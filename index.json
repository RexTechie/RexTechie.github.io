[{"content":"🚏导论 代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。\n🔍索引 代码生成相关模型 MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning DocAgent: A Multi-Agent System for Automated Code Documentation Generation 代码生成评估指标 Evaluating Large Language Models Trained on Code ","permalink":"http://rextechie.github.io/posts/paper_note/code_generate/","summary":"🚏导论 代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。\n🔍索引 代码生成相关模型 MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning DocAgent: A Multi-Agent System for Automated Code Documentation Generation 代码生成评估指标 Evaluating Large Language Models Trained on Code ","title":"代码生成相关论文索引"},{"content":"🚏 导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。\n在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。\n💻 代码 Java代码实现\n🔍 索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 依赖倒置原则(Dependency Inversion Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)\n抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)\n适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)\n观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern) ","permalink":"http://rextechie.github.io/posts/design_patterns/design_patterns/","summary":"🚏 导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。\n在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。\n💻 代码 Java代码实现\n🔍 索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 依赖倒置原则(Dependency Inversion Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)\n抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)\n适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)\n观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern) ","title":"设计模式"},{"content":"基本信息 标题: Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 作者: Minju Seo, Jinheon Baek, Seongyun Lee, Sung Ju Hwang等。 作者单位: KAIST, DeepAuto.ai 期刊/会议: ArXiv 发表年份: 2025 DOI: 2504.17192v2 开源地址: Github 关键词: Large Language Models (LLMs), Code Generation（Machine Learning） 研究背景 (Background) 尽管机器学习研究的迅速增长，但相应的代码实施通常无法实现，这使研究人员重现结果并在先前的工作基础上进行劳动密集型。同时，最近的大型语言模型（LLMS）在了解科学文档并生成高质量代码方面表现出色。\n研究问题 (Research Questions) 用agent复现机器学习相关的论文方法与实验\n核心贡献 (Key Contributions) 提出从科研论文自动生成代码的框架: PaperCoder ​​三阶段工作流程​​：PaperCoder框架将代码生成任务分解为三个结构化的阶段，规划、分析、编码。 构建基准数据集（包含90篇来自ICML、NeurIPS和ICLR 2024的论文） 在PaperBench基准测试中的优异表现：在新发布的PaperBench基准测试中，PaperCoder表现出色，显著优于其他强基线方法。 方法（Methods） 作者引入了PaperCoder，是一种新颖的框架，用于实现研究仓库（论文复现出来的代码仓库）的生成。作者将工作过程建模为M(R) = C，其中M是模型，R是论文，C是代码。受软件开发方法的启发，作者采用了一种结构化的方法，该方法反映了良好的经验验证的软件工程原则，即：规划-分析-实现的工作流程。为了实现这一目标，作者将过程分解为三个阶段：1）规划（Planing）. 2）分析（Analyzing）. 3）编码（Coding）。每个阶段都利用多智能体方案。更加规范化的定义是C = M (P) = M_code(R, P, A)，其中R是论文，P是规划，A是分析。每个部分的生成遵循：P = M_plan(R), A = M_analysis(R, P) and C = M_code(R, P, A)。完整的流程如下图所示：\n规划（Planing） 直接将论文作为输入，生成代码是不现实的，因为论文只要是为了记录一些发现和说服读者自己的方法，而不是作为软件开发的结构化输入。因此论文通常包含补充信息，尽管有些核心概念至关重要，但是与实现无关。这些噪音，都会使得代码生成非常的困难。为了解决这个问题，需要将论文分解为结构化的多个角度的计划。作者用四个步骤来描述论文的分解计划：总体规划、架构设计、逻辑设计和配置文件生成。用公式表示即：Mplan(R) = P = {o, d, l, g}，o表示总体规划的产物，d表示架构设计的产物，l表示逻辑设计的产物，g表示配置文件的产物。每个输出都是在相应的阶段生成的，此阶段遵循一个顺序结构，每个阶段的输出作为下一个输入。\n总体规划（Over Plan） 规划阶段的第一步就是总体规划，涉及概括和组织从大局观（原文使用的是从高级别的角度）的角度看到的实现论文代码所具备的核心要素。提取出来的摘要信息提供了基本的概念框架，可以清楚地指导后续步骤。对应的公式表示是M_plan(R) = o, R表示论文，o表示总体的规划。\n架构设计（Architect Design） 第二阶段是通过上一阶段的产物和论文，来架构软件。设计良好的结构是必不可少的，特别是对于软件系统必须无缝交互的软件系统。这个阶段着重于确定必要的组成部分并定义其关系，以确保井井有条且符合功能的代码仓库。为了实现这个目标，作者要求创建定义软件体系结构的关键artifact。\nFile list: 文件列表是存储库所需的文件的结构化集合，概述了软件的模块化结构。 Class diagram：类图提供了系统数据结构和接口的静态表示，使用UML类图进行描述。 Sequence diagram：时序图以动态表示程序的调用流程和对象直接的交互，同样适用UML表示。 这种结构化方法可确保对软件体系结构的清晰有组织的表示。通过构建这些artifact，可以直观地展示论文中描述的基本组成部分，从而使得代码生成方法更加结构化和系统化。这个过程有助于更好地分析依赖关系，从而确保生成的代码仓库与论文的核心思想保持一致。用公式表示：M_plan(R, o) = d，其中r是论文，o是总体规划，d是架构设计的产物。\n逻辑设计（Logic Design） 在软件开发过程中，各个文件很少独立发挥作用。取而代之的是，它们通常通过导入包和模块交互。比如，如果在utils.py中定义了一个函数a，然后将函数a导入evaluation.py，为了保持正确的依赖结构，utils.py必须在evaluation.py之前实现。为了解决这些依赖性，这个阶段将论文、总体规划的产物和架构设计的产物一起输入。然后分析每个文件及其组件的逻辑，确定必要的依赖项和实现的最佳执行顺序。最终的输出，它会生成一个有序的文件列表，详细说明每个文件作用，以及考虑到依赖关系和仓库内依赖项应实现哪些文件。这个方法可确保存储库的生成不仅考虑单个文件结构，还考虑相互通信，从而促进了组织良好且逻辑上连贯的实现。用公式表示：Mplan(R, o, d) = l，R是论文，o是总体的规划，d是架构设计的产物，l是逻辑设计的产物。\n配置文件生成（Configuration File Generation） 最后，配置文件生成的阶段合成了之前所有的产物，生成包含模型训练所需的超参数和配置文件（config.yaml）。在这个阶段，用户可以查看和修改config.yaml文件，以识别和纠正丢失或错误指定的详细信息。例如用户可能需要指定huggingface数据集的路径或定义checkpoint存储目录。这个步骤有助于减少生成过程中的幻觉，例如产生不存在的数据集或引用错误的文件路径。用公式表示：M_plan(R, o, d, l) = g，R是论文，o是总体的规划，d是架构设计的产物，l是逻辑设计的产物，g是配置文件的产物。\n分析（Analyzing） 规划阶段主要关注设计整体代码的架构并概括大致的路线图，分析阶段主要深入设计每个文件的实现。在这个阶段，对仓库中每个文件的详细目的和必要的考虑进行了彻底的分析。具体而言，这个阶段的输入包括论文以及先前输出的产物，输出包括文件级别的分析准确实现细节，以后将为代码生成过程提供信息。用公式表示：$(\\{0, d, l, g\\}, f_{i}) = a_{i}^{n}$，其中R是论文，d是架构设计的产物，l是逻辑设计的产物，g是配置文件的产物，f是文件，a是分析，n是文件的个数。这个过程对每个文件单独应用，以生产一个文件级的实现计划。\n编码（Coding） 最后的阶段是编码阶段，它会产生构成研究仓库的代码。每个文件的生成都以之前的输出为指导。由于仓库文件直接通常存在导入依赖，因此要求严格遵循规划阶段简历的有序文件列表，确保顺序一致性。用公式表示：$\\{ M_{\\text{coder}}(R, P = \\{0, d, l, g\\}, f_i, a_i) = c_i \\}_{i = 1}^{n(\\text{file})}$，其中R是论文，d是架构设计的产物，l是逻辑设计的产物，g是配置文件的产物，f是文件，a是分析，n是文件的个数，c是文件级代码。最初生成的代码可能需要调试或完善，以确保正确性和完整功能。在这项工作中，综合调试策略和详细的错误纠正工作流程超出了本文的范围。\n实验环境（Experimental Setup） 数据（Data） Paper2Code Benchmark: 数据源于ICML 2024、NeuraIPS 2024 and ICLR 2024。通过OpenReview API过滤出具有开源代码的论文。在其中选择出总代码库少于70000个标记的仓库。为了确保质量，作者评估了基于模型的仓库，并在每个会议选择了得分最高的30篇论文。最终有90篇论文作为实验的基准。对于人类评估，我们选择评估参与者撰写的13篇论文(大多来自于KAIST，不全是顶会)。 PaperBench Code-Dev: 作者进一步使用PaperBench Code-Dev基准验证我们的框架，该基准包含来自ICML 2024的20篇精选论文集。这个数据集来源于OpenAI 2025.04.02发表的PaperBench论文 基线和我们的方法（Baselines and Our Model） Paper2Code Benchmark: 由于没有直接的方法可以实现端到端将论文转为代码，因此作者将几种相关的方法作为基准，尤其是那些用自然语言输入的软件开发设计的方法。 ChatDev MetaGPT Abstract: 一个简单基准，其中只向语言模型提供论文的摘要，要求它根据最少的信息实现代码库。 Paper: 另一个简单的基准，其中将完整论文作为输入，并提示模型生成相应的代码仓库。 PaperCoders（作者的方法） Oracle: 该论文作者发布的官方代码仓库。 PaperBench Code-Dev: 作者将PaperCoders的方法与PaperBench论文中提到的两个智能体进行比较。 Basic Agent：基本智能体遵循ReAct风格的方案，并配备了一套预定义的工具，包括bash shell命令执行器、Python代码运行器、网页浏览器以及用于处理长文档的分页文件阅读器。 Iterative Agent：迭代智能体通过利用全部可用计算时间并融入鼓励通过子目标分解逐步推理的定制提示策略，扩展了基本智能体 评估指标（Evaluation Setup） Paper2Code Benchmark 评估代码生成通常依赖于单元测试或验证特定的实现组件。然而，由于缺乏黄金标准库，因此这类评估不可行。许多论文不发布官方代码，即使发布了，测试脚本也常常不可用。此外，手动标注每篇论文的ground-truth实现细节非常耗时，使得大模型评估不切实际。\nModel-Based Evaluation 为了解决这种挑战，作者提出一种基于模型的评估方法，该方法在上使用或不使用黄金标准库的情况下评估生成仓库的质量。考虑两个变量：1）reference-based，同时使用论文和作者提供的源码。2）reference-free，仅使用论文评估生成的仓库。对于这两种变体，使用语言模型对所需的实现组件进行评价并评估其正确性。它将严重程度级别（高、中、低）分配给任何缺失或存在缺陷的元素，并在1到5的范围上生成一个整体正确性的粉。为确保稳定性，作者使用n-way采样报告多次生成的平均得分。在这个实验中，作者设置n=8并使用o3-mini-high作为一个评估模型。 Reference-Based Evaluation 当存在官方存储库时，将本文中描述的方法视为可能实现的方案。虽然可能存在多个有效的实现，但作者发布的版本视为最准确的版本。在这个实验设置中，作者提供论文和黄金标准仓库作为输入，并且让评估模型来识别和评价所需的组件。然后，模型将预测的库与这些组件进行比较，并从1～5分配一个正确性分数，反映组件覆盖率和任何错误的严重程度。 Reference-Free Evaluation 在许多情况下，作者发布的版本不可用。为了处理此类情况,作者提出一种只根据论文，评价生成的存储库的策略。该模型通过提示词用评估模型评价生成的各个组件，并评估它们是否在生成的仓库中得到充分实现。然后根据这些组件的质量，分配一个1～5的正确性分数。 Human Evaluation 尽管有了模型评估的方式，还是需要人类评估的方法。由于任务复杂，需要理解论文并判断方案的可行性，作者招募了计算机科学专业的MS和PhD学生，要求有至少撰写一篇同行评审论文的经验。评估过程如下 首先，标注着根据论文定义关键事实标准，涵盖数据处理、方法和评估部分。 他们随后对生成的代码库进行审查和排名，分为以下三个比较组: Group1: Model Variants of Our Method 作者的系统使用不同的主干模型（例如，o3-mini vs 其他三个开源方式）； Group2: Navie Baselines. 仅使用论文或摘要作为输入生成的仓库； Group3: Related Works. 由MetaGPT和ChatDev等现有软件开发框架生成的仓库。在每一组中，标注员分配一个相对排名。排名被转换为1-5分的评分。在有三名候选人的小组中，排名第一的仓库获得5分，第二获得3分，第三获得1分。在完成所有组级别的排名之后，注释者被要求选择总体上最好的存储库，并提供一个简短的理由。他们还被问及，排名第一的仓库是否会比从头开始更容易重现论文的方法和实验。如果不是，他们需要解释原因。 最后，标注者重新访问作者的方法生成的仓库，评估之前定义的每个实现标准是否完全（o）、部分（△）或未满足（×）。 PaperBench Code-Dev Evaluation 为了评估作者的系统在PaperBench Code-Dev基准测试上的表现，作者采用了PaperBench官方的评估协议，该协议测量了在精心挑选的ICML 2024论文集中的复制准确性。具体来说，我们遵循原始论文作者撰写的评分标准，该标准定义了一套层次化的实现要求。评估模型根据提交的代码是否正确实现了任何指定要求来评估每个生成的代码库。重要的是，评估仅关注代码开发节点，即候选代码库是否包含某些要求的正确实现。\n实验结果与分析 (Experimental Results \u0026amp; Analysis) Main Results Correlation between Reference-based and Reference-free 作者希望通过这个实验来验证是否可以使用reference-free的评估方法来替代reference-based。实验方法即通过对生成的代码仓库分别使用reference-free和reference-based评分方式进行评分，然后看这两种评分直接是否相关（即是否一致）。\nr（皮尔逊相关系数）：衡量两个变量之间的线性相关程度。范围（-1～+1） p（显著性水平）：p值表示观察到当前数据的结果在“零假设”（即认为两者无相关性）成立的情况下出现的概率。范围（0～1） PaperBench Code-Dev Results 作者想要与OpenAI提出的PaperBench进行比较，分别比较了其论文中提到的BasicAgent和IterativeAgent\nHuman Evaluation Results 为了评估生成代码的实际效用和主观质量，作者进行了全面的人工评估。\nDetailed Analysis on Generated Repository 作者进行更精细的人类评估。具体就是让作者自己从baseline和消融实验变体的仓库中选择一个比较好的一个。77%（13人位作者中的10位）选择了由作者方法生成的仓库，10人里有3人选择了消融变体生成的代码。\n为了进一步评估实用性，询问参与者从头开始相比，排名最高的仓库是否会使复现论文的方法和实验更简单。85%表示了认可。 对于每个论文的每个部分（Data Processing, Method, Evaluation），要求作者评估是否完全实现了每个标准。结果如下所示：\nAnalysis on Human Alignment for Evaluation 这个实验是为了评估模型评估的可信度，上表报告了在reference-based和reference-free的配置下，人类评分与模型评分之间的秩相关。由实验结果表明，人类评分与模型评分的相关性是较高的，因此基于模型的评估方式可以作为参考。\nAnalysis on Different LLMs 作者分别应用DeepSeek-Coder-V2-Lite-Instruct、Qwen2.5-Coder-7B-Instruct、DeepSeek-R1-Distill Qwen-14B、o3-mini-high在框架中。作者的实验结果中，o3-mini-high的模型性能最高。\nAblation Studies Analysis on Executability 为了验证生成的代码不仅结构合理，而且能够在最小干预下执行，作者对五篇代表性论文进行了手动调试分析。对于每种情况，作者都尝试执行生成的存储库，并记录为实现成功运行而修改的行数。\n参考文献 (References) PaperBench: Evaluating AI\u0026rsquo;s Ability to Replicate AI Research 备注 (Notes) 本文实验内容丰富\n优点与创新点 (Strengths) 实验中大量使用了统计学相关的指标来判断模型：皮尔逊系数、显著性水平、秩相关系数 三阶段的设计中侧重于规划阶段的设计，规划阶段中包含绘制类图、时序图，使得编码时更加规范 规划阶段，确定好生成的文件，并文件的功能，分析阶段具体分析各个文件的详细功能。 局限性与不足 (Limitations) 方法缺乏迭代优化 方法中各智能体无法自动实现协作，需要手动一个个执行文件。 我的思考 (Personal Thoughts) 本文由于实验直接执行困难，只能通过模型评估和人类评估的方式进行实验，因此还需要进行实验验证评估方式的有效性。这种实验方式可作为后续实验的参考。\n","permalink":"http://rextechie.github.io/posts/paper_note/paper2code/","summary":"基本信息 标题: Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 作者: Minju Seo, Jinheon Baek, Seongyun Lee, Sung Ju Hwang等。 作者单位: KAIST, DeepAuto.ai 期刊/会议: ArXiv 发表年份: 2025 DOI: 2504.17192v2 开源地址: Github 关键词: Large Language Models (LLMs), Code Generation（Machine Learning） 研究背景 (Background) 尽管机器学习研究的迅速增长，但相应的代码实施通常无法实现，这使研究人员重现结果并在先前的工作基础上进行劳动密集型。同时，最近的大型语言模型（LLMS）在了解科学文档并生成高质量代码方面表现出色。\n研究问题 (Research Questions) 用agent复现机器学习相关的论文方法与实验\n核心贡献 (Key Contributions) 提出从科研论文自动生成代码的框架: PaperCoder ​​三阶段工作流程​​：PaperCoder框架将代码生成任务分解为三个结构化的阶段，规划、分析、编码。 构建基准数据集（包含90篇来自ICML、NeurIPS和ICLR 2024的论文） 在PaperBench基准测试中的优异表现：在新发布的PaperBench基准测试中，PaperCoder表现出色，显著优于其他强基线方法。 方法（Methods） 作者引入了PaperCoder，是一种新颖的框架，用于实现研究仓库（论文复现出来的代码仓库）的生成。作者将工作过程建模为M(R) = C，其中M是模型，R是论文，C是代码。受软件开发方法的启发，作者采用了一种结构化的方法，该方法反映了良好的经验验证的软件工程原则，即：规划-分析-实现的工作流程。为了实现这一目标，作者将过程分解为三个阶段：1）规划（Planing）. 2）分析（Analyzing）. 3）编码（Coding）。每个阶段都利用多智能体方案。更加规范化的定义是C = M (P) = M_code(R, P, A)，其中R是论文，P是规划，A是分析。每个部分的生成遵循：P = M_plan(R), A = M_analysis(R, P) and C = M_code(R, P, A)。完整的流程如下图所示：","title":"Paper2Code"},{"content":"基本信息 标题: PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving 作者: Mihir Parmar、Xin Liu等 作者单位: Google、Arizona State University 期刊/会议: ArXiv 发表年份: 2025 DOI: 2502.16111 开源地址: 🈚️ 关键词: Agent 研究背景与问题 (Background \u0026amp; Questions) 有效的计划是设计在解决复杂现实世界问题的系统的关键组件。传统的用模板化的方式缺乏通用性。 LLM 可以较好的做一些规划任务，比如用 LLM 在自然语言中做规划可以解决一些代码问题。因此作者考虑增强 LLM 生成计划的能力，并证明其在科学和金融领域下游任务的实用性。\n核心贡献 (Key Contributions) 总结本文的主要贡献点：\nPlanGEN，一种新颖的、模型无关的、可扩展的多智能体框架，用于增强LLM的自然规划。 在一些复杂规划和推理的 Benchmarks 上达到了 SOTA 级别。 一种基于约束的验证和基于实例级复杂性的推理算法选择的新方法。 PlanGEN LLM Agents PlanGEN 包括三个 大模型 Agent：Constraint Agent、 Verification Agent 和一个 Selection Agent。每个Agent使用现成的 LLM（如：Gemini, GPT）。\nContstraint Agent “约束”定义为验证问题解决方案所必须的标准。这些标准是具体例子特定的，比如：在 NATURE PLAN 的日历安排中，包括“个人计划”、“可用性”、“偏好”；在 GPQA 的科学推理问题中，约束可能是“使用的概念”、“计算正确性”和“公式选择”。作者认为，提取实例的约束对于成功验证至关重要。Constraint Agent是框架中的预处理组件，负责从问题描述中提取约束。通过分析输入问题，该Agent可以确定生成Plan验证所需的所有可能的关键约束。提取的约束为验证提高 Planning 过程整体相关性和质量的计划提供了基础。Constraint Agent 使用的 Prompt 使其能够通过要求 LLM 关注问题描述的特定方面，系统地识别约束。这样可以确保没有忽略关键信息，并且最终的约束是全面的。\nVerification Agent Verification Agent在框架中发挥着关键作用，通过评估由Constraint Agent生成的约束条件所生成的计划的质量。这个 Agent 用来确保计划和任务目标保持一致，遵守约束，并在逻辑上朝着正确的解决方案进行进展。Verification Agent有两个关键组件：(i) Feedback Generation，以及 (ii) Numerical Reward Generation。\nFeedback Generation 当验证约束与生成的计划，Verification Agent 会生成有关计划质量评估的详细推理。作者把这一过程视为“反馈”，提供了可解释性和可行的下一步改进。\nNumerical Reward Generation 受到Chain-of-experts的启发，作者让 Agent 评估生成的计划和约束，并给出-100 ～ 100的奖励分数。评分机制要求按照严格的质量标准，其阈值表示为高质量的计划（如95）。\nSelection Agent Selection Agent 根据任务的复杂性动态的选择最合适的推理时算法。它利用历史表现、多样性和恢复分数以及来自大模型的指导，自适应地选择当前任务的最佳算法。为了创建 Selection Agent，作者使用了一个修改后的置信区间上界算法（UCB，Upper Confidence Bound）策略。这个策略结合了多个因素：归一化奖励、探索奖金、多样性调整和恢复分数。此外，该 Agent 整合了LLM的先验知识，根据问题描述、任务要求和先前计划（如有）提供算法适用性评分。这些先验条件使 Agent 能够将其选择的算法与输入实例的复杂性和相应的约束对齐，提高所选算法的相关性。\nModified UCB Policy 方程结合了多个术语以平衡在给定任务实例中选择最佳算法时的利用和探索。\n$UCB(a) = \\frac{R(a)}{N(a)} + \\sqrt{\\frac{2 \\log(T+1)}{N(a)}} + \\lambda_{\\text{prior}} \\cdot \\text{Prior}(a) + \\frac{\\alpha_{\\text{diversity}}}{N(a)+1} + \\alpha_{\\text{recovery}} \\cdot S_{\\text{recovery}}(a)$\n第一项$\\frac{R(a)}{N(a)}$表示的是算法 a 的平均奖励得分，其中 $R(a)$ 表示算法 a 的累积的总奖励，$N(a)$ 表示算法 a 被选择的次数。这一项确保优先根据历史经验选择。\n第二项$\\sqrt{\\frac{2 \\log(T+1)}{N(a)}}$ 是探索部分，鼓励选择尝试次数较少的算法。\n第三项$\\lambda_{\\text{prior}} \\cdot \\text{Prior}(a)$ Prior(a) 是基于LLM（大语言模型）的先验评分，用于根据实例复杂性调整算法选择。在这里，λprior是一个动态衰减的权重，定义为λprior = 1+T，其中T代表试验的总数。\n第四项$\\frac{\\alpha_{\\text{diversity}}}{N(a)+1}$ 这一项惩罚被过度使用的算法，确保所有选项的平衡探索。\n第五项$\\alpha_{\\text{recovery}} \\cdot S_{\\text{recovery}}(a)$ S_recovery(a) 是算法 a 的恢复评分，奖励能够有效从失败中恢复的算法。\nSelection Process 选择过程首先要初始化算法的各个变量值，然后，智能体结合LLM引导的先验知识，根据问题陈述和任何提供的反馈为算法生成适宜度分数。这些先验知识来自LLM，并作为调整UCB值的初始估计。\nFramework PlanGen(Best of N) 受 RePrompt 启发，作者改编了 Best of N 算法，并使用他们自己的 Constraint 和 Verification Agent 对其进行修改。这个框架生成 N 个候选Plan（Plan 1, Plan 2, \u0026hellip;Plan n），每个 Plan 由 Verification Agent 根据一组约束进行评估。然后，Verification Agent 分配相应的Reward（Reward 1, Reward 2, \u0026hellip;Reward n）。最后选择 Reward最大的方案，确保得到一个最优解，该解最好地满足问题约束。\n其过程如图所示： PlanGen(ToT) 受 Tree of Thoght 启发，作者用 Constraint 和 Verification 修改了 ToT 算法。该方法首先初始化一个代表问题的根节点，并生成多个潜在的下一步步骤，创建一个树状结构。生成的步骤通过Verification Agent 进行验证，该Agent根据一组约束条件分配奖励分数。遍历过程包括评估给定深度的所有可能步骤，根据奖励分数选择最有希望的路径，并通过生成新步骤进一步扩展它。\n其过程如图所示： PlanGen(REBASE) 该框架集成了动态选择和扩展策略，以迭代优化解决方案。在树的每个深度，候选节点根据其分配的奖励分数（使用Verification Agent获得）进行排名，确保首先探索最有希望的候选者。即使奖励较低的步骤也被考虑，但随着子节点数量的减少，意味着它们的探索深度有限。这种层次化剪枝有助于保持效率，从而减少对较弱节点的无谓探索。这个过程会持续进行，直到找到有效、完整的解决方案或达到预定义的深度或宽度限制。此外，还有一个类似于ToT的完成检查，它可以识别代表完整解决方案的节点，一旦确定了令人满意的结果，REBASE就可以提前终止。\n其过程如图所示： PlanGen(Mixture of Algorithms) 算法混合框架（图1）引入了一个Selection Agent，该 Agent 根据实例级复杂度动态选择上述章节中提出的inference-time algorithm。该框架以模块化和迭代的方式运行，确保在有效解决不同复杂度的规划和推理问题时具有适应性。\nOrchestration 这个过程开始于用 LLM 根据任务和问题描述生成一个初步的计划。与此同时，Constraint Agent来生成特定任务和问题的约束集。根据约束条件，Verification Agent 评估初步计划的质量并提供一个奖励分数。如果初步计划达到所需的阈值，则可作为最终计划接受，否则，开始Iterative Refinement过程。\nIterative Refinement 这个优化循环由一系列推理算法驱动。在这次Iterative Refinement过程中，Selection Agent 根据实例特定的复杂性和历史的 UCB 值确定最合适的算法。所选算法生成一个更新后的计划，然后由Verification Agent 重新评估。为确保持续改进，框架纳入了由提供指导的Verification Agent 生成的反馈，这个反馈循环使系统能够逐步优化计划。\n实验与结果（Experiments and Results） 实验安排（Experiment Setup） Datasets 为了展示自然规划能力的提升，我们使用了NATURAL PLAN。在改进计划后，我们表明这显著增强了LLMs在两个基准上的推理能力：GPQA和OlympiadBench（仅文本）。此外，我们表明PlanGEN在特定领域数据集DocFinQA上提高了性能。\nBaselines and Our Frameworks 我们为与我们的框架进行比较开发了两个baselines：(i) Zero-shot CoT 和 (ii) a Vanilla Multi-Agent Baseline。在 Zero-shot COT，作者为框架提供了输入提示，该模型以\u0026lt;Cot reasoning\u0026gt;的形式生成输出。对于 Multi-Agent Baseline， 相同的模型在多次迭代中反复调用。系统通过反馈循环反复优化其输出，其中反馈是基于一个旨在提高推理能力的自我反思提示词生成的。我们在所有基准上评估所有提出的框架。对于推理任务，我们采用两阶段方法：(1) 使用我们的框架生成一个优化方案，(2) 执行产生最终答案的计划。\n主要结果（Main Results） 下图比较了各种单智能体和多智能体baselines（baselines间有所不同——GPQA的一些单智能体基线来自gpqa-eval的多智能体框架的性能。从结果来看，多智能体框架始终优于baselines。\nPerformance on NATURAL PLAN 对于图 a 可以看出，PlanGen(Best of N)在所有任务中取得了最高的 EM 分数：60.7(Calendar), 43.8(Metting) 和 41.63(Trip)。在所有四个框架都比最强的 Baseline(多智能体) 高出约 10%。对于会议和旅游计划，除了 ToT 之外，所有框架都比最好的 Baseline(Gemini-1.5-Pro) 分别高出约 6% 和约 7%。PlanGEN(Mixture of Algo.) 在会议和旅游计划中达到了第二高的表现，而在日程计划中仍然具有竞争力。这些结果证明了我们的框架在处理多样化的自然语言规划任务以及建立 NATURAL PLAN 三个类别 SOTA的有效性。\nPerformance on OlympiadBench 从图b来看，PlanGEN(Mixture of Algo.) 在数学分类上达到了最高的准确性(55.94%), 表现优于最强的Baseline(Multi-Agent, 50.68%) 大约 5%。值得注意的是，PlanGEN（Mixture of Algo.）在MATH中的卓越性能突显了其在复杂数学推理中的有效性，为MATH达到了SOTA。在PHY类别中，所有多智能体框架都超越了Gemini-1.5-Flash（最强基线），其中PlanGEN（Best of N）实现了最高的准确率（31.78%），在PHY达到了SOTA。\nPerformance on GPQA 从图c可以看出，PlanGEN（Mixture of Algo.）实现了最高的准确率（59.6%）。单个推理时间算法的性能较低，表明选择是有用的。所有提出的框架都大幅优于Gemini-1.5-Pro（46.2%）、GPT模型（∼48%）和Claude-3-Opus（50.4%）。而Claude-3.5-Sonnet和Multi-Agent Baseline与PlanGEN（Mixture of Algo.）相比，表现具有竞争力（∼59%）。\nPerformance on DocFinQA 从图d可以看出，我们的框架在DocFinQA上的性能显著提升，PlanGEN（Best of N）实现了最高的准确率（31.16%）和F1分数（29.45%），为该任务设定了SOTA。所有我们的框架都大幅超越了Gemini-1.5-Pro（最强Baseline）（∼7%）。这些结果突出了多智能体框架在金融文档理解以及在其上进行推理的有效性。\nPerformance of our frameworks w.r.t. different complexity 如图所示，我们对从NATURAL PLAN到日程调度任务的案例进行了研究，以分析不同复杂度级别对不同框架性能的影响。对于日程调度，我们发现PlanGEN（ToT）在简单问题上的表现最佳，而PlanGEN（Best of N）在中级问题上更为有效。随着复杂度的增加，PlanGEN（混合算法）被证明是最有效的方法。我们进一步对附录E中NATURAL PLAN提出的会议和行程规划进行了类似的分析。\nMain Findings 与单代理系统相比，多代理框架在生成优化规划轨迹方面表现始终如一（图5）。此外，多代理（Baseline）并不总是最强的基准，因为自我校正可能带来挑战，如黄等人在2024年所示。因此，系统内的不同代理需要不同的处理策略，类似于我们的PlanGEN。此外，即使在PlanGEN的多代理框架中，依赖inference-time algorithm对于更复杂的问题来说也证明是不够的（图6）。PlanGEN（Mixture of Algo.）方法在解决复杂规划问题方面具有显著优势，突出了根据实例特定复杂性选择算法的重要性（图1）。鉴于我们的框架是多代理的，我们在下一节进一步讨论了LLM调用次数与它们性能之间的关系。\n参考文献 (References) Os-copilot: Towards generalist computer agents with self-improvement. AFlow: Automating agentic workflow generation 备注 (Notes) 优点与创新点 (Strengths) 提供了一个选择inference-time algorithm的算法，这个算法基于数学理论算法扩展得到，不是简单通过让 LLM 选择。 局限性与不足 (Limitations) 作者没有提供开源代码，无法复现实验结果。 我的思考 (Personal Thoughts) 综述与我研究的相关性：能否让智能体自己规划编写项目的计划，然其他智能体进行实现与验证？ 是否有可以改进的地方：增加框架 后续可能的研究方向：将项目规划能力融入项目级代码生成中 ","permalink":"http://rextechie.github.io/posts/paper_note/plangen/","summary":"基本信息 标题: PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving 作者: Mihir Parmar、Xin Liu等 作者单位: Google、Arizona State University 期刊/会议: ArXiv 发表年份: 2025 DOI: 2502.16111 开源地址: 🈚️ 关键词: Agent 研究背景与问题 (Background \u0026amp; Questions) 有效的计划是设计在解决复杂现实世界问题的系统的关键组件。传统的用模板化的方式缺乏通用性。 LLM 可以较好的做一些规划任务，比如用 LLM 在自然语言中做规划可以解决一些代码问题。因此作者考虑增强 LLM 生成计划的能力，并证明其在科学和金融领域下游任务的实用性。\n核心贡献 (Key Contributions) 总结本文的主要贡献点：\nPlanGEN，一种新颖的、模型无关的、可扩展的多智能体框架，用于增强LLM的自然规划。 在一些复杂规划和推理的 Benchmarks 上达到了 SOTA 级别。 一种基于约束的验证和基于实例级复杂性的推理算法选择的新方法。 PlanGEN LLM Agents PlanGEN 包括三个 大模型 Agent：Constraint Agent、 Verification Agent 和一个 Selection Agent。每个Agent使用现成的 LLM（如：Gemini, GPT）。","title":"PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving"},{"content":"🚏 导论 代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。\n代理模式的应用场景\n远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 🚦 结构 UML类图 classDiagram class Client{ } class Subject{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +Request() } class RealSubject{ +Request() } class Proxy{ -realSubject: RealSubject +Request() } Client --\u0026gt; Subject Subject \u0026lt;|.. RealSubject Subject \u0026lt;|.. Proxy 代码实现 Subject类，定义了RealSubject和Proxy的公共接口，这样就在任何使用RealSubject的地方都可以使用Proxy\npublic class abstract Subject { public abstract void Request(); } RealSUbject类，定义Proxy所代表的真实实体\npublic class RealSubject extends Subject { @Override public void Request() { System.out.println(\u0026#34;真实的请求\u0026#34;); } } Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject相同的接口，这样代理就可以用来代替实体\npublic class Proxy extends Subject { private RealSubject realSubject; @Override public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } realSubject.Request(); } } 客户端代码\npublic class Client { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.Request(); } } 🎭 优缺点分析 😊 优点 🙁 缺点 🎬 场景 一个谈恋爱的问题，小刚喜欢小红，但是小刚不好意思直接追小红，于是乎他找了小明帮忙，想让小明帮他送礼物给小红。这样的关系如何用代码来实现呢？\n🛠 解决 没有代理的代码 首先来尝试写出，如果小刚直接追小红的代码。\nclassDiagram class 追求者{ +送洋娃娃🪆() +送鲜花💐() +送巧克力🍫() } class 被追求者{ -姓名: String } ","permalink":"http://rextechie.github.io/posts/design_patterns/proxy_pattern/","summary":"🚏 导论 代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。\n代理模式的应用场景\n远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 🚦 结构 UML类图 classDiagram class Client{ } class Subject{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +Request() } class RealSubject{ +Request() } class Proxy{ -realSubject: RealSubject +Request() } Client --\u0026gt; Subject Subject \u0026lt;|.. RealSubject Subject \u0026lt;|.. Proxy 代码实现 Subject类，定义了RealSubject和Proxy的公共接口，这样就在任何使用RealSubject的地方都可以使用Proxy\npublic class abstract Subject { public abstract void Request(); } RealSUbject类，定义Proxy所代表的真实实体\npublic class RealSubject extends Subject { @Override public void Request() { System.out.println(\u0026#34;真实的请求\u0026#34;); } } Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject相同的接口，这样代理就可以用来代替实体\npublic class Proxy extends Subject { private RealSubject realSubject; @Override public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } realSubject.","title":"Proxy_pattern"},{"content":"🚏 导论 装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。当现有目标功能不足的时候，需要增强时，可以考虑使用装饰模式。\n装饰模式把每个要装饰的代码放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。\n装饰器常在面向切面编程（AOP）中使用，比如日志、事务、权限等功能。\n🚦 结构 UML类图 classDiagram class Component{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +operation() } class ConcreteComponent{ +operation() } class Decorator{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; -component: Component +operation() } class ConcreteDecoratorA{ -addedState +operation() } class ConcreteDecoratorB{ +operation() -AddedBehavior() } Component \u0026lt;|-- ConcreteComponent Component \u0026lt;|-- Decorator Decorator o-- Component Decorator \u0026lt;|-- ConcreteDecoratorA Decorator \u0026lt;|-- ConcreteDecoratorB Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。\n装饰模式是利用setComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。\n基本代码 Component类\npublic interface Component { void operation(); } ConcreteComponent类\npublic class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\u0026#34;具体对象的操作\u0026#34;); } } Decorator类\npublic abstract class Decorator implements Component { protected Component component; public void setComponent(Component component) { this.component = component; } @Override public void operation() { if (component != null) { component.operation(); } } } ConcreteDecoratorA类\npublic class ConcreteDecoratorA extends Decorator { private String addedState; @Override public void operation() { super.operation(); addedState = \u0026#34;New State\u0026#34;; System.out.println(\u0026#34;具体装饰对象A的操作\u0026#34;); } } ConcreteDecoratorB类\npublic class ConcreteDecoratorB extends Decorator { @Override public void operation() { super.operation(); addedBehavior(); System.out.println(\u0026#34;具体装饰对象B的操作\u0026#34;); } private void addedBehavior() { System.out.println(\u0026#34;为具体装饰对象B增加额外的行为addedBehavior()\u0026#34;); } } 客户端代码\npublic class Client { public static void main(String[] args) { Component component = new ConcreteComponent(); Decorator decoratorA = new ConcreteDecoratorA(); Decorator decoratorB = new ConcreteDecoratorB(); decoratorA.setComponent(component); decoratorB.setComponent(decoratorA); decoratorA.operation(); decoratorB.operation(); } } 🎭 优缺点分析 😊 优点 有效地将类的核心职责和装饰功能区分开，而且可以去除相关类中重复的装饰逻辑。 🙁 缺点 会产生很多小对象，增加了系统的复杂性。 🎬 场景 现有一需求，要求写一个可以给人搭配不同服饰的系统，比如类似QQ、网络游戏或论坛都有的Avatar系统。\n🛠 解决 第一版代码 classDiagram class 人 { +穿大T恤() +穿垮裤() +穿破球鞋() +穿西装() +打领带() +穿皮鞋() +形象展示() } Person类的代码如下：\npublic class Person { /** * 姓名 */ private String name; public Person(String name) { this.name = name; } public void wearTShirts() { System.out.print(\u0026#34;大T恤 \u0026#34;); } public void wearBigTrouser() { System.out.print(\u0026#34;垮裤 \u0026#34;); } public void wearSneakers() { System.out.print(\u0026#34;破球鞋 \u0026#34;); } public void wearSuit() { System.out.print(\u0026#34;西装 \u0026#34;); } public void wearTie() { System.out.print(\u0026#34;领带 \u0026#34;); } public void wearLeatherShoes() { System.out.print(\u0026#34;皮鞋 \u0026#34;); } public void show() { System.out.print(\u0026#34;装扮的\u0026#34; + name); } } 客户端代码：\npublic class Client { public static void main(String[] args) { Person rex = new Person(\u0026#34;Rex\u0026#34;); System.out.print(\u0026#34;\\n第一种装扮：\u0026#34;); rex.wearTShirts(); rex.wearBigTrouser(); rex.wearSneakers(); rex.show(); System.out.print(\u0026#34;\\n第二种装扮：\u0026#34;); rex.wearSuit(); rex.wearTie(); rex.wearLeatherShoes(); rex.show(); } } 但是这样就违背了开闭原则，如果要增加一种装扮，就需要修改Person类，这样就不符合开闭原则。可以考虑将这些服饰都写成子类。\n第二版代码（用面向对象的思路构造） classDiagram class 人{ +形象展示() } class 服饰{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +形象展示 } class 大T恤{ +形象展示() } class 垮裤{ +形象展示() } class 破球鞋{ +形象展示() } class 西装{ +形象展示() } class 领带{ +形象展示() } class 皮鞋{ +形象展示() } 服饰 \u0026lt;|-- 大T恤 服饰 \u0026lt;|-- 垮裤 服饰 \u0026lt;|-- 破球鞋 服饰 \u0026lt;|-- 西装 服饰 \u0026lt;|-- 领带 服饰 \u0026lt;|-- 皮鞋 Person类\npublic class Person { /** * 姓名 */ private String name; public Person(String name) { this.name = name; } public void show() { System.out.print(\u0026#34;装扮的\u0026#34; + name); } } 服饰抽象类\npublic abstract class Finery { /** * 服饰抽象方法 */ public abstract void show(); } 各种服饰子类\npublic class BigTrouser extends Finery { /** * 垮裤展示 */ @Override public void show() { System.out.print(\u0026#34;垮裤 \u0026#34;); } } public class LeatherShoes extends Finery { /** * 皮鞋展示 */ @Override public void show() { System.out.print(\u0026#34;皮鞋 \u0026#34;); } } // ... 客户端类\npublic class Client { public static void main(String[] args) { Person rex = new Person(\u0026#34;Rex\u0026#34;); System.out.print(\u0026#34;\\n第一种装扮：\u0026#34;); Finery tShirts = new TShirts(); Finery bigTrouser = new BigTrouser(); Finery sneakers = new Sneakers(); tShirts.show(); bigTrouser.show(); sneakers.show(); rex.show(); System.out.print(\u0026#34;\\n第二种装扮：\u0026#34;); Finery suit = new Suit(); Finery tie = new Tie(); Finery leatherShoes = new LeatherShoes(); suit.show(); tie.show(); leatherShoes.show(); rex.show(); } } 虽然改写成了面向对象写法，实现了“服饰”与“人”类的分离，但是分离的有点过度了，这就好像一个人当众光着身子将衣服穿起来，应该是要在内部组装好再展示出来。\n第三版（用装饰模式改造） classDiagram class 人{ +形象展示() } class 服饰{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +形象展示() } class 大T恤{ +形象展示() } class 垮裤{ +形象展示() } class 破球鞋{ +形象展示() } class 西装{ +形象展示() } class 领带{ +形象展示() } class 皮鞋{ +形象展示() } 人 \u0026lt;|-- 服饰 服饰 \u0026lt;|-- 大T恤 服饰 \u0026lt;|-- 垮裤 服饰 \u0026lt;|-- 破球鞋 服饰 \u0026lt;|-- 西装 服饰 \u0026lt;|-- 领带 服饰 \u0026lt;|-- 皮鞋 \u0026ldquo;Person\u0026quot;类(ConcreteComponent)\npublic class Person { /** * 姓名 */ private String name; public Person() { } public Person(String name) { this.name = name; } public void show() { System.out.print(\u0026#34;装扮的\u0026#34; + name); } } 服饰类(Decorator)\npublic class Finery extends Person { /** * 被装饰者 */ protected Person component; /** * 装饰 * * @param component 被装饰者 */ public void decorate(Person component) { this.component = component; } /** * 展示 */ @Override public void show() { if (component != null) { component.show(); } } } 具体服饰类(ConcreteDecorator)\npublic class BigTrouser extends Finery { /** * 垮裤展示 */ @Override public void show() { System.out.print(\u0026#34;垮裤 \u0026#34;); super.show(); } } public class LeatherShoes extends Finery { /** * 皮鞋展示 */ @Override public void show() { System.out.print(\u0026#34;皮鞋 \u0026#34;); super.show(); } } //... 客户端类\npublic class Client { public static void main(String[] args) { Person rex = new Person(\u0026#34;Rex\u0026#34;); System.out.print(\u0026#34;\\n第一种装扮：\u0026#34;); TShirts tShirts = new TShirts(); BigTrouser bigTrouser = new BigTrouser(); Sneakers sneakers = new Sneakers(); sneakers.decorate(rex); bigTrouser.decorate(sneakers); tShirts.decorate(bigTrouser); tShirts.show(); System.out.print(\u0026#34;\\n第二种装扮：\u0026#34;); Finery suit = new Suit(); Finery tie = new Tie(); Finery leatherShoes = new LeatherShoes(); leatherShoes.decorate(rex); tie.decorate(leatherShoes); suit.decorate(tie); rex.show(); } } ","permalink":"http://rextechie.github.io/posts/design_patterns/decorator_pattern/","summary":"🚏 导论 装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。当现有目标功能不足的时候，需要增强时，可以考虑使用装饰模式。\n装饰模式把每个要装饰的代码放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。\n装饰器常在面向切面编程（AOP）中使用，比如日志、事务、权限等功能。\n🚦 结构 UML类图 classDiagram class Component{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +operation() } class ConcreteComponent{ +operation() } class Decorator{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; -component: Component +operation() } class ConcreteDecoratorA{ -addedState +operation() } class ConcreteDecoratorB{ +operation() -AddedBehavior() } Component \u0026lt;|-- ConcreteComponent Component \u0026lt;|-- Decorator Decorator o-- Component Decorator \u0026lt;|-- ConcreteDecoratorA Decorator \u0026lt;|-- ConcreteDecoratorB Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。\n装饰模式是利用setComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。\n基本代码 Component类\npublic interface Component { void operation(); } ConcreteComponent类\npublic class ConcreteComponent implements Component { @Override public void operation() { System.","title":"装饰模式（Decorator Pattern）"},{"content":"🚏 导论 里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。\n里氏替换原则是Barbara Liskov女士在1988年发表的，A behavioral notion of subtyping, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n由于有里氏替换原则，才使得开放-封闭成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。\n🎬 场景 场景一：🐒 动物世界 因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。\n","permalink":"http://rextechie.github.io/posts/design_patterns/liskov_substitution_principle/","summary":"🚏 导论 里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。\n里氏替换原则是Barbara Liskov女士在1988年发表的，A behavioral notion of subtyping, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n由于有里氏替换原则，才使得开放-封闭成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。\n🎬 场景 场景一：🐒 动物世界 因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。","title":"里氏替换原则(Liskov Substitution Principle)"},{"content":"🚏 导论 依赖倒转原则\nA. 高层模块不应该依赖低层模块。两个都应该依赖抽象。\nB. 抽象不应该依赖细节。细节应该依赖抽象。\n🎬 场景 场景一：📦 修电脑 当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（单一职责原则、开放-封闭原则）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。 与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。\n","permalink":"http://rextechie.github.io/posts/design_patterns/dependency_inversion_principle/","summary":"🚏 导论 依赖倒转原则\nA. 高层模块不应该依赖低层模块。两个都应该依赖抽象。\nB. 抽象不应该依赖细节。细节应该依赖抽象。\n🎬 场景 场景一：📦 修电脑 当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（单一职责原则、开放-封闭原则）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。 与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。","title":"依赖倒转原则(Dependency Inversion Principle)"},{"content":"🚏 导论 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）\n我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。\n具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\n开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n🎬 场景 场景一：🏢 公司管理 现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。\n","permalink":"http://rextechie.github.io/posts/design_patterns/open_closed_principle/","summary":"🚏 导论 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）\n我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。\n具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\n开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n🎬 场景 场景一：🏢 公司管理 现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。","title":"开放-封闭原则(Open Closed Principle)"},{"content":"🚏 导论 单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。\n🎬 场景 场景一：📱 手机 现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。\n当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。\n场景二：♦️ 俄罗斯方块 俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。\n这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。\n","permalink":"http://rextechie.github.io/posts/design_patterns/signle_responsibility_principle/","summary":"🚏 导论 单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。\n🎬 场景 场景一：📱 手机 现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。\n当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。\n场景二：♦️ 俄罗斯方块 俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。\n这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。","title":"单一职责原则(Single Responsibility Principle)"},{"content":"🚏 导论 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以用策略模式封装几乎任何类型的规则，只要分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这些变化的可能性。\n🧀 前置知识 🚦 结构 UML 类图 classDiagram class Context{ -strategy: Strategy +Context(strategy: Strategy) +contextInterface() } class Strategy{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +algorithmInterface() } class ConcreteStrategyA{ +algorithmInterface() } class ConcreteStrategyB{ +algorithmInterface() } class ConcreteStrategyC{ +algorithmInterface() } Context o-- Strategy Strategy \u0026lt;|-- ConcreteStrategyA Strategy \u0026lt;|-- ConcreteStrategyB Strategy \u0026lt;|-- ConcreteStrategyC 基本代码 Strategy类，定义所有支持的算法的公共接口。\npublic abstract class Strategy { /** * 算法方法 */ public abstract void algorithmInterface(); } ConcreteStrategy类，实现具体的算法。\nclass ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法A实现\u0026#34;); } } class ConcreteStrategyB extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法B实现\u0026#34;); } } class ConcreteStrategyC extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法C实现\u0026#34;); } } Context, 用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。\npublic class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void contextInterface() { strategy.algorithmInterface(); } } 客户端代码\npublic static void main(String[] args) { Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); } 🎭 优缺点分析 😊 优点 策略模式的Strategy层次为Context定义了一系列可重用的算法或行为。继承有助于提取这些算法的公共功能。 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 🙁 缺点 在基本的策略模式中，选择所用具体实现的职责有客户端对象承担，并转给策略模式的Context对象，其实并没有减轻客户端的负担。（可以考虑💭用策略模式+简单工厂模式，但即使是这种方式，也有不足之处，每次更改 算法都要修改Context中的switch代码，这个问题可以用反射来解决） 🎬 场景 现要做一个商场收银系统，营业员根据客户所购买商品的单价和数量，向客户收费。如下图所示：\n初步设计后，关键代码如下所示：\n// 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText()); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 但是如果要增加打折功能，就需要修改代码，在totalPrices后乘以折扣，商场活动结束再修改回去。 显然不够灵活。\n这时候可以考虑增加下拉选项，选择不同的折扣方式，如下图所示： 修改后的代码如下所示：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;打八折\u0026#34;, \u0026#34;打七折\u0026#34;, \u0026#34;打五折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { int selectedIndex = discountComboBox.getSelectedIndex(); double discount = 1; switch (selectedIndex) { case 1: discount = 0.8; break; case 2: discount = 0.7; break; case 3: discount = 0.5; break; default: discount = 1; break; } System.out.println(\u0026#34;选中的折扣：\u0026#34; + selectedIndex); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText()) * discount; // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), discountComboBox.getSelectedItem(), totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 这样修改后的代码虽然实现了功能，但是代码量增加，且不够灵活。每次增加新的折扣方式，都需要修改代码。\n🛠 解决 简单工厂模式 当折扣的业务变多时，频繁修改计算总价代码，不符合开闭原则。可以使用简单工厂模式，将计算总价的代码抽取出来，放到一个类中，根据不同的折扣方式，创建不同的类。\nclassDiagram class CashSuper{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +acceptCash(money: double): double } class CashNormal{ +acceptCash(money: double): double } class CashRebate{ +acceptCash(money: double): double } class CashReturn{ +acceptCash(money: double): double } class CashFactory{ +createCashAccept(type: String): CashSuper } CashSuper \u0026lt;|-- CashNormal CashSuper \u0026lt;|-- CashRebate CashSuper \u0026lt;|-- CashReturn CashFactory --\u0026gt; CashSuper 现金收费抽象类\npublic abstract class CashSuper{ /** * 现金收取超类的抽象方法 * @param money 原价 * @return 折后价 */ public abstract double acceptCash(double money); } 正常收费子类：\npublic class CashNormal extends CashSuper{ /** * 正常收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { return money; } } 打折收费子类：\npublic class CashRebate extends CashSuper{ private double moneyRebate = 1d; public CashRebate(String moneyRebate) { this.moneyRebate = Double.parseDouble(moneyRebate); } /** * 打折收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { return money * moneyRebate; } } 返利收费子类：\npublic class CashReturn extends CashSuper{ private double moneyCondition = 0.0d; private double moneyReturn = 0.0d; public CashReturn(String moneyCondition, String moneyReturn) { this.moneyCondition = Double.parseDouble(moneyCondition); this.moneyReturn = Double.parseDouble(moneyReturn); } /** * 返利收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { double result = money; if (money \u0026gt;= moneyCondition) { result = money - Math.floor(money / moneyCondition) * moneyReturn; } return result; } } 现金收费工厂类：\npublic class CashFactory { /** * 现金收取工厂 * @param type 收费类型 * @return CashSuper */ public static CashSuper createCashAccept(String type){ CashSuper cs = null; switch (type){ case \u0026#34;正常收费\u0026#34;: cs = new CashNormal(); break; case \u0026#34;满300返100\u0026#34;: cs = new CashReturn(\u0026#34;300\u0026#34;,\u0026#34;100\u0026#34;); break; case \u0026#34;打8折\u0026#34;: cs = new CashRebate(\u0026#34;0.8\u0026#34;); break; default: break; } return cs; } } 客户端主要部分：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { String cashType = (String) discountComboBox.getSelectedItem(); CashSuper cs = CashFactory.createCashAccept(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cs.acceptCash(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 简单工程虽然也能解决这个问题，这个模式知识解决对象创建问题，而且由于工厂本身包括了所有收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或拓展都要改动这个工厂，以致代码需要重新编译部署，不够灵活，所以它不是最好的办法。面对算法的时常变动，应该有更好的办法。\n策略模式 其实上面写的用简单工程模式实现的商场收银系统，已经是策略模式的一个简单应用了。在基于策略模式的代码改写上述程序。\nclassDiagram class CashContext{ -cashSuper: CashSuper +CashContext(type: String) +getResult(money: double): double } class CashSuper{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +acceptCash(money: double): double } class CashNormal{ +acceptCash(money: double): double } class CashRebate{ +acceptCash(money: double): double } class CashReturn{ +acceptCash(money: double): double } CashSuper \u0026lt;|-- CashNormal CashSuper \u0026lt;|-- CashRebate CashSuper \u0026lt;|-- CashReturn CashContext --\u0026gt; CashSuper CashContext类：\nppublic class CashContext { private CashSuper cs; public CashContext(CashSuper cs) { this.cs = cs; } public double getResult(double money) { return cs.acceptCash(money); } } 客户端主要部分：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { CashContext cc = null; String cashType = (String) discountComboBox.getSelectedItem(); switch (cashType) { case \u0026#34;满300返100\u0026#34;: cc = new CashContext(new CashReturn(\u0026#34;300\u0026#34;, \u0026#34;100\u0026#34;)); break; case \u0026#34;打8折\u0026#34;: cc = new CashContext(new CashRebate(\u0026#34;0.8\u0026#34;)); break; default: cc = new CashContext(new CashNormal()); break; } CashSuper cs = CashFactory.createCashAccept(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cc.getResult(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 但是这样还是回到了原来的问题，在客户端代码中，还是需要根据不同的折扣方式，创建不同的类，这样还是不够灵活。\n简单工厂 + 策略模式 可以尝试用简单工厂模式和策略模式结合，将创建对象的过程交给工厂，客户端只需要知道折扣方式即可。\n改造后的CashContext类：\npublic class CashContext { private CashSuper cs; public CashContext(String type) { switch (type){ case \u0026#34;正常收费\u0026#34;: this.cs = new CashNormal(); break; case \u0026#34;满300返100\u0026#34;: this.cs = new CashReturn(\u0026#34;300\u0026#34;, \u0026#34;100\u0026#34;); break; case \u0026#34;打8折\u0026#34;: this.cs = new CashRebate(\u0026#34;0.8\u0026#34;); break; default: break; } } public double getResult(double money) { return cs.acceptCash(money); } } 客户端代码\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { String cashType = (String) discountComboBox.getSelectedItem(); CashContext cc = new CashContext(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cc.getResult(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 客户端代码与简单工程的不同\n// 简单工厂 CashSuper cs = CashFactory.createCashAccept(cashType); // 简单工厂 + 策略模式 CashContext cc = new CashContext(cashType); 在简单工厂，客户端需要知道CashFactory和CashSuper，而在简单工厂 + 策略模式中，客户端只需要知道CashContext即可。耦合性更低了。使得具体的收费算法和客户端分离，可以相互独立地变化。\n","permalink":"http://rextechie.github.io/posts/design_patterns/strategy_pattern/","summary":"🚏 导论 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以用策略模式封装几乎任何类型的规则，只要分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这些变化的可能性。\n🧀 前置知识 🚦 结构 UML 类图 classDiagram class Context{ -strategy: Strategy +Context(strategy: Strategy) +contextInterface() } class Strategy{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +algorithmInterface() } class ConcreteStrategyA{ +algorithmInterface() } class ConcreteStrategyB{ +algorithmInterface() } class ConcreteStrategyC{ +algorithmInterface() } Context o-- Strategy Strategy \u0026lt;|-- ConcreteStrategyA Strategy \u0026lt;|-- ConcreteStrategyB Strategy \u0026lt;|-- ConcreteStrategyC 基本代码 Strategy类，定义所有支持的算法的公共接口。\npublic abstract class Strategy { /** * 算法方法 */ public abstract void algorithmInterface(); } ConcreteStrategy类，实现具体的算法。\nclass ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.","title":"策略模式（Strategy Pattern）"},{"content":"🚏 导论 抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。\n🧀 前置知识 工厂方法模式（Factory Method） 🚦 结构 classDiagram class AbstractFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createProductA() +createProductB() } class ConcreteFactory1{ +createProductA() +createProductB() } class ConcreteFactory2{ +createProductA() +createProductB() } class AbstractProductA{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductA1 class ProductA2 class AbstractProductB{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductB1 class ProductB2 class Client AbstractFactory \u0026lt;|.. ConcreteFactory1 AbstractFactory \u0026lt;|.. ConcreteFactory2 AbstractProductA \u0026lt;|.. ProductA1 AbstractProductA \u0026lt;|.. ProductA2 AbstractProductB \u0026lt;|.. ProductB1 AbstractProductB \u0026lt;|.. ProductB2 Client --\u0026gt; AbstractFactory Client --\u0026gt; AbstractProductA Client --\u0026gt; AbstractProductB AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。\nAbstractFactory是一个抽象工厂，它里面包含所有产品创建的抽象方法，而ConcreteFactory1和ConcreteFactory2就是两个具体的工厂了。\n通常在运行时在创建一个ConcreteFactory的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。\n🎭 优缺点分析 😊 优点 易于交换产品系列，由于具体工厂类在一个应用中只需要初始化的时候出现一次，这就使得改编一个应用的具体工厂变得非常简单。它只需要改变具体工厂即可使用不同的产品配置。 它让具体的创建实例过程与客户端分离，客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。 🙁 缺点 增加需求时，需要增加新的产品类，并且要调整工厂类，这增加了系统的复杂度。 每次使用都需要声明Factory，但是如果要更改产品系列，那么就需要更改所有的Factory声明。 🎬 场景 公司有一个给第三方企业做的电子商务网站，使用SQL Server数据库，已经都大致完成了。但是公司又接了另外一家公司类似的需求项目，但是这家公司想省钱，要用Access数据库。因此任务就变成了要将整个项目调整为用Access数据库。\n但是替换的过程中出现了很多问题。\nSQL Server的命名空间和Access数据库不同：SQL Server上用的是System.Data.SqlClient，而Access上用的是System.Data.OleDb。 数据库操作语法不同： Access插入数据必须用INSERT INTO，而SQL Server用INSERT（不能用INTO）。 SQL Server中的GetDate()函数在Access中是Now()。 SQL Server中有Substring()函数，而Access中是Mid()。 关键字不同 Access不能用password作为字段名，因为它是关键字，而SQL Server可以。要使用关键字需要用[]括起来。 \u0026hellip; 如果今后要换成其他数据库，那么这个项目就要重新调整。这样的设计显然是不合理的。\n🛠 解决 最初的代码 用户实体: User.java\npublic class User { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } SqlServerUser.java: 用于操作User表\npublic class SqlServerUser { public void insertUser(User user) { System.out.println(\u0026#34;在SQL Server中给User表增加一条记录\u0026#34;); } public User getUser(Integer id) { System.out.println(\u0026#34;在SQL Server中根据ID得到User表一条记录\u0026#34;); return null; } } Client.java: 客户端测试类\npublic class Client { public static void main(String[] args) { User user = new User(); SqlServerUser su = new SqlServerUser(); su.insertUser(user); su.getUser(1); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); } } 这里之所以不能换数据库，愿意在于SqlServerUser su = new SqlServerUser()使得su这个对象被框死在SQL Server上了。如果这里改成多态，那么在执行‘su.insertUser(user);’和‘su.getUser(1)’时就不需要考虑是Access还是Sql Server了。\n初步改造 考虑用工厂方法模式（工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类）进行改造。\nclassDiagram class DaoFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createUserDao() } class SqlServerDaoFactory{ +createUserDao() } class AccessDaoFactory{ +createUserDao() } class UserDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertUser(User user) +getUser(Integer id) } class SqlServerUserDao { +insertUser(User user) +getUser(Integer id) } class AccessUserDao { +insertUser(User user) +getUser(Integer id) } DaoFactory \u0026lt;|.. SqlServerDaoFactory DaoFactory \u0026lt;|.. AccessDaoFactory UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao UserDao.java: UserDao接口\npublic interface UserDao { /** * 插入用户 * @param user 用户 */ void insert(User user); /** * 获取用户 * @param id 用户id * @return 用户 */ User getUser(int id); } SqlServerUserDao.java: 用于访问SQL Server的User\npublic class SqlServerUserDao implements UserDao { /** * 插入用户 * * @param user 用户 */ @Override public void insert(User user) { System.out.println(\u0026#34;在SQL Server中给User表增加一条记录\u0026#34;); } /** * 获取用户 * * @param id 用户id * @return 用户 */ @Override public User getUser(int id) { System.out.println(\u0026#34;在SQL Server中根据id得到User表一条记录\u0026#34;); return null; } } AccessUserDao.java: 用于访问Access的User\npublic class AccessUserDao implements UserDao { /** * 插入用户 * * @param user 用户 */ @Override public void insert(User user) { System.out.println(\u0026#34;在Access中给User表增加一条记录\u0026#34;); } /** * 获取用户 * * @param id 用户id * @return 用户 */ @Override public User getUser(int id) { System.out.println(\u0026#34;在Access中根据id得到User表一条记录\u0026#34;); return null; } } DaoFactory.java: 定义一个创建访问User表对象的抽象的工厂接口\npublic interface DaoFactory { /** * 创建UserDao对象 * @return UserDao对象 */ UserDao createUserDao(); } SqlServerDaoFactory.java: 实现SqlFactory接口，实例化SqlServerFactory类\npublic class SqlServerDaoFactory implements DaoFactory { /** * 创建UserDao对象 * * @return UserDao对象 */ @Override public UserDao createUserDao() { return new SqlServerUserDao(); } } AccessDaoFactory.java: 实现SqlFactory接口，实例化AccessFactory类\npublic class AccessDaoFactory implements DaoFactory{ /** * 创建UserDao对象 * * @return UserDao对象 */ @Override public UserDao createUserDao() { return new AccessUserDao(); } } Client.java: 客户端测试类\npublic class Client { public static void main(String[] args) { User user = new User(); // DaoFactory factory = new SqlServerDaoFactory(); DaoFactory factory = new AccessDaoFactory(); UserDao userDao = factory.createUserDao(); userDao.insert(user); userDao.getUser(1); } } 这样，如果要换数据库，只需要修改DaoFactory factory = new AccessDaoFactory();即可，而对于UserDao接口的对象userDao事先根本不需要知道是访问哪个数据库。这就是所谓的业务逻辑与数据访问逻辑的解耦。\n接下来除了User表，还有Department表，架构就会变成这样：\nclassDiagram direction LR class DaoFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createUserDao() } class SqlServerDaoFactory{ +createUserDao() } class AccessDaoFactory{ +createUserDao() } class UserDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertUser(User user) +getUser(Integer id) } class SqlServerUserDao { +insertUser(User user) +getUser(Integer id) } class AccessUserDao { +insertUser(User user) +getUser(Integer id) } class DepartmentDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertDepartment(Department department) +getDepartment(Integer id) } class SqlServerDepartmentDao { +insertDepartment(Department department) +getDepartment(Integer id) } class AccessDepartmentDao { +insertDepartment(Department department) +getDepartment(Integer id) } DaoFactory \u0026lt;|.. SqlServerDaoFactory DaoFactory \u0026lt;|.. AccessDaoFactory UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao DepartmentDao \u0026lt;|.. SqlServerDepartmentDao DepartmentDao \u0026lt;|.. AccessDepartmentDao 增加DepartmentDao.java，用于客户端访问，解除与具体数据库访问的耦合\npublic interface DepartmentDao { /** * 插入部门 * @param department 部门 */ void insert(Department department); /** * 根据id查询部门 * @param id id * @return 部门 */ Department getDepartment(Integer id); } SqlServerDepartmentDao.java: 用于访问SQL Server的Department\npublic class SqlServerDepartmentDao implements DepartmentDao { /** * 插入部门 * * @param department 部门 */ @Override public void insert(Department department) { System.out.println(\u0026#34;在SQL Server中给Department表增加一条记录\u0026#34;); } /** * 根据id查询部门 * * @param id id * @return 部门 */ @Override public Department getDepartment(Integer id) { System.out.println(\u0026#34;在SQL Server中根据id得到Department表一条记录\u0026#34;); return null; } } AccessDepartmentDao.java: 用于访问Access的Department\npublic class AccessDepartmentDao implements DepartmentDao { /** * 插入部门 * * @param department 部门 */ @Override public void insert(Department department) { System.out.println(\u0026#34;在Access中给Department表增加一条记录\u0026#34;); } /** * 根据id查询部门 * * @param id id * @return 部门 */ @Override public Department getDepartment(Integer id) { System.out.println(\u0026#34;在Access中根据id得到Department表一条记录\u0026#34;); return null; } } 在DaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * @return DepartmentDao对象 */ DepartmentDao createDepartmentDao(); SqlServerDaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * * @return DepartmentDao对象 */ @Override public DepartmentDao createDepartmentDao() { return new SqlServerDepartmentDao(); } AccessDaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * * @return DepartmentDao对象 */ @Override public DepartmentDao createDepartmentDao() { return new AccessDepartmentDao(); } 最后Client.java\npublic class Client { public static void main(String[] args) { User user = new User(); DaoFactory factory = new SqlServerDaoFactory(); // DaoFactory factory = new AccessDaoFactory(); UserDao userDao = factory.createUserDao(); userDao.insert(user); userDao.getUser(1); DepartmentDao departmentDao = factory.createDepartmentDao(); departmentDao.insert(new Department()); departmentDao.getDepartment(1); } } 输出的结果为：\n在SQL Server中给User表增加一条记录 在SQL Server中根据id得到User表一条记录 在SQL Server中给Department表增加一条记录 在SQL Server中根据id得到Department表一条记录 这样整个架构已经演进为了抽象工厂模式。当只有一个类需要被工厂方法创建的时候，是工厂方法模式，而涉及多个产品系列的问题，这种工厂模式叫做抽象工厂模式（Abstract Factory Pattern）。\n用简单工厂模式改进抽象工厂 由于抽象工厂的缺点中提到，每次使用都需要声明Factory，但是如果要更改产品系列，那么就需要更改所有的Factory声明。这里可以用简单工厂模式改进。\n直接去除DaoFactory、SqlServerDaoFactory、AccessDaoFactory，改用DataAccess类。\nclassDiagram class UserDao{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class DepartmentDao{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class SqlServerUserDao class SqlServerDepartmentDao class AccessUserDao class AccessDepartmentDao class DataAccess{ -db : string +createUser() UserDao +createDepartment() DepartmentDao } UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao DepartmentDao \u0026lt;|.. SqlServerDepartmentDao DepartmentDao \u0026lt;|.. AccessDepartmentDao DataAccess ..\u0026gt; UserDao DataAccess ..\u0026gt; DepartmentDao DataAccess.java\npublic class DataAccess { private static final String DB = \u0026#34;SQLServer\u0026#34;; // private static final String DB = \u0026#34;Access\u0026#34;; /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; switch (DB){ case \u0026#34;SQLServer\u0026#34;: userDao = new SqlServerUserDao(); break; case \u0026#34;Access\u0026#34;: userDao = new AccessUserDao(); break; default: break; } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; switch (DB){ case \u0026#34;SQLServer\u0026#34;: departmentDao = new SqlServerDepartmentDao(); break; case \u0026#34;Access\u0026#34;: departmentDao = new AccessDepartmentDao(); break; default: break; } return departmentDao; } } Client.java 客户端代码\npublic class Client { public static void main(String[] args) { User user = new User(); Department department = new Department(); UserDao userDao = DataAccess.createUserDao(); userDao.insert(user); userDao.getUser(1); DepartmentDao departmentDao = DataAccess.createDepartmentDao(); departmentDao.insert(department); departmentDao.getDepartment(1); } } 这样的设计客户端代码可以不出现具体数据库名称，使得需要修改数据库时，只需要在DataAccess修改DB的内容就可以了。但是如果需要增加新的数据库支持，就还需要调整Access的switch结构，原来只需要增加一个工厂类就好了。\n用反射+抽象工厂的数据访问程序 为了解决既不修改switch代码结构，也不让客户端出现具体数据库名称。可以引入反射的思想，通过字符串实例化对应的类。 修改后如下所示\npublic class DataAccess { private static final String DB = \u0026#34;SqlServer\u0026#34;; private static final String packageName = \u0026#34;space.rexhub.designpatterns.creational.abstract_factory.dao.impl\u0026#34;; /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; String className = packageName + \u0026#34;.\u0026#34; + DB + \u0026#34;UserDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getDeclaredConstructor(); userDao = (UserDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; String className = \u0026#34;space.rexhub.designpatterns.creational.abstract_factory.dao.impl.\u0026#34; + DB + \u0026#34;DepartmentDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getConstructor(); departmentDao = (DepartmentDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return departmentDao; } } 这样，只需要修改DB的值，就可以实现不同数据库的切换，并且不需要修改switch结构。如果我们需要提供Oracle的支持，只需要创建OracleUserDao和OracleDepartmentDao类，然后修改DB的值即可。\n但还是可以挑出毛病，切换数据库还是需要在代码里进行修改，能否不修改代码就能切换数据库呢？\n用反射+配置文件实现数据访问程序 为了不修改数据库就能切换数据库，可以将数据库名称放在配置文件中，然后通过反射实例化对应的类。\n创建一个 database_config.properties文件，内容如下：\nDB = SqlServer DataAccess.java只需要从配置文件中获取DB就可以了\npublic class DataAccess { private static final String PACKAGE_NAME = \u0026#34;space.rexhub.design_patterns.creational.abstract_factory.dao.impl\u0026#34;; private static String DB; static{ Properties properties = new Properties(); try { properties.load(new FileInputStream(\u0026#34;space/rexhub/design_patterns/creational/abstract_factory/database_config.properties\u0026#34;)); DB = (String) properties.get(\u0026#34;DB\u0026#34;); } catch (IOException e) { DB = null; } } /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; String className = PACKAGE_NAME + \u0026#34;.\u0026#34; + DB + \u0026#34;UserDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getDeclaredConstructor(); userDao = (UserDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; String className = PACKAGE_NAME + \u0026#34;.\u0026#34; + DB + \u0026#34;DepartmentDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getConstructor(); departmentDao = (DepartmentDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return departmentDao; } } 这样这个数据库切换的问题就可以相对较完美的解决了，我们应用了反射+抽象工厂模式解决了数据库访问时的可维护、可扩展问题。\n","permalink":"http://rextechie.github.io/posts/design_patterns/abstract_factory_pattern/","summary":"🚏 导论 抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。\n🧀 前置知识 工厂方法模式（Factory Method） 🚦 结构 classDiagram class AbstractFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createProductA() +createProductB() } class ConcreteFactory1{ +createProductA() +createProductB() } class ConcreteFactory2{ +createProductA() +createProductB() } class AbstractProductA{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductA1 class ProductA2 class AbstractProductB{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductB1 class ProductB2 class Client AbstractFactory \u0026lt;|.. ConcreteFactory1 AbstractFactory \u0026lt;|.. ConcreteFactory2 AbstractProductA \u0026lt;|.. ProductA1 AbstractProductA \u0026lt;|.. ProductA2 AbstractProductB \u0026lt;|.. ProductB1 AbstractProductB \u0026lt;|.. ProductB2 Client --\u0026gt; AbstractFactory Client --\u0026gt; AbstractProductA Client --\u0026gt; AbstractProductB AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。","title":"抽象工厂模式（Abstract Factory）"},{"content":"基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ICLR 2023 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。\n研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。\n在MetaGPT中，对于每个角色制定了Agent的名字（name）、资料（profile）、目标（goal）和约束（constraints）。同时也初始化每个角色的特定的上下文（context）和技能（skill）。例如，产品经理可以使用网络搜索技能，而工程师可以执行代码。如下图2所示。所有Agent遵循ReAct风格。\n图2：一个展示MetaGPT软件开发生成过程的图表，强调其对SOPs的显著依赖。\n每个Agent监控环境（MetaGPT中的消息池）以发现重要的观察结果（如其他agent的消息），这些消息可以直接触发Agent的行为，也可以协助完成任务。\nAgent之间的工作流程（Workflow across Agents） 通过定义代理的角色和技能，可以建立起基本的工作流。在MetaGPT的工作中，遵循软件开发中的SOP，使得所有工作都能按顺序执行。\n具体来说，如之前图1所示，产品经理在获取用户需求后，进行全面的需求分析，制定PRD（Product requirement document），里面包含用户故事和需求池。之后将PRD传递给架构师，他会将需求转为系统设计，例如文件列表、数据结构以及接口定义等。一旦在系统设计中捕获，信息就会直接发送给项目经理以进行任务分配。工程师则继续执行指定的类和功能（如图2所示）。在之后的阶段，QA工程师制定测试用例确保代码质量。最后MetaGPT生成高质量的软件解决方案。详细的SOP工作流程如下图3所示。\n图3：MetaGPT软件开发生成过程。\n通信协议（Communication Protocol） 结构化通信接口（Structed Communication Interfaces） 如今大部分基于大语言模型的多智能体框架（CAMEL、NLSOM、CoELA、Generative Agents）都是使用无约束的自然语言作为通信接口。但是如果只用自然语言作为通信接口，会出现问题。如在电话游戏中，在几轮传递之后，原始的信息会发生扭曲。当用纯自然语言进行通信时，也会出现这种问题。因此需要每个角色制定一个结构化的通信接口，以确保信息的准确传递。如之前的图3所示，架构师Agent产生两个输出：系统接口设计和顺序流程图。与ChatDev不同，MetaGPT中的Agent通过文档和图输出，而不是对话。这些文档也都是包含必要信息的文档，防止出现不相关或丢失的内容。\n发布订阅机制（Publish-Subscribe Mechanism） 共享信息对于协作非常关键。比如：建筑师和工程师需要参考PRD。然而，如果每次都是以一对一的方式传达这些信息，可能会使通信变得复杂，效率低下。为了解决这个问题，一个可行的方案是将信息存储在一个全局信息池中。如图2左边所示，metagpt引入了共享消息池，允许所有agent直接访问和发布信息。这样就可以使得任何Agent可以直接从共享池中检索所需的信息，而不需要通过其他Agent传递。这样提高了通信效率。\n如果与每个Agent共享所有信息可能会导致信息过载。在执行任务期间，Agent通常喜欢接受与任务相关的信息，要避免因不相关的细节而分散注意力。如图2左边所示，MetaGPT引入了订阅机制，Agent不依赖对话，而是利用角色特定的兴趣来提取相关的信息。实际实现的时候，一个Agent只会在接收到所有其先决依赖项后才会激活操作。如之前图3所示，架构师主要关注产品经理提供的PRD，而QA工程师等角色的文档可能不太关心。\n迭代编程与执行反馈（Iterative programming with execution feedback） 在现实开发中，调试和优化非常重要。然而现有的方法通常缺少自我纠错的机制（self-correction mechanism），从而导致代码生成失败。之前也有一些人引入了不可执行代码审查（non-executable code review）和自我反思（self-reflection）:ChatDev、ReAct。然而它们在确保代码可执行性和运行时正确性上还是面临很大的挑战。\nMetaGPT引入了一种可执行的反馈机制(executable feedback)来迭代改进代码。更具体地说，如之前图2所示，要求工程师根据产品需求和设计编写代码。这使得工程师能够使用自己的历史执行记录和调试记忆来持续的改进代码。为了获得额外的信息，工程师编写并执行相应的单元测试用例，然后接收测试结果。如果测试结果满足条件，则启动其他的开发任务，否则工程师将进行调试。这种迭代过程将会持续进行，直到测试通过或达到最大迭代次数（3次）。\n实验结果 (Results) 实验环境（Experimental Setup） 数据集（Dataset） 作者使用了两个公开的benchmarks（HumanEval、MBPP）以及一个自己设计的软件开发的benchmark\nHumanEval: 出自openai，有164个手写编程任务，包括提示词（prompt）、标准答案（canonical_solution）、单元测试代码（test）、函数名称（entry_point）。 MBPP: 出自google search，有427个Python任务，这些任务涵盖核心概念和标准库代码，并包括要求（text）、代码（code）、单元测试集（test_list）等信息。 SoftwareDev：作者自己设计的Benchmark，包含70个软件开发任务的代表性示例，每个示例都有自己的任务提示。如下表所示。这些任务有游戏、算法、数据可视化等等。Software专注于工程方面。 评估指标（Evaluation Metrics） pass@k: 对于HumanEval和MBPP，作者使用了openai提出的无偏估计的pass@k指标，$\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。 对于SoftwareDev，优先考虑实际使用，并通过人工评估（A、E）或统计分析（B、C、D）来评估性能。 A：可执行性，该指标对代码进行评分，从1（失败/无法运行）～4（完美）。1-非功能性、2-可运行但不完美、3-可运行但不完美、4-完美。 B：成本，包括运行时间、token使用量以及费用。 C：代码统计，包括代码文件数、每个文件代码行数以及总代码数 D：生产率，定义为token使用量/代码行数，即每行代码消耗的令牌。 E：人工修订成本，指手动修正的次数，解决诸如包导入错误、类名不正确或不完整的引用路径等问题。通常，每次修正涉及最多3行代码。 基线（Baselines） 对于HumanEval和MBPP，作者使用了一些基线模型：\nAlphaCode InCoder CodeGeeX CodeGen CodeX CodeT PaLM GPT-4 其中Dong等人已经提供了一些结果（如InCoder、CodeGeeX）。在HumanEval和MBPP中，作者稍微修改了下提示词，以适应MetaGPT的输入格式。\n对于SoftwareDev上的基线\nAutoGPT LangChain with Python Read-Eval-Print Loop(REPL) tool AgentVerse ChatDev 主要结果（Main Result） 上图表明MetaGPT在HumanEval和MBPP基准测试中达到了SOAT。\nMetaGPT在SoftwareDev上的实验结果几乎均好于ChatDev。这些结果均凸显出SOP在多个Agent直接协作中的好处。\n在上图中，通过可视化示例展示了MetaGPT在SoftwareDev上的生成结果。\n能力分析（Capability Analysis） 如上表所示，MetaGPT包含多种能力，可以有效地处理复杂且专业的开发业务，结合SOPs可以显著改进代码生成。\n消融实验（Ablation Study） 角色的有效性 为了了解不同角色对最终结果的影响，作者对角色部分做了消融实验。结果如上表所示，虽然更多的角色会稍微增加费用，但整体性能显著提高，展示了各种角色的有效性。\n可执行的反馈机制的有效性 在一开始的主要结果展示的图中，见可执行反馈添加到MetaGPT，pass@1显著提高。此外，表1中显示出反馈机制提高了可行性并降低了人工修改成本。这些结果说明了反馈机制如何能够生成更高质量的代码。\n参考文献 (References) Austin J, Odena A, Nye M, et al. Program synthesis with large language models[J]. arXiv preprint arXiv:2108.07732, 2021. Yao S, Zhao J, Yu D, et al. React: Synergizing reasoning and acting in language models[J]. arXiv preprint arXiv:2210.03629, 2022. Zhao X, Li M, Weber C, et al. Chat with the environment: Interactive multimodal perception using large language models[C]//2023 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2023: 3590-3596. 备注 (Notes) 这篇论文本身对方法的描述不足够详细，在实现Agent上有很多小技巧，需要读源码才能体会到\n优点与创新点 (Strengths) 将SOPs与Agent结合，更加模仿了真实世界的软件开发过程。 设计了共享消息池和订阅机制，提高了通信效率。 引入了可执行的反馈机制，提高了代码生成的质量。 局限性与不足 (Limitations) 实际使用后，项目的可执行性还是有待提高。 SoftwareDev的实验评价指标略为主观 我的思考 (Personal Thoughts) 本文与我研究的相关性：MetaGPT可以实现一些复杂任务的开发，在全栈项目开发中有共同之处。对于SOPs的思想、共享消息池和订阅机制以及可执行的反馈机制，可以考虑在项目中使用。 是否有可以改进的地方：评价指标还有待改进。 后续可能的研究方向：MetaGPT实现的任务较为广泛，考虑缩小范围，只生成Web开发相关的代码。 ","permalink":"http://rextechie.github.io/posts/paper_note/metagpt/","summary":"基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ICLR 2023 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。\n研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。","title":"MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework"},{"content":"基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。\n研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。\n功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。\nKual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n \u0026gt; k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c \u0026lt;= n），并计算无偏估计量。其中 $\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。\n直接计算这个估计量会导致得到非常大的数字并且数值不稳定。在下图3中包含了数值稳定性的numpy实现，它简化了表达式并逐项评估乘积项。有人也许会尝试用1-(1-p_hat)^k来估pass@k, 其中p_hat是pass@1的经验估计，但是作者已经证明了这个方式是有偏差的。 上图的推导证明如下所示 例子🌰： 给定n为10，k为2\nid n c k pass@k 0 10 10 2 1 1 10 9 2 1 2 10 8 2 0.98 4 10 7 2 0.93 5 10 6 2 0.86 6 10 5 2 0.78 7 10 4 2 0.67 8 10 3 2 0.53 9 10 2 2 0.38 10 10 1 2 0.2 11 10 0 2 0 手写部分计算过程如下所示 HumanEval数据集(HumanEval: Hand-Wirtten Evaluation Set) 数据集名称：HumanEval 数据集规模：164个手写编程问题 数据集结构：函数签名、问题描述、主体和单元测试（每个问题平均有7.7个单元测试i）。 数据集来源：数据集必须是手写的，因为模型本身已经从Github训练了，Github中已经包含了解决方案。 数据集地址：GitHub 执行生成函数的沙箱(Sandbox for Executing Generated Functions) 由于公开的代码具有未知意图，因此在执行生成的代码时，需要一个沙箱环境，以防止恶意代码的执行。开发沙箱环境的目标是防止这些程序修改、在主机或网络上获得持久性、访问敏感资源或从主机或网络中窃取数据。由于OpenAI的训练是在K8s集群和云服务上，因此沙箱也一样。\n作者选择了gVisor容器作为主要主机保护组件（Unsupervised Translation of Programming Languages）。不使用Docker，是因为Docker容器运行时可以与容器共享主机资源，恶意容器可能会危及主机。gVisor通过模拟其资源在主机和容器之间引入一个安全边界来保护主机。网络相邻的主机和服务受基于eBPF防火墙规则的保护，这些规则阻止了入站和出站的链接（实验所需连接以外的连接）\n代码微调 (Code Fine-Tuning) 微调GPT(12B参数) -\u0026gt; Codex\n数据收集 (Data Collection) 来源：Github上54亿个公共仓库 规模：178GB的Python文件，每个Python文件大小不到1MB。过滤了之后剩下159GB的数据。 数据清洗：过滤掉了可能是自动生成、平均行数大于100、最大行数大于1000或者包含一小部分字母数字字符的文件。 方法 (Method) 学习率：与GPT相同 学习率预热（防止模型开始训练时不稳定，让开始训练的几个step学习率小一些）：175步 学习率调整：余弦学习率衰减 优化器：Adam优化器，β1 = 0.9, β2 = 0.95, €= 10−8，权重衰减系数为0.1 词法分析器：代码词法分析器（code lexer），由于Github上的代码和自然语言在数据分布上不一样，因此词法分析器也要不一样。造成模型低效的的最大的原因是对里面whitespace的编码，因此作者添加了一组token来表示不同长度的whitespace。 评估 使用pass@k指标 评估数据：将每个HumanEval问题整理成Prompt，包含元注解（header）、函数声明（signature）、文档注释（docstring）。如下图2所示。 停止采样：停止采样符（[\u0026rsquo;\\nclass\u0026rsquo;, \u0026lsquo;\\ndef\u0026rsquo;, \u0026lsquo;\\n#\u0026rsquo;, \u0026lsquo;\\nif\u0026rsquo;, \u0026lsquo;\\nprint\u0026rsquo;]中的一个，否则模型会生成额外的函数或语句） 采样策略：采用核采样（Top-p），并设置top-p=0.96 实验结果 (Results) 如Kaplan等人Scaling Laws for Neural Language Models指出的，语言模型测试损失在模型大小上遵循幂律。代码微调后的测试损失也遵循类似的形式，$\\left( \\frac{N}{5.92 \\times 10^7} \\right)^{-0.13}$，其中N是模型中非embedding参数的参数数量。\n探究不同的k值与temperature的关系。图中可以得出temperature越高，k值越高，则结果越好，因为样本具有更高的多样性，而度量reward只关注是否生成正确解。\n对于679M参数的模型，pass@1的最佳temperature是0.2， pass@100的最佳temperature是0.8。由实验结果可知，他们的pass@k随参数量的变化非常的平滑。\nPass@k是评估k个样本中有多少个通过了单元测试，为了更加接近真实值，引入了n和c，只要n足够大，得到的pass@k就会更接近于真实值。但在实际推理过程的选择中，我们也必须从生成的样本中选择一个样本。根据上图可知选择具有最高平均token对数概率比随机选择要好，但是随机选择比依据对数概率总和来选要稍差。这个图表说明了选择样本的启发式算法的重要性。对于Docstring backtranslation后文会提到，TODO。\n上图是计算Codex-12B（temperatire = 0.8） HumanEval样本与其参考解决方案的BLEU分数。纵坐标是概率密度，横坐标是BLEU分数。显然，BLEU分数的提高可能并不代表在实际中运行正确。\n相关模型和系统的对比分析 (Comparative Analysis of Related Models and Systems) 类似Codex，GPT-Neo、GPT-J基于The Pile进行训练。这个数据集来自各种来源以及8%的Github代码。作者使用HumanEval数据集对GPT-Neo和GPT-J进行了评估。\n对于GPT-Neo，pass@1达到了6.4%，pass@100达到了21.3%，而同等规模的GPT模型在这两个指标上都接近于0%。GPT-Neo-2.7B相当于Codex-85M（参数量少了30倍）。temperature为0.2、0.4和0.8时结果最好。 对于GPT-J-6B，pass@1达到了11.7%，pass@100达到了27.7%。相当于Codex-300M（参数量少了20倍）。temperature为0.2和0.8时结果最好。\n与当时最好的代码补全模型Tabine做了比较，Tabine在pass@1(T = 0.4)为2.6%，pass@100(T = 0.8)为7.6%。相当于Codex-12M。\nAPPS数据集上的结果（Results on the APPS Dataset） APPS(Hendrycks2021年提出, Pre-training of deep bidirectional transformers for language understanding)是一个用于评估代码生成模型的数据集。这个数据集包含5000个训练样本和5000个测试样本，都是关于代码问题，每个都包含单元测试。对于训练数据，包含正确的解决方案。\n与HumanEval不同，APPS数据测试类似OJ判题，从sdin和sdout读取输入输出。\nAPPS论文中测试了找到问题正确解决方案的比例（strict accuracy）和单元测试的通过率（即使答案不对，但只要通过测试）。后一个的度量是为了减少方差（因为第一个准确率很低），因此在测试时要尽量避免strict accuracy。\n在程序竞赛和APPS数据上，会给出三个输入输出用例。作者从模型中采样1000个解决方案，将通过这3个单元测试的解决方案筛选出来。最后计算这个筛选后的样本的pass@k。 考虑算法效率，在算法竞赛中超时是不能被接受的.但是对于Codex，作者评估中使用了3秒的超时时间。 由于Codex没有在APPS上进行指令微调，因此在提示词中添加了input/output示例。在表中表示为\u0026quot;1-shot\u0026quot;。实验结果表明用3个input/output测试过滤出来的样本，再去评估pass@k，效果更好。\n有监督微调 (Supervised Fine-Tuning) 有些从Github上找到的代码是包含类的实现、配置文件、脚本、甚至用来存储数据，这些与生成代码无关。作者假定这些错误匹配的代码会影响HumanEval的性能。作者分别收集了两类数据，一类是来自编程竞赛网站（和我一开始对于做代码生成的想法一摸一样，不过看来三年前就已经有人在做了🤔。。。），一类是持续集成仓库。用这些数据来训练出来的模型，作者称之为Codex-S。\n编程竞赛中的问题（Problems from Competitive Programming） OJ判题大多通过隐藏的单元测试来自动判断提交的功能正确性，这些单元测试通常有优秀的测试覆盖率，是经过了精心设计的。作者从多个流行的编程竞赛和面试网站手机了相关的问题描述、函数声明以及解决方案，把他们整理成类似HumanEval的格式，使用问题描述作为docstring。由于网站的单元测试是不公开的，作者依据问题的描述创建单元测试，或者通过提交错误解决方案提取了额外的测试用例。总共，作者收集了10000个问题。（🤡这方面的工作已经比较成熟了，感觉不好从这方面继续做研究了。）\n持续集成中的问题（Problems from Continuous Integration） 对于使用了持续集成（CI）相关的项目，使用python中sys.setprofile可以记录函数调用的输入和输出，这些数据天然的可以作为单元测试。作者考虑使用GitHub仓库，其中使用Travis和Tox作为它们的持续集成（CI）框架，因为它们是最受欢迎的CI工具之一。作者最终从数百万个问题中收集了40000个问题，因为不是所有的问题都接受输入并返回输出的。\n过滤问题（Filtering Problems） 为了控制模型的训练数据质量，作者使用Codex-12B对每一个任务生成100个样本，如果没有一个样本通过测试，则说明这个问题的描述是不清晰的，作者会将这个问题过滤掉。\n方法 (Method) 用这些最后的训练数据对Codex进行有监督微调得到Codex-S。作者训练主要是最小化参考解决方案的负对数似然。他们使用了训练Codex学习率的1/10的学习率来微调Codex-S，但学习率计划是一样的，训练直到验证集损失达到平稳。\n实验结果 (Results) 和Codex一样，他们首先计算pass@k的最佳temperature（1 \u0026lt;= k \u0026lt;= 100）。作者发现对于k \u0026gt; 1，Codex-S更喜欢略高的temperature，这可能反映了Codex-S的分布比Codex更狭窄。作者对于pass@1使用temperature=0, pass@100使用temperature=1。\n随后作者比较了Codex-S和Codex在pass@1和pass@100。实验结果表明，Codex-S在pass@1 平均比Codex高出6.5%，在pass@100上平均高出15.1%。\n作者同时还绘制了Codex-S-12B的不同样本选择启发式算法在Codex-S-12B上的性能与Codex-12B上的相同启发式算法进行比较。当按平均对数概率从1到100个样本进行排名时，平均比随机高11.6，这比Codex高出2%。\ndocstring生成 (Docstring Generation) 用docstring生成代码是可能的（合理的），因为代码通常紧跟在docstring之后，但是通过代码生成docstring是困难的。因此作者又开发了一个编写docstring的模型，可以描述生成代码的意图。使用前一节的训练问题描述，可以简单的创建一个训练数据集用于依据代码生成描述。\n具体来说，对于每一个训练问题，作者集成了训练样本的函数声明、参考解决方案和docstring。和之前一样，他们训练docstring生成模型（Codex-D）最小化负对数似然。\n对于生成代码，可以在HumanEval上测量pass@k作为基准测试，其中正确性由单元测试来定义。然而，没有类似的方法可以自动评估docstring样本.因此，他们通过手动来评估这些样本，如果文档字符串独特且准确的描述了代码，则认为是正确的。由于工作量大，作者只对每个问题生成的10个样本进行了评估，总共1640个问题，用temperature=0.8的Codex-D-12B。当模型简单的将代码体里的代码复制到docstring中时，作者认为这是错误的。最常见的错误是遗漏了重要的细节（如：结果保留两位小数）或者过度的要求函数名但是函数体的内容与函数名无关。\n实验结果表明，Codex-D的通过率较低，但是与相同temperature下的Codex-S相当。由于自然语言语法没有代码语法严格，所以生成的文档可能更宽容。docstring的质量相对较低，因为程序员🧑‍💻不会花很多时间来写docstring。\n最后，使用docstring模型，又有了一种从k个样本中选出一个样本的方法。不同与之前用最佳平均对数概率选择样本，可以最大化back-translation的P（GT docstring | 生成的样本），其中P是由Codex-D得出的。然而，如下图所示，通过back-translation进行排序的表现不如平均对数概率排序，尽管他优于随机排序。\n局限性与不足 (Limitations) Codex在训练上并不高效：作者认为没必要用Github上这么多的代码，实际上一个完成了学习的科班学生，预计能解决更大一部分的问题（比起Codex-12B）。 Codex可能会出现语法错误或未定义的代码，并且调用未定义或不在定义域内的函数、变量和属性。此外Codex在解析越来越长、更高层次或系统级的要求的时候会比较困难。为了具体说明这个问题，作者创建了一个由13个基本构建快组成的合成数据集。比如“将字符串转换为小写”或“移除每个字符串中第三个元素”（附录C里有详细的内容）。作者发现随着构建块链长度的增加，Codex的性能会呈指数下降。 和其他模态中的文本条件生成模型很难将属性绑定到对象上一样，Codex在将操作绑定到对象上也会出错，尤其是文档涉及的操作和变量很大的时候。如下面代码所示，Codex-12B并没有减少w变量，也没有返回四个变量的乘积。 def do_work(x, y, z, w): \u0026#34;\u0026#34;\u0026#34; Add 3 to y, then subtract 4 from both x and w. Return the product of the four numbers. \u0026#34;\u0026#34;\u0026#34; t=y+3 u=x-4 v=z*w return v 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n提出了一个评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 作者提出了Codex，通过对GPT-3进行微调，使其在HumanEval数据集上的性能得到了进一步提升。 作者提出了Codex-S，通过有监督微调Codex，使其在HumanEval数据集上的性能得到了进一步提升。 作者提出了Codex-D，通过训练docstring生成模型，使其在HumanEval数据集上的性能得到了进一步提升。 参考文献 (References) Kulal, Sumith, et al. \u0026ldquo;Spoc: Search-based pseudocode to code.\u0026rdquo; Advances in Neural Information Processing Systems 32 (2019). Hendrycks, Dan, et al. \u0026ldquo;Measuring coding challenge competence with apps.\u0026rdquo; arXiv preprint arXiv:2105.09938 (2021). 备注 (Notes) 论文提到一个现象（Introduction），12B的Codex可以解决28.8%的问题，而300M的Codex只能解决13.2的问题。这是为什么？ 论文提到了启发式（Heuristic），指的是什么 优化后的pass@k有什么含义。 这篇文章的Related work写了这个领域的发展，最早2011年就有人开始研究代码生成。这部分内容值得深入探索。 我的思考 (Personal Thoughts) 本文与我研究的相关性：提出了一个评估大型语言模型生成代码能力的方法，对于代码生成的研究有一定的参考价值。 是否有可以改进的地方：数据集的数量已经足够，但是数据集的质量可能还有待提高。作者提到了Codex在解析越来越长、更高层次或系统级的要求的时候会比较困难，这个问题也值得进一步研究。 后续可能的研究方向：研究更多相关评估大语言模型生成代码能力的数据集，如MBPP、APPS等数据集。 ","permalink":"http://rextechie.github.io/posts/paper_note/human_eval/","summary":"基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。\n研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。\n功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。\nKual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n \u0026gt; k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c \u0026lt;= n），并计算无偏估计量。其中 $\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。","title":"Evaluating Large Language Models Trained on Code"},{"content":"关于我 🎓 🎯 软件工程研究生在读 🔬 研究方向：基于大语言模型的代码生成 💻 后端开发工程师 🌱 持续学习，保持热情 研究领域 🚀 大语言模型在软件工程中的应用 智能代码生成与程序合成 代码理解与转换 技术栈 💪 语言：Java, Python, JavaScript\u0026hellip; 框架：Spring Boot, Spring Cloud, MyBatis\u0026hellip; 数据库：MySQL, Redis, MongoDB, Elasticsearch\u0026hellip; AI/ML：Neural Network, Transformers\u0026hellip; 项目经历 📚 🤖 基于LLM的代码生成系统 🌟 分布式微服务架构设计与实现 📊 企业级数据分析平台 生活爱好 ⭐ 🏸 羽毛球爱好者 🏃 跑步健身 📚 阅读：技术书籍 GitHub 统计 📊 联系我 📫 Email: rexhub@163.com Blog: 个人博客 ","permalink":"http://rextechie.github.io/about/","summary":"关于我 🎓 🎯 软件工程研究生在读 🔬 研究方向：基于大语言模型的代码生成 💻 后端开发工程师 🌱 持续学习，保持热情 研究领域 🚀 大语言模型在软件工程中的应用 智能代码生成与程序合成 代码理解与转换 技术栈 💪 语言：Java, Python, JavaScript\u0026hellip; 框架：Spring Boot, Spring Cloud, MyBatis\u0026hellip; 数据库：MySQL, Redis, MongoDB, Elasticsearch\u0026hellip; AI/ML：Neural Network, Transformers\u0026hellip; 项目经历 📚 🤖 基于LLM的代码生成系统 🌟 分布式微服务架构设计与实现 📊 企业级数据分析平台 生活爱好 ⭐ 🏸 羽毛球爱好者 🏃 跑步健身 📚 阅读：技术书籍 GitHub 统计 📊 联系我 📫 Email: rexhub@163.com Blog: 个人博客 ","title":"About"}]