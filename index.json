[{"content":"🚏导论 代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。\n🔍索引 代码生成相关模型 MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning DocAgent: A Multi-Agent System for Automated Code Documentation Generation 代码生成评估指标 Evaluating Large Language Models Trained on Code ","permalink":"http://rextechie.github.io/posts/paper_note/code_generate/","summary":"🚏导论 代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。\n🔍索引 代码生成相关模型 MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning DocAgent: A Multi-Agent System for Automated Code Documentation Generation 代码生成评估指标 Evaluating Large Language Models Trained on Code ","title":"代码生成相关论文索引"},{"content":"🚏 导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。\n在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。\n💻 代码 Java代码实现\n🔍 索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 依赖倒置原则(Dependency Inversion Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)\n抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)\n适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)\n观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern) ","permalink":"http://rextechie.github.io/posts/design_patterns/design_patterns/","summary":"🚏 导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。\n在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。\n💻 代码 Java代码实现\n🔍 索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 依赖倒置原则(Dependency Inversion Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)\n抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)\n适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)\n观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern) ","title":"设计模式"},{"content":"Spring Cloud原生中间件 Consul（服务注册与发现 + 分布式配置管理） 拥有服务治理功能，实现微服务之间的动态注册与发现\n❌不在使用Eureka：1. 停更进维 2. 注册中心独立且和微服务功能解耦\nConsul官网\nSpring官方介绍\n三个注册中心区别 组件名 语言 CAP 服务健康检查 对外暴露接口 Spring Cloud集成 Eureka Java AP 可配支持 HTTP 已集成 Consul Go CP 支持 HTTP/DNS 已集成 Zookeeper Java CP 支持 客户端 已集成 Nacos Java AP 支持 客户端 已集成 CAP 一个分布式系统最多只能同时满足其中的两个属性。\nConsistency: 强一致性，每次读取都能获取到最近一次成功写入的数据。 Availablity: 可用性，每次请求都会在有限时间内返回结果，无论结果是否为最新。 Partition tolerance: 分区容错性，系统在遇到网络分区（节点之间无法通信）时仍能继续运作。（必须有） 经典CAP：\nAP（Eurake）：当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\nCP：当网络分区出现后，为了保证一致性，系统返回错误信息。\n当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性，Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。结论：违背了可用性A的要求，只满足一致性和分区容错，即CP\n使用 ./consul --version # 查看版本号 ./consul agent -dev # 开发模式启动 http://localhost:8500 LoadBalance（服务调用复杂均衡） 负载均衡：平摊请求，减少服务器压力\nSpring-cloud-starter-loadbalancer：spring官方提供的客户端负载均衡器，在SpringCloud-commons中，用来替代以前的Ribbon，支持RestTemplate、Web Flux。\n客户端与服务器端负载均衡区别：服务器端如Nginx，将客户端发起的请求到通过服务器端部署的Nginx，转发到各个服务器上。LoadBlance本地负载均衡，调用微服务接口时，在注册中心上获取信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用。\nSpring官方介绍\n负载均衡算法 实现ReactiveLoadBalancer接口，默认使用的是RoundRobinLoadBalancer。\n官方对负载均衡算法的介绍\nRoundRobinLoadBalancer: 轮询 RandomLoadBalancer: 随机 OpenFeign（服务调用复杂均衡） Feign是一个声明式web服务客户端，用来替代RestTemplate，只需创建一个Rest接口并在该接口上添加注解@FeignClient。\nOpenFeign基本上就是当前微服务之间调用的事实标准。\n可以结合LoadBalancer实现负载均衡，结合Sentinel实现熔断降级。\nSpring官方介绍 Github\n超时控制 超时控制说明\nconnectTimeout: 连接超时时间 readTimeout: 请求处理超时时间，默认超时时间是60s 重试机制 重试机制说明\n默认情况下会创建Retry.NEVER_RETRY类型的Retry的bean，这将禁用重试，这种重试行为与Feign默认行为不同，他会自动重试IOExceptions，将它们视为网络相关的瞬态异常，以及从ErrorDecoder抛出的任何RetryableException。\n默认HTTPClient修改 默认HTTPClient修改说明\n如果不做特殊配置，OpenFeign默认使用JDK自带的HttpURLConnection发送HTTP请求，\n由于默认HttpURLConnection没有连接池、性能和效率比较低 ，如果采用默认，无法发挥最大性能，故使用Apach的HTTPClient 5替换默认HTTPURLConnection。\n⚠️注意：httpclient的版本对齐\n请求/响应压缩 请求/响应压缩说明\nSpring Cloud OpenFeign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。\n日志打印功能 日志打印功能说明\nFeign 提供了日志打印功能，我们可以通过配置来调整日志级别，\n日志级别：\nNONE：默认的，不显示任何日志； BASIC：仅记录请求方法、URL、响应状态码及执行时间； HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息； FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据 CircuitBreaker（断路器） ⚠️较为繁琐，资料少，不适合自学，面试必考\n解决服务雪崩问题，对于有问题的节点，快速熔断（快速返回失败处理或者返回默认兜底数据【服务降级】）\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n当一个组件或服务出现故障时，CircuitBreaker会迅速切换到开放OPEN状态(保险丝跳闸断电)，阻止请求发送到该组件或服务从而避免更多的请求发送到该组件或服务。这可以减少对该组件或服务的负载，防止该组件或服务进一步崩溃，并使整个系统能够继续正常运行。同时，CircuitBreaker还可以提高系统的可用性和健壮性，因为它可以在分布式系统的各个组件之间自动切换，从而避免单点故障的问题。\nSpring官方介绍\nSpring Cloud提供的两个实现类：Resilience4j、Spring Retry\nResilience4j Resilience4j官网\nResilience4j 是一个轻量级的容错库，专为函数式编程设计。Resilience4j 提供了高阶函数（装饰器），可以增强任何函数式接口、lambda 表达式或方法引用，添加断路器、速率限制器、重试或舱壁。您可以在任何函数式接口、lambda 表达式或方法引用上堆叠多个装饰器。优点是可以自由选择所需的装饰器，而不需要其他任何东西。\n断路（Circuit Breaker） 断路器状态 OPEN CLOSED HALF_OPEN DISABLED(特殊状态) FORCED_OPEN(特殊状态) 3大状态之间的转换 当熔断器关闭时，所有请求都会通过熔断器 失败率超过设定的阈值，熔断器就会从CLOSED转到OPEN，这时所有的请求都会被拒绝 当经过一段时间后，熔断器会从OPEN变为HALF_OPEN，这时有一定数量的请求会被放入，并重新计算失败率 如果失败率超过阈值，则变为OPEN状态，如果失败率低于阈值，则变为CLOSED状态 断路器使用滑动窗口来存储和统计调用的结果 基于访问数量的滑动窗口：统计了最近N次调用的返回结果 基于时间的滑动窗口：统计了最近N秒的调用返回结果 特殊状态 这两个状态不会生成熔断时间，并且不回记录事件的成功或失败 退出这两个状态的唯一方法是触发状态转换或者熔断器 配置 failure-rate-threshold 以百分比配置失败率峰值 sliding-window-type 断路器的滑动窗口期类型 可以基于“次数”（COUNT_BASED）或者“时间”（TIME_BASED）进行熔断，默认是COUNT_BASED。 sliding-window-size 若COUNT_BASED，则N次调用中有failure-rate-threshold%失败（即5次）打开熔断断路器； 若为TIME_BASED则，此时还有额外的两个设置属性，含义为：在N秒内（sliding-window-size）100%（slow-call-rate-threshold）的请求超过N秒（slow-call-duration-threshold）打开断路器。 slowCallRateThreshold 以百分比的方式配置，断路器把调用时间大于slowCallDurationThreshold的调用视为慢调用，当慢调用比例大于等于峰值时，断路器开启，并进入服务降级。 slowCallDurationThreshold 配置调用时间的峰值，高于该峰值的视为慢调用。 permitted-number-of-calls-in-half-open-state 运行断路器在HALF_OPEN状态下时进行N次调用，如果故障或慢速调用仍然高于阈值，断路器再次进入打开状态。 minimum-number-of-calls 在每个滑动窗口期样本数，配置断路器计算错误率或者慢调用率的最小调用数。比如设置为5意味着，在计算故障率之前，必须至少调用5次。如果只记录了4次，即使4次都失败了，断路器也不会进入到打开状态。 wait-duration-in-open-state 从OPEN到HALF_OPEN状态需要等待的时间 例子：\n6次访问中当执行方法的失败率达到50%时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。\n等待5秒后，CircuitBreaker将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。\n如还是异常CircuitBreaker将重新进入开启OPEN状态；如正常将进入关闭CLOSE闭合状态恢复正常处理请求。\nfailure-rate-threshold: 50 # 设置50%的失败率阈值，超过失败请求百分比CircuitBreaker变为open sliding-window-type: COUNT_BASED # 滑动窗口的类型 sliding-window-size: 6 # 滑动窗口的大小，单位为请求数 minimum-number-of-calls: 6 # 断路器计算失败率或慢调用之前所需的最小样本（每个滑动窗口周期） automatic-transition-from-open-to-half-open-enabled: true # 是否启用自动从开启到半开启状态，默认值为false wait-duration-in-open-state: 5s # 从OPEN到HALF_OPEN状态的等待时间 permitted-number-of-calls-in-half-open-state: 2 # 半开状态允许的最大请求数，默认值为10. failure-rate-threshold: 50 # 设置50%的失败率阈值，超过失败请求百分比CircuitBreaker变为open slow-call-duration-threshold: 2s # 慢调用时间阈值，高于此时间的调用将被视为慢调用并增加调用比例。 slow-call-rate-threshold: 30 # 慢调用百分比阈值，超过此百分比的慢调用将触发断路器。 sliding-window-type: TIME_BASED sliding-window-size: 2 # 滑动窗口的大小配置，配置TIME_BASED表示2秒 minimum-number-of-calls: 2 # 断路器计算失败率或慢调用之前所需的最小样本（每个滑动窗口周期） permitted-number-of-calls-in-half-open-state: 2 # 半开状态允许的最大请求数，默认值为10. wait-duration-in-open-state: 5s # 从OPEN到HALF_OPEN状态的等待时间 record-exceptions: - java.lang.Exception 舱壁隔离（Bulkhead） 依赖隔离\u0026amp;负载保护：用来限制对于下游服务的最大并发的限制\n舱壁隔离说明\n两种隔离方式 信号量舱壁（SemaphoreBulkhead）： 当信号量有空闲时，进入系统的请求会直接获取信号量并开始业务处理。 当信号量全备占用时，接下来的请求将会进入阻塞状态，SemaphoreBulkhead提供了一个阻塞计时器 如果阻塞状态的请求在阻塞计时内无法获取到信号量则系统会拒绝这些请求。 若请求在阻塞计时内获取到了信号量，那将直接获取信号量并执行相应的业务处理 FixedThreadPoolBulkhead使用了有界队列和固定大小线程池 当线程池中存在空闲时，则此时进入系统的请求将直接进入线程池开启新线程或使用空闲线程来处理请求 当线程中无空闲时，接下来的请求进入等待队列 若等待队列仍然无剩余空间时接下来的请求将直接被拒绝 在队列中的请求等待线程池出现空闲时，将进入线程池进行业务处理 另，ThreadPoolBulkhead只对CompletableFuture方法有效，所以必须创建返回CompletableFuture类型的方法 速率限制（Rate Limiter） 速率限制说明\n限流算法 漏斗算法（Leaky Bucket） 一个固定容量的漏桶，按照设定常量固定速率流出水滴，类似医院打吊针，不管你源头流量多大，我设定匀速流出。 如果流入水滴超出了桶的容量，则流入的水滴将会溢出了(被丢弃)，而漏桶容量是不变的。 缺点：对于存在突发特性的流量来说缺乏效率。 令牌桶算法（Token Bucket） Spring Cloud 默认使用的算法 当用户发起请求，先判断桶空不空 令牌桶算法会匀速的添加令牌至令牌桶中，桶可容纳令牌的数量是有限的。 用户每次发起请求，先检查桶是否为空。若桶空，则丢弃请求；若桶不空，则申请获得令牌，获得令牌则可排队让处理器处理当前请求 滚动时间窗口算法（Tumbling time window） 允许固定数量的请求进入(比如1秒取4个数据相加，超过25值就over)超过数量就拒绝或者排队，等下一个时间段进入。 由于是在一个时间间隔内进行限制，如果用户在上个时间间隔结束前请求（但没有超过限制），同时在当前时间间隔刚开始请求（同样没超过限制），在各自的时间间隔内，这些请求都是正常的。 缺点：间隔临界的一段时间内的请求就会超过系统限制，可能导致系统被压垮。 滑动时间窗口算法（Sliding time window） 滑动窗口算法是把固定时间片进行划分并且随着时间移动，移动方式为开始时间点变为时间列表中的第2个时间点，结束时间点增加一个时间点。 不断重复，通过这种方式可以巧妙的避开计数器的临界点的问题。 Sleuth(Micrometer) + Zipkin（分布式链路追踪） 分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。\n⚠️ Sleuth停更进维， Sleuth替代方案Micrometer\nMicrometer官方文档\n分布式链路追踪原理 两个关键id：Track Id（链路id）、Span Id（节点id）、Parent Id（父级节点id，Span Id）\n主要通过Span Id记录整条链路\nDashboard ZipKin：由Twitter公司开源，开放源代码分布式的跟踪系統，用于收集服务的定时数据，以解决微服务架构中的延迟问 题，包括：数据的收集、存储、查找和展现。结合spring-cloud-sleuth使用较为简单，集成方便，但是功能较 简单。 Cat：由大众点评开源，基于Java开发的实时应用监控千台，包括实时应用监控，业务监控。集成方案是通过代码埋 点的方式来实现监控，比如：拦截器，过滤器等。对代码的侵入性很大，集成成本较高。风险较大。 Pinpoint：Pinpoint是一款开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能 强大，接入端无代码侵入。 Skywalking： SkyWalking是国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多 种插件，UI功能较强，接入端无代码侵入。 整合Micrometer Tracing 由于Micrometer Tracing是一个门面工具自身并没有实现完整的链路追踪系统，具体的链路追踪另外需要引入的是第三方链路追踪系统的依赖：\nmicrometer-tracing-bom 导入链路追踪版本中心，体系化说明 micrometer-tracing 指标追踪 micrometer-tracing-bridge-brave 一个Micrometer模块，用于与分布式跟踪工具 Brave 集成，以收集应用程序的分布式跟踪数据。Brave是一个开源的分布式跟踪工具，它可以帮助用户在分布式系统中跟踪请求的流转，它使用一种称为\u0026quot;跟踪上下文\u0026quot;的机制，将请求的跟踪信息存储在请求的头部，然后将请求传递给下一个服务。在整个请求链中，Brave会将每个服务处理请求的时间和其他信息存储到跟踪数据中，以便用户可以了解整个请求的路径和性能。 micrometer-observation 一个基于度量库 Micrometer的观测模块，用于收集应用程序的度量数据。 feign-micrometer 一个Feign HTTP客户端的Micrometer模块，用于收集客户端请求的度量数据。 zipkin-reporter-brave 一个用于将 Brave 跟踪数据报告到Zipkin 跟踪系统的库。 补充包：spring-boot-starter-actuator SpringBoot框架的一个模块用于监视和管理应用程序 Gateway（服务网关 ） 以前都是用Zuul，但是Zuul更新太水了，Spring Cloud 自己研发了Gateway替代Zuul\nSpring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发(路由)到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。Spring Cloud Gateway本身也是一个微服务，需要注册进服务注册中心。\nSpring官方介绍\n三大核心 路由（Route）：网关的基本构建块。它由一个ID、一个目标URI、一组断言和一组过滤器定义。如果断言为True，则匹配路由。 断言（Predicate）：参考的是Java8中的java.util.function.Predicate, 允许匹配HTTP请求中的任何内容，例如头或参数。如果请求与断言相匹配则进行路由。 过滤器（Filter）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 Gateway工作流程 工作流程说明\n客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(Pre)或之后(Post)执行业务逻辑。\n在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等;\n在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n核心：路由转发 + 断言判断 + 执行过滤器链\nRoute以微服务名 - 动态获取服务URI 在配置route的uri时使用 lb://服务名 即可\nPredicate断言 Predicate断言说明\nSpring Cloud中Gateway有一个RoutePredictFactory，通过RoutePredicate工厂类可以创建Predict对象，Predict对象用于Route的匹配。Spring Cloud Gateway中包含多个内置的Route Predicate Factories：After、Before、Between、Cookie、Header、Host、Method、Path、Query、ReadBody、RemoteAddr、XForwardedRemoteAddr、Weight、CloudFoundryRouteService，当然也可以自定义。\nFilter过滤 Filter过滤说明\n功能上类似SpringMVC里的拦截器Interceptor，Servlet里的过滤器\n\u0026ldquo;pre\u0026quot;和\u0026quot;post\u0026quot;分别会在请求被执行前调用和被执行后调用，用来修改请求和响应信息\n作用：请求鉴权、异常处理、记录接口调用时长统计\n过滤器分类\n单一内置过滤器 自定义过滤器 ","permalink":"http://rextechie.github.io/posts/java/springcloud/","summary":"Spring Cloud原生中间件 Consul（服务注册与发现 + 分布式配置管理） 拥有服务治理功能，实现微服务之间的动态注册与发现\n❌不在使用Eureka：1. 停更进维 2. 注册中心独立且和微服务功能解耦\nConsul官网\nSpring官方介绍\n三个注册中心区别 组件名 语言 CAP 服务健康检查 对外暴露接口 Spring Cloud集成 Eureka Java AP 可配支持 HTTP 已集成 Consul Go CP 支持 HTTP/DNS 已集成 Zookeeper Java CP 支持 客户端 已集成 Nacos Java AP 支持 客户端 已集成 CAP 一个分布式系统最多只能同时满足其中的两个属性。\nConsistency: 强一致性，每次读取都能获取到最近一次成功写入的数据。 Availablity: 可用性，每次请求都会在有限时间内返回结果，无论结果是否为最新。 Partition tolerance: 分区容错性，系统在遇到网络分区（节点之间无法通信）时仍能继续运作。（必须有） 经典CAP：\nAP（Eurake）：当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\nCP：当网络分区出现后，为了保证一致性，系统返回错误信息。\n当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性，Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。结论：违背了可用性A的要求，只满足一致性和分区容错，即CP\n使用 ./consul --version # 查看版本号 .","title":"SpringCloud原生中间件"},{"content":"基本信息 标题: DocAgent: A Multi-Agent System for Automated Code Documentation Generation 作者: Dayu Yang（通讯作者）、Antoine Simoulin、Xin Qian等。 作者单位: Meta AI 期刊/会议: ArXiv 发表年份: 2025.04.11 DOI: 2504.08725 开源地址: Github 关键词: Code Documentation, Multi-Agent System, Large Language Models 研究问题 (Research Questions) 如何自动生成代码文档，尤其是处理复杂的依赖关系和上下文信息？\n研究背景 (Background) 像现在的方法FIM（Fill in the Middle）和 chat agent可以实现自动化生成代码文档，但还是有一些局限性：\n省略了必要的信息（例如，参数或返回值描述）。 它们通常提供最少量的上下文或理由，限制了生成文档的有用性。 由于LLM的幻觉，会虚构不存在的组件，尤其是规模比较大的项目中。 核心贡献 (Key Contributions) DocAgent，一个多智能体、拓扑结构化的上下文感知文档生成系统。 一个衡量代码文档完整性、实用性和事实一致性的稳健评估框架。 全面实验表明，DocAgent在多个数据集中持续优于最先进的基线。 方法 (Methodology) DocAgent分两个阶段来处理复杂的依赖关系并确保上下文的相关性。\n用一个Navigator确定一个最佳的依赖感知的处理顺序 Multi-Agent System系统增量地生成文档，利用专门的Agent进行代码分析、信息检索、编写文档和验证 Navigator: 感知依赖顺序 生成代码级别的文档需要理解依赖代码之间的关系，然而如果给出所有内容，很容易超出上下文窗口的限制。Navigator模块就是为了解决这个问题，Navigator建立了一个处理顺序，确保处理依赖关系之后才对组件进行文档化，从而实现增量上下文构建。\n构建依赖图 首先对整个存储库进行静态分析，解析源文件的抽象语法树（AST，Abstract Syntax Tree），以识别代码组件（函数、方法、类）及其相互关系（函数调用、继承、属性方法和模块导入），用一个有向无环图（DAG， Directed Acyclic Graph）来表示，节点是组件，边是依赖关系。为了实现拓扑排序，用Tarjan算法检测图中的循环，并将其浓缩单个超级节点。\nTopological Traversal for Hierarchical Generation 使用有向无环图，Navigator模块使用DAG执行拓扑排序，以确定文档生成顺序。遍历遵循“依赖优先”原则：只有在所有直接依赖的组件都已被文档化后，才会处理组件。这种方式确保多智能体系统为特定组件生成文档时，已经生成该组件的所有依赖性描述。因此，每个代码文档只需要其单跳依赖项的信息，消除了需要拉入不断增长的背景信息链的需求。\nMulti-Agent Documentation Generation 多智能体系统由一个编排器协调四个专业智能体（Reader、Searcher、Writer、Verifier），为每个组件生成文档。\nReader 对于ReaderAgent来说，他的任务是确定对生成全面的且对代码文档有帮助的信息。他通过评估组件的复杂性、可见性和实现细节来进行判断，1）是否需要外部信息，简单的、自包含的组件可能不需要外部信息。2）需要什么信息：这涉及到识别特定的内部依赖（用到的函数、类）、使用的上下文（组件调用的地方，以及其目标）或隐式/显式的外部概念（算法、库、领域知识）。\n这个Agent最终输出的是一个格式化的XML，1）关于相关代码组件的内部信息、2）针对特定算法或技术的外部知识。\n对于内部信息，需要包含依赖和引用。依赖意味着目标组件调用里其他组件，Reader Agent会判断这些依赖是否是必须的信息。引用意味着目标组件在代码库的某个地方被调用，揭示了目标组件的目的。\n外部请求针对的信息并非直接来自代码库本身或可从代码库推断，例如特定领域的知识或第三方库功能。\nSearcher Searcher Agent 负责使用工具满足Reader Agent的信息请求。\n内部代码分析工具（Internal Code Analysis Tool）: 该工具利用静态分析能力遍历代码库，可获取指定内部组件的源代码及现有文档，定位目标组件的调用点，通过预计算依赖图或实时分析追踪依赖关系，并提取相关结构信息（如类继承层次、方法签名等）。 外部知识检索工具（External Knowledge Retrieval Tool）: 这个工具通过通用检索API介入外部知识源，能根据Reader对外部概念查询需求自动构建检索语句，并对返回结果进行处理以提取相关解释、定义或描述。 Searcher会将检索到的内部代码信息和外部知识合并为结构化格式，作为后续智能体运作的上下文依据。\n就像两个人类合作完成项目并相互交流一样，在Searcher将检索到的信息发送回读者后，Reader会读取更新后的上下文和目标组件，并判断当前上下文是否足以生成文档。若Reader认为检索到的信息仍不充分，Reader可继续向Searcher发送信息请求。如此，信息请求与新检索到的内容将在Reader与Searcher之间循环传递，直至获取足够的信息为止。\nWriter Writer智能体的输入是目标组件的代码和由Searcher产出的结构化的内容，核心任务是生成代码文档。生成过程主要通过提示词根据组件类型指定所需结构和内容：\n函数/方法（Function / Method）：通常需要摘要、额外描述、参数描述、返回值描述、引发的异常以及可能使用的示例（特别是对于公共组件）。 类：通常需要摘要、额外描述、初始化示例、构造器参数描述、公共参数描述 这个Writer Agent根据代码和提供的上下文生成符合要求的代码文档草稿。\nVerifier Verifier的输入是Writer提供的上下文、代码组件和生成的代码文档，根据预定义的质量标准评估代码文档：信息价值、详细程度和完整性。评估后，Verifier要么批准文档，要么通过结构化反馈提供具体的改进建议。\n如果问题可以不通过额外上下文信息的情况下解决，Verifier可以和Writer进行交互。比如：格式问题，可以通过要求Writer重写来轻松解决。\n如果问题是因为缺乏信息引起的，并且需要额外的内容，verifier也可以向Reader提供建议，并且将通过Reader-Searcher循环收集额外的信息。\nOrchestrator 用Orchestrator管理agent工作流，来实现整体的迭代过程。整个周期：\nReader分析目标代码以及必要的上下文 Searcher收集信息 Writer写文档 Verifier评估文档质量，批准或退回以供修订 这个过程一直持续到生成令人满意的代码文档或达到最大迭代限制。\nAdaptive Context Manage(自适应上下文管理)：为了处理Searcher检索到的很大的文本，尤其是复杂的组件，Orchestrator实现了一个自适应上下文截断机制。他监控提供给Writer的token总数，如果context超过了一个可配置的阈值（基于底层LLM的限制），Orchestrator将使用截断策略。它识别结构化后的上下文中最大部分（如：外部知识片段、特定的依赖细节），并从这些部分的末尾选择性地删除内容，以减少token数同时保持整体结构。\n评估框架（Evaluation Framework） 存在的挑战：\n缺乏gold reference。传统的指标BLEU或ROUGE，不能适用。 根据文档长度这样的方法不足以作为实际效用的指标 人工评估具有主观性、成本高、难以拓展，大规模试验或持续集成场景不切实际 为了解决这些问题，作者提出了一个新的评估框架，包含几个方面：完整性（Completeness）、帮助性（Helpfulness）、真实性（Truthfulness）。\n完整性（Completeness） 完整性评估依据标准结构的约定，并包括预期用于给定代码元素（例如，函数、类）的基本组件。高质量的代码文档不仅包括摘要，还包括参数描述、返回值、引发的异常以及可能的使用示例，这些信息依赖于目标组件的声明、主体和可见性。评估方法\n主要评估方法，采用抽象语法树（AST）和正则表达式的自动化检查器。\nAST Parsing：识别代码组件（类、函数、方法）并提取其生成的文档。 Code Analysis：分析代码声明和代码主体（例如：参数、返回语句、抛出异常是否存在）以及可见性（公共/私有），来确定文档部分。如没有参数的函数不需要“参数”部分，而公共类可能比私有函数更有用。 Section Identification：检测文档字符串中标准部分（例如，摘要、描述、参数、返回值、抛出异常、示例、类属性）的存在，使用预定义模式和结构提示。 Scoring：计算每个文档字符串的完整性得分，作为所需部分存在的比例。0.0～1.0之间。 这种确定性方法提供了一个结构遵循的客观度量，表明文档是否符合基本形式要求。\n帮助性（Helpfulness） 帮助是评估文档内容内容的语义质量和实用价值，一个有帮助性的文档不仅限于重申代码元素；它阐明了代码的目的、使用上下文、设计理由和潜在限制。\nClarity and Conciseness: 摘要信息是否简洁 Descriptive Depth：扩展描述是否提供了足够的信息，解释了代码背后的“为什么”，或者提到了相关场景或边缘情况？ Parameter/Attribute Utilty：输入和属性的描述是否有意义，是否指定了预期的类型、值范围或约束，而不是仅仅重复名称？ Guidance：文档是否有效地指导开发者何时以及如何使用该组件？ 评估方式，使用LLM进行评估，作者提出了一套框架。Component Specific Evaluation：作者将评估分解为分别评估文档的不同部分（摘要、主要描述、参数描述）使用针对每个部分的提示词。Structured Prompt Engineering:\n明确评分标准（Explicit Scoring Rubrics）：详细标准用5分制Likert特量表（1=Poor，5=Excellent） 示例说明（Illustrative Examples）：具体对应不同等级的文档片段示例，确立评价标准 分步说明（Step-by-Step Instructions）：引导LLM分析代码，将文档与评分标准进行比较，考虑代码的上下文，并为其评分提供理由。 标准的输出格式（Standardized Output Format）：要求大模型提供结构化输出，包括详细的推理、具体的改进意见（如适用）以及最终的数值评分。 这种结构化方法允许对语义质量进行可扩展的评估，超越了表面层次的检查，以衡量文档对开发者的实际价值。\n真实性（Truthfulness） 由于LLM存在幻觉，因此可能会导致生成文档时引用不存在的函数、参数或类，或者错误地表示组件之间的关系，因此有必要评估文档的真实性。作者通过验证生成的文档中提到的实体是否确实存在与目标的代码库中以及引用是否正确来评估真实性。主要过程包含三部分：\n代码实体提取（Code Entity Extraction）：大模型用提示词从代码仓库中提取特定代码组件（类、函数、方法、属性）。提示词特别的引导大模型区分关键字、内置类型和常见外部库组件，重点关注内部引用。 真实构造（Ground Truth Construction）：作者利用Navigator构建的依赖图，将其用作基准事实，包含所有代码组件及其在存储库中的规范表示。 验证（Verification）：每个提取的实体提及都与依赖图进行交叉引用。 作者使用Existence Ratio来量化Truthfulness，即文档中提及的实体与代码库中的实际实体的比例。${Existence Ratio} = \\frac{Verified Entities}{Extracted Entities}$\n高比率表明文档在实际代码结构中很好地建立了基础，从而最大限度地减少了幻觉引用的风险。\n实验 (Experimental) 基线（Baselines） FIM（Fill-in-the-middle） 用途模拟：模拟内联代码补全工具，通过补全“中间空白”来预测注释内容。 使用模型：使用的是 CodeLlama-13B（Roziere 等人，2023），这是一个开源模型，专门针对 FIM 任务进行训练（Bavarian 等人，2022）。 简称：FIM-CL Chat 用途模拟：将代码片段直接输入到聊天模型中，请其生成文档注释，代表了当前流行的基于对话的使用方式。 测试模型： GPT-4o mini：简称 Chat-GPT CodeLlama-34B-instruct：简称 Chat-CL 实验设置（Experimental Setup） Data: 选择了一组具有不同规模、复杂度和领域的Python代码库的代表性子集，以确保多样性。数据集包括具有不同依赖密度的模块、函数、方法和类。\nSystem: 作者评估了 DocAgent 的两个变体，仅在所用底层大语言模型（LLM）上有所不同\nDA-GPT：基于 GPT-4o mini 的 DocAgent 版本 DA-CL：基于 CodeLlama-34B-instruct 的 DocAgent 版本 Statistical: 所有关于统计显著性的结论均基于配对 t 检验（paired t-tests）， 显著性阈值设为：p \u0026lt; 0.05\n实验结果（Experimental Results） 作者主要对Completeness、Helpfulness和Truthfulness三个方面进行了评估。\n完整性试验 从结果来看DocAgent的方法完整性显著优于Chat和FIM。说明DocAgent能够生成更全面的代码文档，包含更多必要的部分。\n帮助性试验 如表所示，DocAgent实现了最高的整体有用性得分，显著优于相应的Chat和FIM，展示了其通过利用检索到的上下文生成更清晰、更有信息量的内容的能力。即使生成有用的参数描述是非常困难的，但是在这里，DocAgent依旧是最高分，这表明其结构化方法有助于这项困难任务，尽管仍有改进空间。\n真实性试验 上表的结果展示了DocAgent生成的文档在事实准确性方面的优越性。DocAgent实现了最高的存在比率，表明其大部分对内部代码组件的引用都是正确的。\n消融试验 - Helpfulness DA-Rand表示Navigator部分不进行拓扑排序，随机处理代码组件。\n由试验表明，经过拓扑排序的DocAgent在帮助性方面表现更好，表明依赖感知的处理顺序对生成有用的代码文档至关重要。\n消融试验 - Truthfulness 由试验表明，虽然没有Navigator，Searcher依然能检索依赖的组件。然而没有遵循“依赖优先”原则，这些组件不太可能有可用于上下文的现有文档。\n总体而言，消融结果证实，导航器的依赖感知拓扑排序是DocAgent的关键组成部分，通过实现有效的增量上下文管理，显著提高了生成文档的有用性和事实准确性。\n参考文献 (References) LLM Agent Guang Yang, Yu Zhou, Wei Cheng, Xiangyu Zhang, Xiang Chen, Terry Yue Zhuo, Ke Liu, Xin Zhou, David Lo, and Taolue Chen. 2024. Less is more: Docstring compression in code generation. arXiv preprint arXiv:2410.22793. Shinn Yao, Jeffrey Zhao, Dian Yu, Kang Chen, Karthik Narasimhan, and Yuan Cao. 2022. React: Synergizing reasoning and acting in language models. arXiv preprint arXiv:2210.03629. Noah Shinn, Margaret Labash, and Stefano Ermon. 2023. Reflexion: Language agents with verbal reinforcement learning. arXiv preprint arXiv:2303.11366. Xiang Li, Qinyuan Zhu, Yelong Cheng, Weizhu Xu, and Xi Liu. 2023b. Camel: Communicative agents for “mind” exploration. arXiv preprint arXiv:2303.17760. Ziniu Wu, Cheng Liu, Jindong Zhang, Xinyun Li, Yewen Wang, Jimmy Xin, Lianmin Zhang, Eric Xing, Yuxin Lu, and Percy Liang. 2023. Autogen: Enabling next-generation multi-agent communication with language models. arXiv preprint arXiv:2309.07864. Xiaoqing Zhang, Zhirui Wang, Lichao Yang, Wei Zhang, and Yong Zhang. 2023b. Mapcoder: Map-reducestyle code generation with multi-agent collaboration. arXiv preprint arXiv:2307.15808. Yuzhang Qian, Zian Zhang, Liang Pan, Peng Wang, Shouyi Liu, Wayne Xin Zhao, and Ji-Rong Wen. 2023. Chatdev: Revolutionizing software development with ai-collaborative agents. arXiv preprint arXiv:2307.07924. Code Summarization Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing Qin, Ting Liu, and Daxin Jiang. 2020. Codebert: A pre-trained model for programming and natural languages. In EMNLP. Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Nan Duan, Ming Zhou, and Daxin Jiang. 2021. Graphcodebert: Pre-training code representations with data flow. In ICLR. Wasi U Ahmad, Saikat Chakraborty, Baishakhi Ray, and Kai-Wei Chang. 2021. Unified pre-training for program understanding and generation. In ACL. Yue Wang, Shuo Ren, Daya Lu, Duyu Tang, Nan Duan, Ming Zhou, and Daxin Jiang. 2021. Codet5: Identifier-aware unified pre-trained encoder-decoder models for code understanding and generation. In EMNLP. Colin B Clement, Andrew Terrell, Hanlin Mao, Joshua Dillon, Sameer Singh, and Dan Alistarh. 2020. Pymt5: Multi-mode translation of natural language and python code with transformers. In EMNLP. Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, and 1 others. 2021. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374. Raymond Li, Lewis Tunstall, Patrick von Platen, Jungtaek Kim, Teven Le Scao, Thomas Wolf, and Alexander M. Rush. 2023a. Starcoder: May the source be with you! Preprint, arXiv:2305.06161. Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Romain Sauvestre, Tal Remez, and 1 others. 2023. Code llama: Open foundation models for code. arXiv preprint arXiv:2308.12950. 优点与创新点 (Strengths) 有图论的理论支撑，通过依赖图和拓扑排序来处理复杂的代码依赖关系。 试验客观性强，紧紧依赖于代码的AST和正则表达式，避免了人工评估的主观性。 我的思考 (Personal Thoughts) 是否可以考虑将DAG图用于通过需求生成复杂业务的代码中？ 对于项目级别的代码生成后，能否通过DocAgent类似的方法再生成用户手册/开发文档？\n","permalink":"http://rextechie.github.io/posts/paper_note/doc_agent/","summary":"基本信息 标题: DocAgent: A Multi-Agent System for Automated Code Documentation Generation 作者: Dayu Yang（通讯作者）、Antoine Simoulin、Xin Qian等。 作者单位: Meta AI 期刊/会议: ArXiv 发表年份: 2025.04.11 DOI: 2504.08725 开源地址: Github 关键词: Code Documentation, Multi-Agent System, Large Language Models 研究问题 (Research Questions) 如何自动生成代码文档，尤其是处理复杂的依赖关系和上下文信息？\n研究背景 (Background) 像现在的方法FIM（Fill in the Middle）和 chat agent可以实现自动化生成代码文档，但还是有一些局限性：\n省略了必要的信息（例如，参数或返回值描述）。 它们通常提供最少量的上下文或理由，限制了生成文档的有用性。 由于LLM的幻觉，会虚构不存在的组件，尤其是规模比较大的项目中。 核心贡献 (Key Contributions) DocAgent，一个多智能体、拓扑结构化的上下文感知文档生成系统。 一个衡量代码文档完整性、实用性和事实一致性的稳健评估框架。 全面实验表明，DocAgent在多个数据集中持续优于最先进的基线。 方法 (Methodology) DocAgent分两个阶段来处理复杂的依赖关系并确保上下文的相关性。\n用一个Navigator确定一个最佳的依赖感知的处理顺序 Multi-Agent System系统增量地生成文档，利用专门的Agent进行代码分析、信息检索、编写文档和验证 Navigator: 感知依赖顺序 生成代码级别的文档需要理解依赖代码之间的关系，然而如果给出所有内容，很容易超出上下文窗口的限制。Navigator模块就是为了解决这个问题，Navigator建立了一个处理顺序，确保处理依赖关系之后才对组件进行文档化，从而实现增量上下文构建。\n构建依赖图 首先对整个存储库进行静态分析，解析源文件的抽象语法树（AST，Abstract Syntax Tree），以识别代码组件（函数、方法、类）及其相互关系（函数调用、继承、属性方法和模块导入），用一个有向无环图（DAG， Directed Acyclic Graph）来表示，节点是组件，边是依赖关系。为了实现拓扑排序，用Tarjan算法检测图中的循环，并将其浓缩单个超级节点。","title":"DocAgent: A Multi-Agent System for Automated Code Documentation Generation"},{"content":"基本信息 标题: Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 作者: Minju Seo, Jinheon Baek, Seongyun Lee, Sung Ju Hwang等。 作者单位: KAIST, DeepAuto.ai 期刊/会议: ArXiv 发表年份: 2025 DOI: 2504.17192v2 开源地址: Github 关键词: Large Language Models (LLMs), Code Generation（Machine Learning） 研究背景 (Background) 尽管机器学习研究的迅速增长，但相应的代码实施通常无法实现，这使研究人员重现结果并在先前的工作基础上进行劳动密集型。同时，最近的大型语言模型（LLMS）在了解科学文档并生成高质量代码方面表现出色。\n研究问题 (Research Questions) 用agent复现机器学习相关的论文方法与实验\n核心贡献 (Key Contributions) 提出从科研论文自动生成代码的框架: PaperCoder ​​三阶段工作流程​​：PaperCoder框架将代码生成任务分解为三个结构化的阶段，规划、分析、编码。 构建基准数据集（包含90篇来自ICML、NeurIPS和ICLR 2024的论文） 在PaperBench基准测试中的优异表现：在新发布的PaperBench基准测试中，PaperCoder表现出色，显著优于其他强基线方法。 方法（Methods） 作者引入了PaperCoder，是一种新颖的框架，用于实现研究仓库（论文复现出来的代码仓库）的生成。作者将工作过程建模为M(R) = C，其中M是模型，R是论文，C是代码。受软件开发方法的启发，作者采用了一种结构化的方法，该方法反映了良好的经验验证的软件工程原则，即：规划-分析-实现的工作流程。为了实现这一目标，作者将过程分解为三个阶段：1）规划（Planing）. 2）分析（Analyzing）. 3）编码（Coding）。每个阶段都利用多智能体方案。更加规范化的定义是C = M (P) = M_code(R, P, A)，其中R是论文，P是规划，A是分析。每个部分的生成遵循：P = M_plan(R), A = M_analysis(R, P) and C = M_code(R, P, A)。完整的流程如下图所示：\n规划（Planing） 直接将论文作为输入，生成代码是不现实的，因为论文只要是为了记录一些发现和说服读者自己的方法，而不是作为软件开发的结构化输入。因此论文通常包含补充信息，尽管有些核心概念至关重要，但是与实现无关。这些噪音，都会使得代码生成非常的困难。为了解决这个问题，需要将论文分解为结构化的多个角度的计划。作者用四个步骤来描述论文的分解计划：总体规划、架构设计、逻辑设计和配置文件生成。用公式表示即：Mplan(R) = P = {o, d, l, g}，o表示总体规划的产物，d表示架构设计的产物，l表示逻辑设计的产物，g表示配置文件的产物。每个输出都是在相应的阶段生成的，此阶段遵循一个顺序结构，每个阶段的输出作为下一个输入。\n总体规划（Over Plan） 规划阶段的第一步就是总体规划，涉及概括和组织从大局观（原文使用的是从高级别的角度）的角度看到的实现论文代码所具备的核心要素。提取出来的摘要信息提供了基本的概念框架，可以清楚地指导后续步骤。对应的公式表示是M_plan(R) = o, R表示论文，o表示总体的规划。\n架构设计（Architect Design） 第二阶段是通过上一阶段的产物和论文，来架构软件。设计良好的结构是必不可少的，特别是对于软件系统必须无缝交互的软件系统。这个阶段着重于确定必要的组成部分并定义其关系，以确保井井有条且符合功能的代码仓库。为了实现这个目标，作者要求创建定义软件体系结构的关键artifact。\nFile list: 文件列表是存储库所需的文件的结构化集合，概述了软件的模块化结构。 Class diagram：类图提供了系统数据结构和接口的静态表示，使用UML类图进行描述。 Sequence diagram：时序图以动态表示程序的调用流程和对象直接的交互，同样适用UML表示。 这种结构化方法可确保对软件体系结构的清晰有组织的表示。通过构建这些artifact，可以直观地展示论文中描述的基本组成部分，从而使得代码生成方法更加结构化和系统化。这个过程有助于更好地分析依赖关系，从而确保生成的代码仓库与论文的核心思想保持一致。用公式表示：M_plan(R, o) = d，其中r是论文，o是总体规划，d是架构设计的产物。\n逻辑设计（Logic Design） 在软件开发过程中，各个文件很少独立发挥作用。取而代之的是，它们通常通过导入包和模块交互。比如，如果在utils.py中定义了一个函数a，然后将函数a导入evaluation.py，为了保持正确的依赖结构，utils.py必须在evaluation.py之前实现。为了解决这些依赖性，这个阶段将论文、总体规划的产物和架构设计的产物一起输入。然后分析每个文件及其组件的逻辑，确定必要的依赖项和实现的最佳执行顺序。最终的输出，它会生成一个有序的文件列表，详细说明每个文件作用，以及考虑到依赖关系和仓库内依赖项应实现哪些文件。这个方法可确保存储库的生成不仅考虑单个文件结构，还考虑相互通信，从而促进了组织良好且逻辑上连贯的实现。用公式表示：Mplan(R, o, d) = l，R是论文，o是总体的规划，d是架构设计的产物，l是逻辑设计的产物。\n配置文件生成（Configuration File Generation） 最后，配置文件生成的阶段合成了之前所有的产物，生成包含模型训练所需的超参数和配置文件（config.yaml）。在这个阶段，用户可以查看和修改config.yaml文件，以识别和纠正丢失或错误指定的详细信息。例如用户可能需要指定huggingface数据集的路径或定义checkpoint存储目录。这个步骤有助于减少生成过程中的幻觉，例如产生不存在的数据集或引用错误的文件路径。用公式表示：M_plan(R, o, d, l) = g，R是论文，o是总体的规划，d是架构设计的产物，l是逻辑设计的产物，g是配置文件的产物。\n分析（Analyzing） 规划阶段主要关注设计整体代码的架构并概括大致的路线图，分析阶段主要深入设计每个文件的实现。在这个阶段，对仓库中每个文件的详细目的和必要的考虑进行了彻底的分析。具体而言，这个阶段的输入包括论文以及先前输出的产物，输出包括文件级别的分析准确实现细节，以后将为代码生成过程提供信息。用公式表示：$(\\{0, d, l, g\\}, f_{i}) = a_{i}^{n}$，其中R是论文，d是架构设计的产物，l是逻辑设计的产物，g是配置文件的产物，f是文件，a是分析，n是文件的个数。这个过程对每个文件单独应用，以生产一个文件级的实现计划。\n编码（Coding） 最后的阶段是编码阶段，它会产生构成研究仓库的代码。每个文件的生成都以之前的输出为指导。由于仓库文件直接通常存在导入依赖，因此要求严格遵循规划阶段简历的有序文件列表，确保顺序一致性。用公式表示：$\\{ M_{\\text{coder}}(R, P = \\{0, d, l, g\\}, f_i, a_i) = c_i \\}_{i = 1}^{n(\\text{file})}$，其中R是论文，d是架构设计的产物，l是逻辑设计的产物，g是配置文件的产物，f是文件，a是分析，n是文件的个数，c是文件级代码。最初生成的代码可能需要调试或完善，以确保正确性和完整功能。在这项工作中，综合调试策略和详细的错误纠正工作流程超出了本文的范围。\n实验环境（Experimental Setup） 数据（Data） Paper2Code Benchmark: 数据源于ICML 2024、NeuraIPS 2024 and ICLR 2024。通过OpenReview API过滤出具有开源代码的论文。在其中选择出总代码库少于70000个标记的仓库。为了确保质量，作者评估了基于模型的仓库，并在每个会议选择了得分最高的30篇论文。最终有90篇论文作为实验的基准。对于人类评估，我们选择评估参与者撰写的13篇论文(大多来自于KAIST，不全是顶会)。 PaperBench Code-Dev: 作者进一步使用PaperBench Code-Dev基准验证我们的框架，该基准包含来自ICML 2024的20篇精选论文集。这个数据集来源于OpenAI 2025.04.02发表的PaperBench论文 基线和我们的方法（Baselines and Our Model） Paper2Code Benchmark: 由于没有直接的方法可以实现端到端将论文转为代码，因此作者将几种相关的方法作为基准，尤其是那些用自然语言输入的软件开发设计的方法。 ChatDev MetaGPT Abstract: 一个简单基准，其中只向语言模型提供论文的摘要，要求它根据最少的信息实现代码库。 Paper: 另一个简单的基准，其中将完整论文作为输入，并提示模型生成相应的代码仓库。 PaperCoders（作者的方法） Oracle: 该论文作者发布的官方代码仓库。 PaperBench Code-Dev: 作者将PaperCoders的方法与PaperBench论文中提到的两个智能体进行比较。 Basic Agent：基本智能体遵循ReAct风格的方案，并配备了一套预定义的工具，包括bash shell命令执行器、Python代码运行器、网页浏览器以及用于处理长文档的分页文件阅读器。 Iterative Agent：迭代智能体通过利用全部可用计算时间并融入鼓励通过子目标分解逐步推理的定制提示策略，扩展了基本智能体 评估指标（Evaluation Setup） Paper2Code Benchmark 评估代码生成通常依赖于单元测试或验证特定的实现组件。然而，由于缺乏黄金标准库，因此这类评估不可行。许多论文不发布官方代码，即使发布了，测试脚本也常常不可用。此外，手动标注每篇论文的ground-truth实现细节非常耗时，使得大模型评估不切实际。\nModel-Based Evaluation 为了解决这种挑战，作者提出一种基于模型的评估方法，该方法在上使用或不使用黄金标准库的情况下评估生成仓库的质量。考虑两个变量：1）reference-based，同时使用论文和作者提供的源码。2）reference-free，仅使用论文评估生成的仓库。对于这两种变体，使用语言模型对所需的实现组件进行评价并评估其正确性。它将严重程度级别（高、中、低）分配给任何缺失或存在缺陷的元素，并在1到5的范围上生成一个整体正确性的粉。为确保稳定性，作者使用n-way采样报告多次生成的平均得分。在这个实验中，作者设置n=8并使用o3-mini-high作为一个评估模型。 Reference-Based Evaluation 当存在官方存储库时，将本文中描述的方法视为可能实现的方案。虽然可能存在多个有效的实现，但作者发布的版本视为最准确的版本。在这个实验设置中，作者提供论文和黄金标准仓库作为输入，并且让评估模型来识别和评价所需的组件。然后，模型将预测的库与这些组件进行比较，并从1～5分配一个正确性分数，反映组件覆盖率和任何错误的严重程度。 Reference-Free Evaluation 在许多情况下，作者发布的版本不可用。为了处理此类情况,作者提出一种只根据论文，评价生成的存储库的策略。该模型通过提示词用评估模型评价生成的各个组件，并评估它们是否在生成的仓库中得到充分实现。然后根据这些组件的质量，分配一个1～5的正确性分数。 Human Evaluation 尽管有了模型评估的方式，还是需要人类评估的方法。由于任务复杂，需要理解论文并判断方案的可行性，作者招募了计算机科学专业的MS和PhD学生，要求有至少撰写一篇同行评审论文的经验。评估过程如下 首先，标注着根据论文定义关键事实标准，涵盖数据处理、方法和评估部分。 他们随后对生成的代码库进行审查和排名，分为以下三个比较组: Group1: Model Variants of Our Method 作者的系统使用不同的主干模型（例如，o3-mini vs 其他三个开源方式）； Group2: Navie Baselines. 仅使用论文或摘要作为输入生成的仓库； Group3: Related Works. 由MetaGPT和ChatDev等现有软件开发框架生成的仓库。在每一组中，标注员分配一个相对排名。排名被转换为1-5分的评分。在有三名候选人的小组中，排名第一的仓库获得5分，第二获得3分，第三获得1分。在完成所有组级别的排名之后，注释者被要求选择总体上最好的存储库，并提供一个简短的理由。他们还被问及，排名第一的仓库是否会比从头开始更容易重现论文的方法和实验。如果不是，他们需要解释原因。 最后，标注者重新访问作者的方法生成的仓库，评估之前定义的每个实现标准是否完全（o）、部分（△）或未满足（×）。 PaperBench Code-Dev Evaluation 为了评估作者的系统在PaperBench Code-Dev基准测试上的表现，作者采用了PaperBench官方的评估协议，该协议测量了在精心挑选的ICML 2024论文集中的复制准确性。具体来说，我们遵循原始论文作者撰写的评分标准，该标准定义了一套层次化的实现要求。评估模型根据提交的代码是否正确实现了任何指定要求来评估每个生成的代码库。重要的是，评估仅关注代码开发节点，即候选代码库是否包含某些要求的正确实现。\n实验结果与分析 (Experimental Results \u0026amp; Analysis) Main Results Correlation between Reference-based and Reference-free 作者希望通过这个实验来验证是否可以使用reference-free的评估方法来替代reference-based。实验方法即通过对生成的代码仓库分别使用reference-free和reference-based评分方式进行评分，然后看这两种评分直接是否相关（即是否一致）。\nr（皮尔逊相关系数）：衡量两个变量之间的线性相关程度。范围（-1～+1） p（显著性水平）：p值表示观察到当前数据的结果在“零假设”（即认为两者无相关性）成立的情况下出现的概率。范围（0～1） PaperBench Code-Dev Results 作者想要与OpenAI提出的PaperBench进行比较，分别比较了其论文中提到的BasicAgent和IterativeAgent\nHuman Evaluation Results 为了评估生成代码的实际效用和主观质量，作者进行了全面的人工评估。\nDetailed Analysis on Generated Repository 作者进行更精细的人类评估。具体就是让作者自己从baseline和消融实验变体的仓库中选择一个比较好的一个。77%（13人位作者中的10位）选择了由作者方法生成的仓库，10人里有3人选择了消融变体生成的代码。\n为了进一步评估实用性，询问参与者从头开始相比，排名最高的仓库是否会使复现论文的方法和实验更简单。85%表示了认可。 对于每个论文的每个部分（Data Processing, Method, Evaluation），要求作者评估是否完全实现了每个标准。结果如下所示：\nAnalysis on Human Alignment for Evaluation 这个实验是为了评估模型评估的可信度，上表报告了在reference-based和reference-free的配置下，人类评分与模型评分之间的秩相关。由实验结果表明，人类评分与模型评分的相关性是较高的，因此基于模型的评估方式可以作为参考。\nAnalysis on Different LLMs 作者分别应用DeepSeek-Coder-V2-Lite-Instruct、Qwen2.5-Coder-7B-Instruct、DeepSeek-R1-Distill Qwen-14B、o3-mini-high在框架中。作者的实验结果中，o3-mini-high的模型性能最高。\nAblation Studies Analysis on Executability 为了验证生成的代码不仅结构合理，而且能够在最小干预下执行，作者对五篇代表性论文进行了手动调试分析。对于每种情况，作者都尝试执行生成的存储库，并记录为实现成功运行而修改的行数。\n参考文献 (References) PaperBench: Evaluating AI\u0026rsquo;s Ability to Replicate AI Research 备注 (Notes) 本文实验内容丰富\n优点与创新点 (Strengths) 实验中大量使用了统计学相关的指标来判断模型：皮尔逊系数、显著性水平、秩相关系数 三阶段的设计中侧重于规划阶段的设计，规划阶段中包含绘制类图、时序图，使得编码时更加规范 规划阶段，确定好生成的文件，并文件的功能，分析阶段具体分析各个文件的详细功能。 局限性与不足 (Limitations) 方法缺乏迭代优化 方法中各智能体无法自动实现协作，需要手动一个个执行文件。 我的思考 (Personal Thoughts) 本文由于实验直接执行困难，只能通过模型评估和人类评估的方式进行实验，因此还需要进行实验验证评估方式的有效性。这种实验方式可作为后续实验的参考。\n","permalink":"http://rextechie.github.io/posts/paper_note/paper2code/","summary":"基本信息 标题: Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 作者: Minju Seo, Jinheon Baek, Seongyun Lee, Sung Ju Hwang等。 作者单位: KAIST, DeepAuto.ai 期刊/会议: ArXiv 发表年份: 2025 DOI: 2504.17192v2 开源地址: Github 关键词: Large Language Models (LLMs), Code Generation（Machine Learning） 研究背景 (Background) 尽管机器学习研究的迅速增长，但相应的代码实施通常无法实现，这使研究人员重现结果并在先前的工作基础上进行劳动密集型。同时，最近的大型语言模型（LLMS）在了解科学文档并生成高质量代码方面表现出色。\n研究问题 (Research Questions) 用agent复现机器学习相关的论文方法与实验\n核心贡献 (Key Contributions) 提出从科研论文自动生成代码的框架: PaperCoder ​​三阶段工作流程​​：PaperCoder框架将代码生成任务分解为三个结构化的阶段，规划、分析、编码。 构建基准数据集（包含90篇来自ICML、NeurIPS和ICLR 2024的论文） 在PaperBench基准测试中的优异表现：在新发布的PaperBench基准测试中，PaperCoder表现出色，显著优于其他强基线方法。 方法（Methods） 作者引入了PaperCoder，是一种新颖的框架，用于实现研究仓库（论文复现出来的代码仓库）的生成。作者将工作过程建模为M(R) = C，其中M是模型，R是论文，C是代码。受软件开发方法的启发，作者采用了一种结构化的方法，该方法反映了良好的经验验证的软件工程原则，即：规划-分析-实现的工作流程。为了实现这一目标，作者将过程分解为三个阶段：1）规划（Planing）. 2）分析（Analyzing）. 3）编码（Coding）。每个阶段都利用多智能体方案。更加规范化的定义是C = M (P) = M_code(R, P, A)，其中R是论文，P是规划，A是分析。每个部分的生成遵循：P = M_plan(R), A = M_analysis(R, P) and C = M_code(R, P, A)。完整的流程如下图所示：","title":"Paper2Code"},{"content":"基本信息 标题: PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving 作者: Mihir Parmar、Xin Liu等 作者单位: Google、Arizona State University 期刊/会议: ArXiv 发表年份: 2025 DOI: 2502.16111 开源地址: 🈚️ 关键词: Agent 研究背景与问题 (Background \u0026amp; Questions) 有效的计划是设计在解决复杂现实世界问题的系统的关键组件。传统的用模板化的方式缺乏通用性。 LLM 可以较好的做一些规划任务，比如用 LLM 在自然语言中做规划可以解决一些代码问题。因此作者考虑增强 LLM 生成计划的能力，并证明其在科学和金融领域下游任务的实用性。\n核心贡献 (Key Contributions) 总结本文的主要贡献点：\nPlanGEN，一种新颖的、模型无关的、可扩展的多智能体框架，用于增强LLM的自然规划。 在一些复杂规划和推理的 Benchmarks 上达到了 SOTA 级别。 一种基于约束的验证和基于实例级复杂性的推理算法选择的新方法。 PlanGEN LLM Agents PlanGEN 包括三个 大模型 Agent：Constraint Agent、 Verification Agent 和一个 Selection Agent。每个Agent使用现成的 LLM（如：Gemini, GPT）。\nContstraint Agent “约束”定义为验证问题解决方案所必须的标准。这些标准是具体例子特定的，比如：在 NATURE PLAN 的日历安排中，包括“个人计划”、“可用性”、“偏好”；在 GPQA 的科学推理问题中，约束可能是“使用的概念”、“计算正确性”和“公式选择”。作者认为，提取实例的约束对于成功验证至关重要。Constraint Agent是框架中的预处理组件，负责从问题描述中提取约束。通过分析输入问题，该Agent可以确定生成Plan验证所需的所有可能的关键约束。提取的约束为验证提高 Planning 过程整体相关性和质量的计划提供了基础。Constraint Agent 使用的 Prompt 使其能够通过要求 LLM 关注问题描述的特定方面，系统地识别约束。这样可以确保没有忽略关键信息，并且最终的约束是全面的。\nVerification Agent Verification Agent在框架中发挥着关键作用，通过评估由Constraint Agent生成的约束条件所生成的计划的质量。这个 Agent 用来确保计划和任务目标保持一致，遵守约束，并在逻辑上朝着正确的解决方案进行进展。Verification Agent有两个关键组件：(i) Feedback Generation，以及 (ii) Numerical Reward Generation。\nFeedback Generation 当验证约束与生成的计划，Verification Agent 会生成有关计划质量评估的详细推理。作者把这一过程视为“反馈”，提供了可解释性和可行的下一步改进。\nNumerical Reward Generation 受到Chain-of-experts的启发，作者让 Agent 评估生成的计划和约束，并给出-100 ～ 100的奖励分数。评分机制要求按照严格的质量标准，其阈值表示为高质量的计划（如95）。\nSelection Agent Selection Agent 根据任务的复杂性动态的选择最合适的推理时算法。它利用历史表现、多样性和恢复分数以及来自大模型的指导，自适应地选择当前任务的最佳算法。为了创建 Selection Agent，作者使用了一个修改后的置信区间上界算法（UCB，Upper Confidence Bound）策略。这个策略结合了多个因素：归一化奖励、探索奖金、多样性调整和恢复分数。此外，该 Agent 整合了LLM的先验知识，根据问题描述、任务要求和先前计划（如有）提供算法适用性评分。这些先验条件使 Agent 能够将其选择的算法与输入实例的复杂性和相应的约束对齐，提高所选算法的相关性。\nModified UCB Policy 方程结合了多个术语以平衡在给定任务实例中选择最佳算法时的利用和探索。\n$UCB(a) = \\frac{R(a)}{N(a)} + \\sqrt{\\frac{2 \\log(T+1)}{N(a)}} + \\lambda_{\\text{prior}} \\cdot \\text{Prior}(a) + \\frac{\\alpha_{\\text{diversity}}}{N(a)+1} + \\alpha_{\\text{recovery}} \\cdot S_{\\text{recovery}}(a)$\n第一项$\\frac{R(a)}{N(a)}$表示的是算法 a 的平均奖励得分，其中 $R(a)$ 表示算法 a 的累积的总奖励，$N(a)$ 表示算法 a 被选择的次数。这一项确保优先根据历史经验选择。\n第二项$\\sqrt{\\frac{2 \\log(T+1)}{N(a)}}$ 是探索部分，鼓励选择尝试次数较少的算法。\n第三项$\\lambda_{\\text{prior}} \\cdot \\text{Prior}(a)$ Prior(a) 是基于LLM（大语言模型）的先验评分，用于根据实例复杂性调整算法选择。在这里，λprior是一个动态衰减的权重，定义为λprior = 1+T，其中T代表试验的总数。\n第四项$\\frac{\\alpha_{\\text{diversity}}}{N(a)+1}$ 这一项惩罚被过度使用的算法，确保所有选项的平衡探索。\n第五项$\\alpha_{\\text{recovery}} \\cdot S_{\\text{recovery}}(a)$ S_recovery(a) 是算法 a 的恢复评分，奖励能够有效从失败中恢复的算法。\nSelection Process 选择过程首先要初始化算法的各个变量值，然后，智能体结合LLM引导的先验知识，根据问题陈述和任何提供的反馈为算法生成适宜度分数。这些先验知识来自LLM，并作为调整UCB值的初始估计。\nFramework PlanGen(Best of N) 受 RePrompt 启发，作者改编了 Best of N 算法，并使用他们自己的 Constraint 和 Verification Agent 对其进行修改。这个框架生成 N 个候选Plan（Plan 1, Plan 2, \u0026hellip;Plan n），每个 Plan 由 Verification Agent 根据一组约束进行评估。然后，Verification Agent 分配相应的Reward（Reward 1, Reward 2, \u0026hellip;Reward n）。最后选择 Reward最大的方案，确保得到一个最优解，该解最好地满足问题约束。\n其过程如图所示： PlanGen(ToT) 受 Tree of Thoght 启发，作者用 Constraint 和 Verification 修改了 ToT 算法。该方法首先初始化一个代表问题的根节点，并生成多个潜在的下一步步骤，创建一个树状结构。生成的步骤通过Verification Agent 进行验证，该Agent根据一组约束条件分配奖励分数。遍历过程包括评估给定深度的所有可能步骤，根据奖励分数选择最有希望的路径，并通过生成新步骤进一步扩展它。\n其过程如图所示： PlanGen(REBASE) 该框架集成了动态选择和扩展策略，以迭代优化解决方案。在树的每个深度，候选节点根据其分配的奖励分数（使用Verification Agent获得）进行排名，确保首先探索最有希望的候选者。即使奖励较低的步骤也被考虑，但随着子节点数量的减少，意味着它们的探索深度有限。这种层次化剪枝有助于保持效率，从而减少对较弱节点的无谓探索。这个过程会持续进行，直到找到有效、完整的解决方案或达到预定义的深度或宽度限制。此外，还有一个类似于ToT的完成检查，它可以识别代表完整解决方案的节点，一旦确定了令人满意的结果，REBASE就可以提前终止。\n其过程如图所示： PlanGen(Mixture of Algorithms) 算法混合框架（图1）引入了一个Selection Agent，该 Agent 根据实例级复杂度动态选择上述章节中提出的inference-time algorithm。该框架以模块化和迭代的方式运行，确保在有效解决不同复杂度的规划和推理问题时具有适应性。\nOrchestration 这个过程开始于用 LLM 根据任务和问题描述生成一个初步的计划。与此同时，Constraint Agent来生成特定任务和问题的约束集。根据约束条件，Verification Agent 评估初步计划的质量并提供一个奖励分数。如果初步计划达到所需的阈值，则可作为最终计划接受，否则，开始Iterative Refinement过程。\nIterative Refinement 这个优化循环由一系列推理算法驱动。在这次Iterative Refinement过程中，Selection Agent 根据实例特定的复杂性和历史的 UCB 值确定最合适的算法。所选算法生成一个更新后的计划，然后由Verification Agent 重新评估。为确保持续改进，框架纳入了由提供指导的Verification Agent 生成的反馈，这个反馈循环使系统能够逐步优化计划。\n实验与结果（Experiments and Results） 实验安排（Experiment Setup） Datasets 为了展示自然规划能力的提升，我们使用了NATURAL PLAN。在改进计划后，我们表明这显著增强了LLMs在两个基准上的推理能力：GPQA和OlympiadBench（仅文本）。此外，我们表明PlanGEN在特定领域数据集DocFinQA上提高了性能。\nBaselines and Our Frameworks 我们为与我们的框架进行比较开发了两个baselines：(i) Zero-shot CoT 和 (ii) a Vanilla Multi-Agent Baseline。在 Zero-shot COT，作者为框架提供了输入提示，该模型以\u0026lt;Cot reasoning\u0026gt;的形式生成输出。对于 Multi-Agent Baseline， 相同的模型在多次迭代中反复调用。系统通过反馈循环反复优化其输出，其中反馈是基于一个旨在提高推理能力的自我反思提示词生成的。我们在所有基准上评估所有提出的框架。对于推理任务，我们采用两阶段方法：(1) 使用我们的框架生成一个优化方案，(2) 执行产生最终答案的计划。\n主要结果（Main Results） 下图比较了各种单智能体和多智能体baselines（baselines间有所不同——GPQA的一些单智能体基线来自gpqa-eval的多智能体框架的性能。从结果来看，多智能体框架始终优于baselines。\nPerformance on NATURAL PLAN 对于图 a 可以看出，PlanGen(Best of N)在所有任务中取得了最高的 EM 分数：60.7(Calendar), 43.8(Metting) 和 41.63(Trip)。在所有四个框架都比最强的 Baseline(多智能体) 高出约 10%。对于会议和旅游计划，除了 ToT 之外，所有框架都比最好的 Baseline(Gemini-1.5-Pro) 分别高出约 6% 和约 7%。PlanGEN(Mixture of Algo.) 在会议和旅游计划中达到了第二高的表现，而在日程计划中仍然具有竞争力。这些结果证明了我们的框架在处理多样化的自然语言规划任务以及建立 NATURAL PLAN 三个类别 SOTA的有效性。\nPerformance on OlympiadBench 从图b来看，PlanGEN(Mixture of Algo.) 在数学分类上达到了最高的准确性(55.94%), 表现优于最强的Baseline(Multi-Agent, 50.68%) 大约 5%。值得注意的是，PlanGEN（Mixture of Algo.）在MATH中的卓越性能突显了其在复杂数学推理中的有效性，为MATH达到了SOTA。在PHY类别中，所有多智能体框架都超越了Gemini-1.5-Flash（最强基线），其中PlanGEN（Best of N）实现了最高的准确率（31.78%），在PHY达到了SOTA。\nPerformance on GPQA 从图c可以看出，PlanGEN（Mixture of Algo.）实现了最高的准确率（59.6%）。单个推理时间算法的性能较低，表明选择是有用的。所有提出的框架都大幅优于Gemini-1.5-Pro（46.2%）、GPT模型（∼48%）和Claude-3-Opus（50.4%）。而Claude-3.5-Sonnet和Multi-Agent Baseline与PlanGEN（Mixture of Algo.）相比，表现具有竞争力（∼59%）。\nPerformance on DocFinQA 从图d可以看出，我们的框架在DocFinQA上的性能显著提升，PlanGEN（Best of N）实现了最高的准确率（31.16%）和F1分数（29.45%），为该任务设定了SOTA。所有我们的框架都大幅超越了Gemini-1.5-Pro（最强Baseline）（∼7%）。这些结果突出了多智能体框架在金融文档理解以及在其上进行推理的有效性。\nPerformance of our frameworks w.r.t. different complexity 如图所示，我们对从NATURAL PLAN到日程调度任务的案例进行了研究，以分析不同复杂度级别对不同框架性能的影响。对于日程调度，我们发现PlanGEN（ToT）在简单问题上的表现最佳，而PlanGEN（Best of N）在中级问题上更为有效。随着复杂度的增加，PlanGEN（混合算法）被证明是最有效的方法。我们进一步对附录E中NATURAL PLAN提出的会议和行程规划进行了类似的分析。\nMain Findings 与单代理系统相比，多代理框架在生成优化规划轨迹方面表现始终如一（图5）。此外，多代理（Baseline）并不总是最强的基准，因为自我校正可能带来挑战，如黄等人在2024年所示。因此，系统内的不同代理需要不同的处理策略，类似于我们的PlanGEN。此外，即使在PlanGEN的多代理框架中，依赖inference-time algorithm对于更复杂的问题来说也证明是不够的（图6）。PlanGEN（Mixture of Algo.）方法在解决复杂规划问题方面具有显著优势，突出了根据实例特定复杂性选择算法的重要性（图1）。鉴于我们的框架是多代理的，我们在下一节进一步讨论了LLM调用次数与它们性能之间的关系。\n参考文献 (References) Os-copilot: Towards generalist computer agents with self-improvement. AFlow: Automating agentic workflow generation 备注 (Notes) 优点与创新点 (Strengths) 提供了一个选择inference-time algorithm的算法，这个算法基于数学理论算法扩展得到，不是简单通过让 LLM 选择。 局限性与不足 (Limitations) 作者没有提供开源代码，无法复现实验结果。 我的思考 (Personal Thoughts) 综述与我研究的相关性：能否让智能体自己规划编写项目的计划，然其他智能体进行实现与验证？ 是否有可以改进的地方：增加框架 后续可能的研究方向：将项目规划能力融入项目级代码生成中 ","permalink":"http://rextechie.github.io/posts/paper_note/plangen/","summary":"基本信息 标题: PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving 作者: Mihir Parmar、Xin Liu等 作者单位: Google、Arizona State University 期刊/会议: ArXiv 发表年份: 2025 DOI: 2502.16111 开源地址: 🈚️ 关键词: Agent 研究背景与问题 (Background \u0026amp; Questions) 有效的计划是设计在解决复杂现实世界问题的系统的关键组件。传统的用模板化的方式缺乏通用性。 LLM 可以较好的做一些规划任务，比如用 LLM 在自然语言中做规划可以解决一些代码问题。因此作者考虑增强 LLM 生成计划的能力，并证明其在科学和金融领域下游任务的实用性。\n核心贡献 (Key Contributions) 总结本文的主要贡献点：\nPlanGEN，一种新颖的、模型无关的、可扩展的多智能体框架，用于增强LLM的自然规划。 在一些复杂规划和推理的 Benchmarks 上达到了 SOTA 级别。 一种基于约束的验证和基于实例级复杂性的推理算法选择的新方法。 PlanGEN LLM Agents PlanGEN 包括三个 大模型 Agent：Constraint Agent、 Verification Agent 和一个 Selection Agent。每个Agent使用现成的 LLM（如：Gemini, GPT）。","title":"PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving"},{"content":"🚏 导论 代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。\n代理模式的应用场景\n远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 🚦 结构 UML类图 classDiagram class Client{ } class Subject{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +Request() } class RealSubject{ +Request() } class Proxy{ -realSubject: RealSubject +Request() } Client --\u0026gt; Subject Subject \u0026lt;|.. RealSubject Subject \u0026lt;|.. Proxy 代码实现 Subject类，定义了RealSubject和Proxy的公共接口，这样就在任何使用RealSubject的地方都可以使用Proxy\npublic class abstract Subject { public abstract void Request(); } RealSUbject类，定义Proxy所代表的真实实体\npublic class RealSubject extends Subject { @Override public void Request() { System.out.println(\u0026#34;真实的请求\u0026#34;); } } Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject相同的接口，这样代理就可以用来代替实体\npublic class Proxy extends Subject { private RealSubject realSubject; @Override public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } realSubject.Request(); } } 客户端代码\npublic class Client { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.Request(); } } 🎭 优缺点分析 😊 优点 🙁 缺点 🎬 场景 一个谈恋爱的问题，小刚喜欢小红，但是小刚不好意思直接追小红，于是乎他找了小明帮忙，想让小明帮他送礼物给小红。这样的关系如何用代码来实现呢？\n🛠 解决 没有代理的代码 首先来尝试写出，如果小刚直接追小红的代码。\nclassDiagram class 追求者{ +送洋娃娃🪆() +送鲜花💐() +送巧克力🍫() } class 被追求者{ -姓名: String } ","permalink":"http://rextechie.github.io/posts/design_patterns/proxy_pattern/","summary":"🚏 导论 代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。\n代理模式的应用场景\n远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 🚦 结构 UML类图 classDiagram class Client{ } class Subject{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +Request() } class RealSubject{ +Request() } class Proxy{ -realSubject: RealSubject +Request() } Client --\u0026gt; Subject Subject \u0026lt;|.. RealSubject Subject \u0026lt;|.. Proxy 代码实现 Subject类，定义了RealSubject和Proxy的公共接口，这样就在任何使用RealSubject的地方都可以使用Proxy\npublic class abstract Subject { public abstract void Request(); } RealSUbject类，定义Proxy所代表的真实实体\npublic class RealSubject extends Subject { @Override public void Request() { System.out.println(\u0026#34;真实的请求\u0026#34;); } } Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject相同的接口，这样代理就可以用来代替实体\npublic class Proxy extends Subject { private RealSubject realSubject; @Override public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } realSubject.","title":"Proxy_pattern"},{"content":"🚏 导论 装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。当现有目标功能不足的时候，需要增强时，可以考虑使用装饰模式。\n装饰模式把每个要装饰的代码放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。\n装饰器常在面向切面编程（AOP）中使用，比如日志、事务、权限等功能。\n🚦 结构 UML类图 classDiagram class Component{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +operation() } class ConcreteComponent{ +operation() } class Decorator{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; -component: Component +operation() } class ConcreteDecoratorA{ -addedState +operation() } class ConcreteDecoratorB{ +operation() -AddedBehavior() } Component \u0026lt;|-- ConcreteComponent Component \u0026lt;|-- Decorator Decorator o-- Component Decorator \u0026lt;|-- ConcreteDecoratorA Decorator \u0026lt;|-- ConcreteDecoratorB Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。\n装饰模式是利用setComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。\n基本代码 Component类\npublic interface Component { void operation(); } ConcreteComponent类\npublic class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\u0026#34;具体对象的操作\u0026#34;); } } Decorator类\npublic abstract class Decorator implements Component { protected Component component; public void setComponent(Component component) { this.component = component; } @Override public void operation() { if (component != null) { component.operation(); } } } ConcreteDecoratorA类\npublic class ConcreteDecoratorA extends Decorator { private String addedState; @Override public void operation() { super.operation(); addedState = \u0026#34;New State\u0026#34;; System.out.println(\u0026#34;具体装饰对象A的操作\u0026#34;); } } ConcreteDecoratorB类\npublic class ConcreteDecoratorB extends Decorator { @Override public void operation() { super.operation(); addedBehavior(); System.out.println(\u0026#34;具体装饰对象B的操作\u0026#34;); } private void addedBehavior() { System.out.println(\u0026#34;为具体装饰对象B增加额外的行为addedBehavior()\u0026#34;); } } 客户端代码\npublic class Client { public static void main(String[] args) { Component component = new ConcreteComponent(); Decorator decoratorA = new ConcreteDecoratorA(); Decorator decoratorB = new ConcreteDecoratorB(); decoratorA.setComponent(component); decoratorB.setComponent(decoratorA); decoratorA.operation(); decoratorB.operation(); } } 🎭 优缺点分析 😊 优点 有效地将类的核心职责和装饰功能区分开，而且可以去除相关类中重复的装饰逻辑。 🙁 缺点 会产生很多小对象，增加了系统的复杂性。 🎬 场景 现有一需求，要求写一个可以给人搭配不同服饰的系统，比如类似QQ、网络游戏或论坛都有的Avatar系统。\n🛠 解决 第一版代码 classDiagram class 人 { +穿大T恤() +穿垮裤() +穿破球鞋() +穿西装() +打领带() +穿皮鞋() +形象展示() } Person类的代码如下：\npublic class Person { /** * 姓名 */ private String name; public Person(String name) { this.name = name; } public void wearTShirts() { System.out.print(\u0026#34;大T恤 \u0026#34;); } public void wearBigTrouser() { System.out.print(\u0026#34;垮裤 \u0026#34;); } public void wearSneakers() { System.out.print(\u0026#34;破球鞋 \u0026#34;); } public void wearSuit() { System.out.print(\u0026#34;西装 \u0026#34;); } public void wearTie() { System.out.print(\u0026#34;领带 \u0026#34;); } public void wearLeatherShoes() { System.out.print(\u0026#34;皮鞋 \u0026#34;); } public void show() { System.out.print(\u0026#34;装扮的\u0026#34; + name); } } 客户端代码：\npublic class Client { public static void main(String[] args) { Person rex = new Person(\u0026#34;Rex\u0026#34;); System.out.print(\u0026#34;\\n第一种装扮：\u0026#34;); rex.wearTShirts(); rex.wearBigTrouser(); rex.wearSneakers(); rex.show(); System.out.print(\u0026#34;\\n第二种装扮：\u0026#34;); rex.wearSuit(); rex.wearTie(); rex.wearLeatherShoes(); rex.show(); } } 但是这样就违背了开闭原则，如果要增加一种装扮，就需要修改Person类，这样就不符合开闭原则。可以考虑将这些服饰都写成子类。\n第二版代码（用面向对象的思路构造） classDiagram class 人{ +形象展示() } class 服饰{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +形象展示 } class 大T恤{ +形象展示() } class 垮裤{ +形象展示() } class 破球鞋{ +形象展示() } class 西装{ +形象展示() } class 领带{ +形象展示() } class 皮鞋{ +形象展示() } 服饰 \u0026lt;|-- 大T恤 服饰 \u0026lt;|-- 垮裤 服饰 \u0026lt;|-- 破球鞋 服饰 \u0026lt;|-- 西装 服饰 \u0026lt;|-- 领带 服饰 \u0026lt;|-- 皮鞋 Person类\npublic class Person { /** * 姓名 */ private String name; public Person(String name) { this.name = name; } public void show() { System.out.print(\u0026#34;装扮的\u0026#34; + name); } } 服饰抽象类\npublic abstract class Finery { /** * 服饰抽象方法 */ public abstract void show(); } 各种服饰子类\npublic class BigTrouser extends Finery { /** * 垮裤展示 */ @Override public void show() { System.out.print(\u0026#34;垮裤 \u0026#34;); } } public class LeatherShoes extends Finery { /** * 皮鞋展示 */ @Override public void show() { System.out.print(\u0026#34;皮鞋 \u0026#34;); } } // ... 客户端类\npublic class Client { public static void main(String[] args) { Person rex = new Person(\u0026#34;Rex\u0026#34;); System.out.print(\u0026#34;\\n第一种装扮：\u0026#34;); Finery tShirts = new TShirts(); Finery bigTrouser = new BigTrouser(); Finery sneakers = new Sneakers(); tShirts.show(); bigTrouser.show(); sneakers.show(); rex.show(); System.out.print(\u0026#34;\\n第二种装扮：\u0026#34;); Finery suit = new Suit(); Finery tie = new Tie(); Finery leatherShoes = new LeatherShoes(); suit.show(); tie.show(); leatherShoes.show(); rex.show(); } } 虽然改写成了面向对象写法，实现了“服饰”与“人”类的分离，但是分离的有点过度了，这就好像一个人当众光着身子将衣服穿起来，应该是要在内部组装好再展示出来。\n第三版（用装饰模式改造） classDiagram class 人{ +形象展示() } class 服饰{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +形象展示() } class 大T恤{ +形象展示() } class 垮裤{ +形象展示() } class 破球鞋{ +形象展示() } class 西装{ +形象展示() } class 领带{ +形象展示() } class 皮鞋{ +形象展示() } 人 \u0026lt;|-- 服饰 服饰 \u0026lt;|-- 大T恤 服饰 \u0026lt;|-- 垮裤 服饰 \u0026lt;|-- 破球鞋 服饰 \u0026lt;|-- 西装 服饰 \u0026lt;|-- 领带 服饰 \u0026lt;|-- 皮鞋 \u0026ldquo;Person\u0026quot;类(ConcreteComponent)\npublic class Person { /** * 姓名 */ private String name; public Person() { } public Person(String name) { this.name = name; } public void show() { System.out.print(\u0026#34;装扮的\u0026#34; + name); } } 服饰类(Decorator)\npublic class Finery extends Person { /** * 被装饰者 */ protected Person component; /** * 装饰 * * @param component 被装饰者 */ public void decorate(Person component) { this.component = component; } /** * 展示 */ @Override public void show() { if (component != null) { component.show(); } } } 具体服饰类(ConcreteDecorator)\npublic class BigTrouser extends Finery { /** * 垮裤展示 */ @Override public void show() { System.out.print(\u0026#34;垮裤 \u0026#34;); super.show(); } } public class LeatherShoes extends Finery { /** * 皮鞋展示 */ @Override public void show() { System.out.print(\u0026#34;皮鞋 \u0026#34;); super.show(); } } //... 客户端类\npublic class Client { public static void main(String[] args) { Person rex = new Person(\u0026#34;Rex\u0026#34;); System.out.print(\u0026#34;\\n第一种装扮：\u0026#34;); TShirts tShirts = new TShirts(); BigTrouser bigTrouser = new BigTrouser(); Sneakers sneakers = new Sneakers(); sneakers.decorate(rex); bigTrouser.decorate(sneakers); tShirts.decorate(bigTrouser); tShirts.show(); System.out.print(\u0026#34;\\n第二种装扮：\u0026#34;); Finery suit = new Suit(); Finery tie = new Tie(); Finery leatherShoes = new LeatherShoes(); leatherShoes.decorate(rex); tie.decorate(leatherShoes); suit.decorate(tie); rex.show(); } } ","permalink":"http://rextechie.github.io/posts/design_patterns/decorator_pattern/","summary":"🚏 导论 装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。当现有目标功能不足的时候，需要增强时，可以考虑使用装饰模式。\n装饰模式把每个要装饰的代码放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。\n装饰器常在面向切面编程（AOP）中使用，比如日志、事务、权限等功能。\n🚦 结构 UML类图 classDiagram class Component{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +operation() } class ConcreteComponent{ +operation() } class Decorator{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; -component: Component +operation() } class ConcreteDecoratorA{ -addedState +operation() } class ConcreteDecoratorB{ +operation() -AddedBehavior() } Component \u0026lt;|-- ConcreteComponent Component \u0026lt;|-- Decorator Decorator o-- Component Decorator \u0026lt;|-- ConcreteDecoratorA Decorator \u0026lt;|-- ConcreteDecoratorB Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。\n装饰模式是利用setComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。\n基本代码 Component类\npublic interface Component { void operation(); } ConcreteComponent类\npublic class ConcreteComponent implements Component { @Override public void operation() { System.","title":"装饰模式（Decorator Pattern）"},{"content":"🚏 导论 里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。\n里氏替换原则是Barbara Liskov女士在1988年发表的，A behavioral notion of subtyping, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n由于有里氏替换原则，才使得开放-封闭成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。\n🎬 场景 场景一：🐒 动物世界 因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。\n","permalink":"http://rextechie.github.io/posts/design_patterns/liskov_substitution_principle/","summary":"🚏 导论 里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。\n里氏替换原则是Barbara Liskov女士在1988年发表的，A behavioral notion of subtyping, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n由于有里氏替换原则，才使得开放-封闭成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。\n🎬 场景 场景一：🐒 动物世界 因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。","title":"里氏替换原则(Liskov Substitution Principle)"},{"content":"🚏 导论 依赖倒转原则\nA. 高层模块不应该依赖低层模块。两个都应该依赖抽象。\nB. 抽象不应该依赖细节。细节应该依赖抽象。\n🎬 场景 场景一：📦 修电脑 当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（单一职责原则、开放-封闭原则）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。 与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。\n","permalink":"http://rextechie.github.io/posts/design_patterns/dependency_inversion_principle/","summary":"🚏 导论 依赖倒转原则\nA. 高层模块不应该依赖低层模块。两个都应该依赖抽象。\nB. 抽象不应该依赖细节。细节应该依赖抽象。\n🎬 场景 场景一：📦 修电脑 当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（单一职责原则、开放-封闭原则）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。 与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。","title":"依赖倒转原则(Dependency Inversion Principle)"},{"content":"🚏 导论 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）\n我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。\n具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\n开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n🎬 场景 场景一：🏢 公司管理 现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。\n","permalink":"http://rextechie.github.io/posts/design_patterns/open_closed_principle/","summary":"🚏 导论 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）\n我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。\n具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\n开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n🎬 场景 场景一：🏢 公司管理 现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。","title":"开放-封闭原则(Open Closed Principle)"},{"content":"🚏 导论 单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。\n🎬 场景 场景一：📱 手机 现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。\n当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。\n场景二：♦️ 俄罗斯方块 俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。\n这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。\n","permalink":"http://rextechie.github.io/posts/design_patterns/signle_responsibility_principle/","summary":"🚏 导论 单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。\n🎬 场景 场景一：📱 手机 现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。\n当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。\n场景二：♦️ 俄罗斯方块 俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。\n这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。","title":"单一职责原则(Single Responsibility Principle)"},{"content":"🚏 导论 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以用策略模式封装几乎任何类型的规则，只要分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这些变化的可能性。\n🧀 前置知识 🚦 结构 UML 类图 classDiagram class Context{ -strategy: Strategy +Context(strategy: Strategy) +contextInterface() } class Strategy{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +algorithmInterface() } class ConcreteStrategyA{ +algorithmInterface() } class ConcreteStrategyB{ +algorithmInterface() } class ConcreteStrategyC{ +algorithmInterface() } Context o-- Strategy Strategy \u0026lt;|-- ConcreteStrategyA Strategy \u0026lt;|-- ConcreteStrategyB Strategy \u0026lt;|-- ConcreteStrategyC 基本代码 Strategy类，定义所有支持的算法的公共接口。\npublic abstract class Strategy { /** * 算法方法 */ public abstract void algorithmInterface(); } ConcreteStrategy类，实现具体的算法。\nclass ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法A实现\u0026#34;); } } class ConcreteStrategyB extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法B实现\u0026#34;); } } class ConcreteStrategyC extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法C实现\u0026#34;); } } Context, 用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。\npublic class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void contextInterface() { strategy.algorithmInterface(); } } 客户端代码\npublic static void main(String[] args) { Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); } 🎭 优缺点分析 😊 优点 策略模式的Strategy层次为Context定义了一系列可重用的算法或行为。继承有助于提取这些算法的公共功能。 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 🙁 缺点 在基本的策略模式中，选择所用具体实现的职责有客户端对象承担，并转给策略模式的Context对象，其实并没有减轻客户端的负担。（可以考虑💭用策略模式+简单工厂模式，但即使是这种方式，也有不足之处，每次更改 算法都要修改Context中的switch代码，这个问题可以用反射来解决） 🎬 场景 现要做一个商场收银系统，营业员根据客户所购买商品的单价和数量，向客户收费。如下图所示：\n初步设计后，关键代码如下所示：\n// 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText()); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 但是如果要增加打折功能，就需要修改代码，在totalPrices后乘以折扣，商场活动结束再修改回去。 显然不够灵活。\n这时候可以考虑增加下拉选项，选择不同的折扣方式，如下图所示： 修改后的代码如下所示：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;打八折\u0026#34;, \u0026#34;打七折\u0026#34;, \u0026#34;打五折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { int selectedIndex = discountComboBox.getSelectedIndex(); double discount = 1; switch (selectedIndex) { case 1: discount = 0.8; break; case 2: discount = 0.7; break; case 3: discount = 0.5; break; default: discount = 1; break; } System.out.println(\u0026#34;选中的折扣：\u0026#34; + selectedIndex); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText()) * discount; // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), discountComboBox.getSelectedItem(), totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 这样修改后的代码虽然实现了功能，但是代码量增加，且不够灵活。每次增加新的折扣方式，都需要修改代码。\n🛠 解决 简单工厂模式 当折扣的业务变多时，频繁修改计算总价代码，不符合开闭原则。可以使用简单工厂模式，将计算总价的代码抽取出来，放到一个类中，根据不同的折扣方式，创建不同的类。\nclassDiagram class CashSuper{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +acceptCash(money: double): double } class CashNormal{ +acceptCash(money: double): double } class CashRebate{ +acceptCash(money: double): double } class CashReturn{ +acceptCash(money: double): double } class CashFactory{ +createCashAccept(type: String): CashSuper } CashSuper \u0026lt;|-- CashNormal CashSuper \u0026lt;|-- CashRebate CashSuper \u0026lt;|-- CashReturn CashFactory --\u0026gt; CashSuper 现金收费抽象类\npublic abstract class CashSuper{ /** * 现金收取超类的抽象方法 * @param money 原价 * @return 折后价 */ public abstract double acceptCash(double money); } 正常收费子类：\npublic class CashNormal extends CashSuper{ /** * 正常收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { return money; } } 打折收费子类：\npublic class CashRebate extends CashSuper{ private double moneyRebate = 1d; public CashRebate(String moneyRebate) { this.moneyRebate = Double.parseDouble(moneyRebate); } /** * 打折收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { return money * moneyRebate; } } 返利收费子类：\npublic class CashReturn extends CashSuper{ private double moneyCondition = 0.0d; private double moneyReturn = 0.0d; public CashReturn(String moneyCondition, String moneyReturn) { this.moneyCondition = Double.parseDouble(moneyCondition); this.moneyReturn = Double.parseDouble(moneyReturn); } /** * 返利收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { double result = money; if (money \u0026gt;= moneyCondition) { result = money - Math.floor(money / moneyCondition) * moneyReturn; } return result; } } 现金收费工厂类：\npublic class CashFactory { /** * 现金收取工厂 * @param type 收费类型 * @return CashSuper */ public static CashSuper createCashAccept(String type){ CashSuper cs = null; switch (type){ case \u0026#34;正常收费\u0026#34;: cs = new CashNormal(); break; case \u0026#34;满300返100\u0026#34;: cs = new CashReturn(\u0026#34;300\u0026#34;,\u0026#34;100\u0026#34;); break; case \u0026#34;打8折\u0026#34;: cs = new CashRebate(\u0026#34;0.8\u0026#34;); break; default: break; } return cs; } } 客户端主要部分：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { String cashType = (String) discountComboBox.getSelectedItem(); CashSuper cs = CashFactory.createCashAccept(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cs.acceptCash(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 简单工程虽然也能解决这个问题，这个模式知识解决对象创建问题，而且由于工厂本身包括了所有收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或拓展都要改动这个工厂，以致代码需要重新编译部署，不够灵活，所以它不是最好的办法。面对算法的时常变动，应该有更好的办法。\n策略模式 其实上面写的用简单工程模式实现的商场收银系统，已经是策略模式的一个简单应用了。在基于策略模式的代码改写上述程序。\nclassDiagram class CashContext{ -cashSuper: CashSuper +CashContext(type: String) +getResult(money: double): double } class CashSuper{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +acceptCash(money: double): double } class CashNormal{ +acceptCash(money: double): double } class CashRebate{ +acceptCash(money: double): double } class CashReturn{ +acceptCash(money: double): double } CashSuper \u0026lt;|-- CashNormal CashSuper \u0026lt;|-- CashRebate CashSuper \u0026lt;|-- CashReturn CashContext --\u0026gt; CashSuper CashContext类：\nppublic class CashContext { private CashSuper cs; public CashContext(CashSuper cs) { this.cs = cs; } public double getResult(double money) { return cs.acceptCash(money); } } 客户端主要部分：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { CashContext cc = null; String cashType = (String) discountComboBox.getSelectedItem(); switch (cashType) { case \u0026#34;满300返100\u0026#34;: cc = new CashContext(new CashReturn(\u0026#34;300\u0026#34;, \u0026#34;100\u0026#34;)); break; case \u0026#34;打8折\u0026#34;: cc = new CashContext(new CashRebate(\u0026#34;0.8\u0026#34;)); break; default: cc = new CashContext(new CashNormal()); break; } CashSuper cs = CashFactory.createCashAccept(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cc.getResult(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 但是这样还是回到了原来的问题，在客户端代码中，还是需要根据不同的折扣方式，创建不同的类，这样还是不够灵活。\n简单工厂 + 策略模式 可以尝试用简单工厂模式和策略模式结合，将创建对象的过程交给工厂，客户端只需要知道折扣方式即可。\n改造后的CashContext类：\npublic class CashContext { private CashSuper cs; public CashContext(String type) { switch (type){ case \u0026#34;正常收费\u0026#34;: this.cs = new CashNormal(); break; case \u0026#34;满300返100\u0026#34;: this.cs = new CashReturn(\u0026#34;300\u0026#34;, \u0026#34;100\u0026#34;); break; case \u0026#34;打8折\u0026#34;: this.cs = new CashRebate(\u0026#34;0.8\u0026#34;); break; default: break; } } public double getResult(double money) { return cs.acceptCash(money); } } 客户端代码\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { String cashType = (String) discountComboBox.getSelectedItem(); CashContext cc = new CashContext(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cc.getResult(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 客户端代码与简单工程的不同\n// 简单工厂 CashSuper cs = CashFactory.createCashAccept(cashType); // 简单工厂 + 策略模式 CashContext cc = new CashContext(cashType); 在简单工厂，客户端需要知道CashFactory和CashSuper，而在简单工厂 + 策略模式中，客户端只需要知道CashContext即可。耦合性更低了。使得具体的收费算法和客户端分离，可以相互独立地变化。\n","permalink":"http://rextechie.github.io/posts/design_patterns/strategy_pattern/","summary":"🚏 导论 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以用策略模式封装几乎任何类型的规则，只要分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这些变化的可能性。\n🧀 前置知识 🚦 结构 UML 类图 classDiagram class Context{ -strategy: Strategy +Context(strategy: Strategy) +contextInterface() } class Strategy{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +algorithmInterface() } class ConcreteStrategyA{ +algorithmInterface() } class ConcreteStrategyB{ +algorithmInterface() } class ConcreteStrategyC{ +algorithmInterface() } Context o-- Strategy Strategy \u0026lt;|-- ConcreteStrategyA Strategy \u0026lt;|-- ConcreteStrategyB Strategy \u0026lt;|-- ConcreteStrategyC 基本代码 Strategy类，定义所有支持的算法的公共接口。\npublic abstract class Strategy { /** * 算法方法 */ public abstract void algorithmInterface(); } ConcreteStrategy类，实现具体的算法。\nclass ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.","title":"策略模式（Strategy Pattern）"},{"content":"🚏 导论 抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。\n🧀 前置知识 工厂方法模式（Factory Method） 🚦 结构 classDiagram class AbstractFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createProductA() +createProductB() } class ConcreteFactory1{ +createProductA() +createProductB() } class ConcreteFactory2{ +createProductA() +createProductB() } class AbstractProductA{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductA1 class ProductA2 class AbstractProductB{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductB1 class ProductB2 class Client AbstractFactory \u0026lt;|.. ConcreteFactory1 AbstractFactory \u0026lt;|.. ConcreteFactory2 AbstractProductA \u0026lt;|.. ProductA1 AbstractProductA \u0026lt;|.. ProductA2 AbstractProductB \u0026lt;|.. ProductB1 AbstractProductB \u0026lt;|.. ProductB2 Client --\u0026gt; AbstractFactory Client --\u0026gt; AbstractProductA Client --\u0026gt; AbstractProductB AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。\nAbstractFactory是一个抽象工厂，它里面包含所有产品创建的抽象方法，而ConcreteFactory1和ConcreteFactory2就是两个具体的工厂了。\n通常在运行时在创建一个ConcreteFactory的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。\n🎭 优缺点分析 😊 优点 易于交换产品系列，由于具体工厂类在一个应用中只需要初始化的时候出现一次，这就使得改编一个应用的具体工厂变得非常简单。它只需要改变具体工厂即可使用不同的产品配置。 它让具体的创建实例过程与客户端分离，客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。 🙁 缺点 增加需求时，需要增加新的产品类，并且要调整工厂类，这增加了系统的复杂度。 每次使用都需要声明Factory，但是如果要更改产品系列，那么就需要更改所有的Factory声明。 🎬 场景 公司有一个给第三方企业做的电子商务网站，使用SQL Server数据库，已经都大致完成了。但是公司又接了另外一家公司类似的需求项目，但是这家公司想省钱，要用Access数据库。因此任务就变成了要将整个项目调整为用Access数据库。\n但是替换的过程中出现了很多问题。\nSQL Server的命名空间和Access数据库不同：SQL Server上用的是System.Data.SqlClient，而Access上用的是System.Data.OleDb。 数据库操作语法不同： Access插入数据必须用INSERT INTO，而SQL Server用INSERT（不能用INTO）。 SQL Server中的GetDate()函数在Access中是Now()。 SQL Server中有Substring()函数，而Access中是Mid()。 关键字不同 Access不能用password作为字段名，因为它是关键字，而SQL Server可以。要使用关键字需要用[]括起来。 \u0026hellip; 如果今后要换成其他数据库，那么这个项目就要重新调整。这样的设计显然是不合理的。\n🛠 解决 最初的代码 用户实体: User.java\npublic class User { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } SqlServerUser.java: 用于操作User表\npublic class SqlServerUser { public void insertUser(User user) { System.out.println(\u0026#34;在SQL Server中给User表增加一条记录\u0026#34;); } public User getUser(Integer id) { System.out.println(\u0026#34;在SQL Server中根据ID得到User表一条记录\u0026#34;); return null; } } Client.java: 客户端测试类\npublic class Client { public static void main(String[] args) { User user = new User(); SqlServerUser su = new SqlServerUser(); su.insertUser(user); su.getUser(1); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); } } 这里之所以不能换数据库，愿意在于SqlServerUser su = new SqlServerUser()使得su这个对象被框死在SQL Server上了。如果这里改成多态，那么在执行‘su.insertUser(user);’和‘su.getUser(1)’时就不需要考虑是Access还是Sql Server了。\n初步改造 考虑用工厂方法模式（工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类）进行改造。\nclassDiagram class DaoFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createUserDao() } class SqlServerDaoFactory{ +createUserDao() } class AccessDaoFactory{ +createUserDao() } class UserDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertUser(User user) +getUser(Integer id) } class SqlServerUserDao { +insertUser(User user) +getUser(Integer id) } class AccessUserDao { +insertUser(User user) +getUser(Integer id) } DaoFactory \u0026lt;|.. SqlServerDaoFactory DaoFactory \u0026lt;|.. AccessDaoFactory UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao UserDao.java: UserDao接口\npublic interface UserDao { /** * 插入用户 * @param user 用户 */ void insert(User user); /** * 获取用户 * @param id 用户id * @return 用户 */ User getUser(int id); } SqlServerUserDao.java: 用于访问SQL Server的User\npublic class SqlServerUserDao implements UserDao { /** * 插入用户 * * @param user 用户 */ @Override public void insert(User user) { System.out.println(\u0026#34;在SQL Server中给User表增加一条记录\u0026#34;); } /** * 获取用户 * * @param id 用户id * @return 用户 */ @Override public User getUser(int id) { System.out.println(\u0026#34;在SQL Server中根据id得到User表一条记录\u0026#34;); return null; } } AccessUserDao.java: 用于访问Access的User\npublic class AccessUserDao implements UserDao { /** * 插入用户 * * @param user 用户 */ @Override public void insert(User user) { System.out.println(\u0026#34;在Access中给User表增加一条记录\u0026#34;); } /** * 获取用户 * * @param id 用户id * @return 用户 */ @Override public User getUser(int id) { System.out.println(\u0026#34;在Access中根据id得到User表一条记录\u0026#34;); return null; } } DaoFactory.java: 定义一个创建访问User表对象的抽象的工厂接口\npublic interface DaoFactory { /** * 创建UserDao对象 * @return UserDao对象 */ UserDao createUserDao(); } SqlServerDaoFactory.java: 实现SqlFactory接口，实例化SqlServerFactory类\npublic class SqlServerDaoFactory implements DaoFactory { /** * 创建UserDao对象 * * @return UserDao对象 */ @Override public UserDao createUserDao() { return new SqlServerUserDao(); } } AccessDaoFactory.java: 实现SqlFactory接口，实例化AccessFactory类\npublic class AccessDaoFactory implements DaoFactory{ /** * 创建UserDao对象 * * @return UserDao对象 */ @Override public UserDao createUserDao() { return new AccessUserDao(); } } Client.java: 客户端测试类\npublic class Client { public static void main(String[] args) { User user = new User(); // DaoFactory factory = new SqlServerDaoFactory(); DaoFactory factory = new AccessDaoFactory(); UserDao userDao = factory.createUserDao(); userDao.insert(user); userDao.getUser(1); } } 这样，如果要换数据库，只需要修改DaoFactory factory = new AccessDaoFactory();即可，而对于UserDao接口的对象userDao事先根本不需要知道是访问哪个数据库。这就是所谓的业务逻辑与数据访问逻辑的解耦。\n接下来除了User表，还有Department表，架构就会变成这样：\nclassDiagram direction LR class DaoFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createUserDao() } class SqlServerDaoFactory{ +createUserDao() } class AccessDaoFactory{ +createUserDao() } class UserDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertUser(User user) +getUser(Integer id) } class SqlServerUserDao { +insertUser(User user) +getUser(Integer id) } class AccessUserDao { +insertUser(User user) +getUser(Integer id) } class DepartmentDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertDepartment(Department department) +getDepartment(Integer id) } class SqlServerDepartmentDao { +insertDepartment(Department department) +getDepartment(Integer id) } class AccessDepartmentDao { +insertDepartment(Department department) +getDepartment(Integer id) } DaoFactory \u0026lt;|.. SqlServerDaoFactory DaoFactory \u0026lt;|.. AccessDaoFactory UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao DepartmentDao \u0026lt;|.. SqlServerDepartmentDao DepartmentDao \u0026lt;|.. AccessDepartmentDao 增加DepartmentDao.java，用于客户端访问，解除与具体数据库访问的耦合\npublic interface DepartmentDao { /** * 插入部门 * @param department 部门 */ void insert(Department department); /** * 根据id查询部门 * @param id id * @return 部门 */ Department getDepartment(Integer id); } SqlServerDepartmentDao.java: 用于访问SQL Server的Department\npublic class SqlServerDepartmentDao implements DepartmentDao { /** * 插入部门 * * @param department 部门 */ @Override public void insert(Department department) { System.out.println(\u0026#34;在SQL Server中给Department表增加一条记录\u0026#34;); } /** * 根据id查询部门 * * @param id id * @return 部门 */ @Override public Department getDepartment(Integer id) { System.out.println(\u0026#34;在SQL Server中根据id得到Department表一条记录\u0026#34;); return null; } } AccessDepartmentDao.java: 用于访问Access的Department\npublic class AccessDepartmentDao implements DepartmentDao { /** * 插入部门 * * @param department 部门 */ @Override public void insert(Department department) { System.out.println(\u0026#34;在Access中给Department表增加一条记录\u0026#34;); } /** * 根据id查询部门 * * @param id id * @return 部门 */ @Override public Department getDepartment(Integer id) { System.out.println(\u0026#34;在Access中根据id得到Department表一条记录\u0026#34;); return null; } } 在DaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * @return DepartmentDao对象 */ DepartmentDao createDepartmentDao(); SqlServerDaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * * @return DepartmentDao对象 */ @Override public DepartmentDao createDepartmentDao() { return new SqlServerDepartmentDao(); } AccessDaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * * @return DepartmentDao对象 */ @Override public DepartmentDao createDepartmentDao() { return new AccessDepartmentDao(); } 最后Client.java\npublic class Client { public static void main(String[] args) { User user = new User(); DaoFactory factory = new SqlServerDaoFactory(); // DaoFactory factory = new AccessDaoFactory(); UserDao userDao = factory.createUserDao(); userDao.insert(user); userDao.getUser(1); DepartmentDao departmentDao = factory.createDepartmentDao(); departmentDao.insert(new Department()); departmentDao.getDepartment(1); } } 输出的结果为：\n在SQL Server中给User表增加一条记录 在SQL Server中根据id得到User表一条记录 在SQL Server中给Department表增加一条记录 在SQL Server中根据id得到Department表一条记录 这样整个架构已经演进为了抽象工厂模式。当只有一个类需要被工厂方法创建的时候，是工厂方法模式，而涉及多个产品系列的问题，这种工厂模式叫做抽象工厂模式（Abstract Factory Pattern）。\n用简单工厂模式改进抽象工厂 由于抽象工厂的缺点中提到，每次使用都需要声明Factory，但是如果要更改产品系列，那么就需要更改所有的Factory声明。这里可以用简单工厂模式改进。\n直接去除DaoFactory、SqlServerDaoFactory、AccessDaoFactory，改用DataAccess类。\nclassDiagram class UserDao{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class DepartmentDao{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class SqlServerUserDao class SqlServerDepartmentDao class AccessUserDao class AccessDepartmentDao class DataAccess{ -db : string +createUser() UserDao +createDepartment() DepartmentDao } UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao DepartmentDao \u0026lt;|.. SqlServerDepartmentDao DepartmentDao \u0026lt;|.. AccessDepartmentDao DataAccess ..\u0026gt; UserDao DataAccess ..\u0026gt; DepartmentDao DataAccess.java\npublic class DataAccess { private static final String DB = \u0026#34;SQLServer\u0026#34;; // private static final String DB = \u0026#34;Access\u0026#34;; /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; switch (DB){ case \u0026#34;SQLServer\u0026#34;: userDao = new SqlServerUserDao(); break; case \u0026#34;Access\u0026#34;: userDao = new AccessUserDao(); break; default: break; } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; switch (DB){ case \u0026#34;SQLServer\u0026#34;: departmentDao = new SqlServerDepartmentDao(); break; case \u0026#34;Access\u0026#34;: departmentDao = new AccessDepartmentDao(); break; default: break; } return departmentDao; } } Client.java 客户端代码\npublic class Client { public static void main(String[] args) { User user = new User(); Department department = new Department(); UserDao userDao = DataAccess.createUserDao(); userDao.insert(user); userDao.getUser(1); DepartmentDao departmentDao = DataAccess.createDepartmentDao(); departmentDao.insert(department); departmentDao.getDepartment(1); } } 这样的设计客户端代码可以不出现具体数据库名称，使得需要修改数据库时，只需要在DataAccess修改DB的内容就可以了。但是如果需要增加新的数据库支持，就还需要调整Access的switch结构，原来只需要增加一个工厂类就好了。\n用反射+抽象工厂的数据访问程序 为了解决既不修改switch代码结构，也不让客户端出现具体数据库名称。可以引入反射的思想，通过字符串实例化对应的类。 修改后如下所示\npublic class DataAccess { private static final String DB = \u0026#34;SqlServer\u0026#34;; private static final String packageName = \u0026#34;space.rexhub.designpatterns.creational.abstract_factory.dao.impl\u0026#34;; /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; String className = packageName + \u0026#34;.\u0026#34; + DB + \u0026#34;UserDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getDeclaredConstructor(); userDao = (UserDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; String className = \u0026#34;space.rexhub.designpatterns.creational.abstract_factory.dao.impl.\u0026#34; + DB + \u0026#34;DepartmentDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getConstructor(); departmentDao = (DepartmentDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return departmentDao; } } 这样，只需要修改DB的值，就可以实现不同数据库的切换，并且不需要修改switch结构。如果我们需要提供Oracle的支持，只需要创建OracleUserDao和OracleDepartmentDao类，然后修改DB的值即可。\n但还是可以挑出毛病，切换数据库还是需要在代码里进行修改，能否不修改代码就能切换数据库呢？\n用反射+配置文件实现数据访问程序 为了不修改数据库就能切换数据库，可以将数据库名称放在配置文件中，然后通过反射实例化对应的类。\n创建一个 database_config.properties文件，内容如下：\nDB = SqlServer DataAccess.java只需要从配置文件中获取DB就可以了\npublic class DataAccess { private static final String PACKAGE_NAME = \u0026#34;space.rexhub.design_patterns.creational.abstract_factory.dao.impl\u0026#34;; private static String DB; static{ Properties properties = new Properties(); try { properties.load(new FileInputStream(\u0026#34;space/rexhub/design_patterns/creational/abstract_factory/database_config.properties\u0026#34;)); DB = (String) properties.get(\u0026#34;DB\u0026#34;); } catch (IOException e) { DB = null; } } /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; String className = PACKAGE_NAME + \u0026#34;.\u0026#34; + DB + \u0026#34;UserDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getDeclaredConstructor(); userDao = (UserDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; String className = PACKAGE_NAME + \u0026#34;.\u0026#34; + DB + \u0026#34;DepartmentDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getConstructor(); departmentDao = (DepartmentDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return departmentDao; } } 这样这个数据库切换的问题就可以相对较完美的解决了，我们应用了反射+抽象工厂模式解决了数据库访问时的可维护、可扩展问题。\n","permalink":"http://rextechie.github.io/posts/design_patterns/abstract_factory_pattern/","summary":"🚏 导论 抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。\n🧀 前置知识 工厂方法模式（Factory Method） 🚦 结构 classDiagram class AbstractFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createProductA() +createProductB() } class ConcreteFactory1{ +createProductA() +createProductB() } class ConcreteFactory2{ +createProductA() +createProductB() } class AbstractProductA{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductA1 class ProductA2 class AbstractProductB{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductB1 class ProductB2 class Client AbstractFactory \u0026lt;|.. ConcreteFactory1 AbstractFactory \u0026lt;|.. ConcreteFactory2 AbstractProductA \u0026lt;|.. ProductA1 AbstractProductA \u0026lt;|.. ProductA2 AbstractProductB \u0026lt;|.. ProductB1 AbstractProductB \u0026lt;|.. ProductB2 Client --\u0026gt; AbstractFactory Client --\u0026gt; AbstractProductA Client --\u0026gt; AbstractProductB AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。","title":"抽象工厂模式（Abstract Factory）"},{"content":"基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ICLR 2023 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。\n研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。\n在MetaGPT中，对于每个角色制定了Agent的名字（name）、资料（profile）、目标（goal）和约束（constraints）。同时也初始化每个角色的特定的上下文（context）和技能（skill）。例如，产品经理可以使用网络搜索技能，而工程师可以执行代码。如下图2所示。所有Agent遵循ReAct风格。\n图2：一个展示MetaGPT软件开发生成过程的图表，强调其对SOPs的显著依赖。\n每个Agent监控环境（MetaGPT中的消息池）以发现重要的观察结果（如其他agent的消息），这些消息可以直接触发Agent的行为，也可以协助完成任务。\nAgent之间的工作流程（Workflow across Agents） 通过定义代理的角色和技能，可以建立起基本的工作流。在MetaGPT的工作中，遵循软件开发中的SOP，使得所有工作都能按顺序执行。\n具体来说，如之前图1所示，产品经理在获取用户需求后，进行全面的需求分析，制定PRD（Product requirement document），里面包含用户故事和需求池。之后将PRD传递给架构师，他会将需求转为系统设计，例如文件列表、数据结构以及接口定义等。一旦在系统设计中捕获，信息就会直接发送给项目经理以进行任务分配。工程师则继续执行指定的类和功能（如图2所示）。在之后的阶段，QA工程师制定测试用例确保代码质量。最后MetaGPT生成高质量的软件解决方案。详细的SOP工作流程如下图3所示。\n图3：MetaGPT软件开发生成过程。\n通信协议（Communication Protocol） 结构化通信接口（Structed Communication Interfaces） 如今大部分基于大语言模型的多智能体框架（CAMEL、NLSOM、CoELA、Generative Agents）都是使用无约束的自然语言作为通信接口。但是如果只用自然语言作为通信接口，会出现问题。如在电话游戏中，在几轮传递之后，原始的信息会发生扭曲。当用纯自然语言进行通信时，也会出现这种问题。因此需要每个角色制定一个结构化的通信接口，以确保信息的准确传递。如之前的图3所示，架构师Agent产生两个输出：系统接口设计和顺序流程图。与ChatDev不同，MetaGPT中的Agent通过文档和图输出，而不是对话。这些文档也都是包含必要信息的文档，防止出现不相关或丢失的内容。\n发布订阅机制（Publish-Subscribe Mechanism） 共享信息对于协作非常关键。比如：建筑师和工程师需要参考PRD。然而，如果每次都是以一对一的方式传达这些信息，可能会使通信变得复杂，效率低下。为了解决这个问题，一个可行的方案是将信息存储在一个全局信息池中。如图2左边所示，metagpt引入了共享消息池，允许所有agent直接访问和发布信息。这样就可以使得任何Agent可以直接从共享池中检索所需的信息，而不需要通过其他Agent传递。这样提高了通信效率。\n如果与每个Agent共享所有信息可能会导致信息过载。在执行任务期间，Agent通常喜欢接受与任务相关的信息，要避免因不相关的细节而分散注意力。如图2左边所示，MetaGPT引入了订阅机制，Agent不依赖对话，而是利用角色特定的兴趣来提取相关的信息。实际实现的时候，一个Agent只会在接收到所有其先决依赖项后才会激活操作。如之前图3所示，架构师主要关注产品经理提供的PRD，而QA工程师等角色的文档可能不太关心。\n迭代编程与执行反馈（Iterative programming with execution feedback） 在现实开发中，调试和优化非常重要。然而现有的方法通常缺少自我纠错的机制（self-correction mechanism），从而导致代码生成失败。之前也有一些人引入了不可执行代码审查（non-executable code review）和自我反思（self-reflection）:ChatDev、ReAct。然而它们在确保代码可执行性和运行时正确性上还是面临很大的挑战。\nMetaGPT引入了一种可执行的反馈机制(executable feedback)来迭代改进代码。更具体地说，如之前图2所示，要求工程师根据产品需求和设计编写代码。这使得工程师能够使用自己的历史执行记录和调试记忆来持续的改进代码。为了获得额外的信息，工程师编写并执行相应的单元测试用例，然后接收测试结果。如果测试结果满足条件，则启动其他的开发任务，否则工程师将进行调试。这种迭代过程将会持续进行，直到测试通过或达到最大迭代次数（3次）。\n实验结果 (Results) 实验环境（Experimental Setup） 数据集（Dataset） 作者使用了两个公开的benchmarks（HumanEval、MBPP）以及一个自己设计的软件开发的benchmark\nHumanEval: 出自openai，有164个手写编程任务，包括提示词（prompt）、标准答案（canonical_solution）、单元测试代码（test）、函数名称（entry_point）。 MBPP: 出自google search，有427个Python任务，这些任务涵盖核心概念和标准库代码，并包括要求（text）、代码（code）、单元测试集（test_list）等信息。 SoftwareDev：作者自己设计的Benchmark，包含70个软件开发任务的代表性示例，每个示例都有自己的任务提示。如下表所示。这些任务有游戏、算法、数据可视化等等。Software专注于工程方面。 评估指标（Evaluation Metrics） pass@k: 对于HumanEval和MBPP，作者使用了openai提出的无偏估计的pass@k指标，$\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。 对于SoftwareDev，优先考虑实际使用，并通过人工评估（A、E）或统计分析（B、C、D）来评估性能。 A：可执行性，该指标对代码进行评分，从1（失败/无法运行）～4（完美）。1-非功能性、2-可运行但不完美、3-可运行但不完美、4-完美。 B：成本，包括运行时间、token使用量以及费用。 C：代码统计，包括代码文件数、每个文件代码行数以及总代码数 D：生产率，定义为token使用量/代码行数，即每行代码消耗的令牌。 E：人工修订成本，指手动修正的次数，解决诸如包导入错误、类名不正确或不完整的引用路径等问题。通常，每次修正涉及最多3行代码。 基线（Baselines） 对于HumanEval和MBPP，作者使用了一些基线模型：\nAlphaCode InCoder CodeGeeX CodeGen CodeX CodeT PaLM GPT-4 其中Dong等人已经提供了一些结果（如InCoder、CodeGeeX）。在HumanEval和MBPP中，作者稍微修改了下提示词，以适应MetaGPT的输入格式。\n对于SoftwareDev上的基线\nAutoGPT LangChain with Python Read-Eval-Print Loop(REPL) tool AgentVerse ChatDev 主要结果（Main Result） 上图表明MetaGPT在HumanEval和MBPP基准测试中达到了SOAT。\nMetaGPT在SoftwareDev上的实验结果几乎均好于ChatDev。这些结果均凸显出SOP在多个Agent直接协作中的好处。\n在上图中，通过可视化示例展示了MetaGPT在SoftwareDev上的生成结果。\n能力分析（Capability Analysis） 如上表所示，MetaGPT包含多种能力，可以有效地处理复杂且专业的开发业务，结合SOPs可以显著改进代码生成。\n消融实验（Ablation Study） 角色的有效性 为了了解不同角色对最终结果的影响，作者对角色部分做了消融实验。结果如上表所示，虽然更多的角色会稍微增加费用，但整体性能显著提高，展示了各种角色的有效性。\n可执行的反馈机制的有效性 在一开始的主要结果展示的图中，见可执行反馈添加到MetaGPT，pass@1显著提高。此外，表1中显示出反馈机制提高了可行性并降低了人工修改成本。这些结果说明了反馈机制如何能够生成更高质量的代码。\n参考文献 (References) Austin J, Odena A, Nye M, et al. Program synthesis with large language models[J]. arXiv preprint arXiv:2108.07732, 2021. Yao S, Zhao J, Yu D, et al. React: Synergizing reasoning and acting in language models[J]. arXiv preprint arXiv:2210.03629, 2022. Zhao X, Li M, Weber C, et al. Chat with the environment: Interactive multimodal perception using large language models[C]//2023 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2023: 3590-3596. 备注 (Notes) 这篇论文本身对方法的描述不足够详细，在实现Agent上有很多小技巧，需要读源码才能体会到\n优点与创新点 (Strengths) 将SOPs与Agent结合，更加模仿了真实世界的软件开发过程。 设计了共享消息池和订阅机制，提高了通信效率。 引入了可执行的反馈机制，提高了代码生成的质量。 局限性与不足 (Limitations) 实际使用后，项目的可执行性还是有待提高。 SoftwareDev的实验评价指标略为主观 我的思考 (Personal Thoughts) 本文与我研究的相关性：MetaGPT可以实现一些复杂任务的开发，在全栈项目开发中有共同之处。对于SOPs的思想、共享消息池和订阅机制以及可执行的反馈机制，可以考虑在项目中使用。 是否有可以改进的地方：评价指标还有待改进。 后续可能的研究方向：MetaGPT实现的任务较为广泛，考虑缩小范围，只生成Web开发相关的代码。 ","permalink":"http://rextechie.github.io/posts/paper_note/metagpt/","summary":"基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ICLR 2023 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。\n研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。","title":"MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework"},{"content":"基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。\n研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。\n功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。\nKual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n \u0026gt; k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c \u0026lt;= n），并计算无偏估计量。其中 $\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。\n直接计算这个估计量会导致得到非常大的数字并且数值不稳定。在下图3中包含了数值稳定性的numpy实现，它简化了表达式并逐项评估乘积项。有人也许会尝试用1-(1-p_hat)^k来估pass@k, 其中p_hat是pass@1的经验估计，但是作者已经证明了这个方式是有偏差的。 上图的推导证明如下所示 例子🌰： 给定n为10，k为2\nid n c k pass@k 0 10 10 2 1 1 10 9 2 1 2 10 8 2 0.98 4 10 7 2 0.93 5 10 6 2 0.86 6 10 5 2 0.78 7 10 4 2 0.67 8 10 3 2 0.53 9 10 2 2 0.38 10 10 1 2 0.2 11 10 0 2 0 手写部分计算过程如下所示 HumanEval数据集(HumanEval: Hand-Wirtten Evaluation Set) 数据集名称：HumanEval 数据集规模：164个手写编程问题 数据集结构：函数签名、问题描述、主体和单元测试（每个问题平均有7.7个单元测试i）。 数据集来源：数据集必须是手写的，因为模型本身已经从Github训练了，Github中已经包含了解决方案。 数据集地址：GitHub 执行生成函数的沙箱(Sandbox for Executing Generated Functions) 由于公开的代码具有未知意图，因此在执行生成的代码时，需要一个沙箱环境，以防止恶意代码的执行。开发沙箱环境的目标是防止这些程序修改、在主机或网络上获得持久性、访问敏感资源或从主机或网络中窃取数据。由于OpenAI的训练是在K8s集群和云服务上，因此沙箱也一样。\n作者选择了gVisor容器作为主要主机保护组件（Unsupervised Translation of Programming Languages）。不使用Docker，是因为Docker容器运行时可以与容器共享主机资源，恶意容器可能会危及主机。gVisor通过模拟其资源在主机和容器之间引入一个安全边界来保护主机。网络相邻的主机和服务受基于eBPF防火墙规则的保护，这些规则阻止了入站和出站的链接（实验所需连接以外的连接）\n代码微调 (Code Fine-Tuning) 微调GPT(12B参数) -\u0026gt; Codex\n数据收集 (Data Collection) 来源：Github上54亿个公共仓库 规模：178GB的Python文件，每个Python文件大小不到1MB。过滤了之后剩下159GB的数据。 数据清洗：过滤掉了可能是自动生成、平均行数大于100、最大行数大于1000或者包含一小部分字母数字字符的文件。 方法 (Method) 学习率：与GPT相同 学习率预热（防止模型开始训练时不稳定，让开始训练的几个step学习率小一些）：175步 学习率调整：余弦学习率衰减 优化器：Adam优化器，β1 = 0.9, β2 = 0.95, €= 10−8，权重衰减系数为0.1 词法分析器：代码词法分析器（code lexer），由于Github上的代码和自然语言在数据分布上不一样，因此词法分析器也要不一样。造成模型低效的的最大的原因是对里面whitespace的编码，因此作者添加了一组token来表示不同长度的whitespace。 评估 使用pass@k指标 评估数据：将每个HumanEval问题整理成Prompt，包含元注解（header）、函数声明（signature）、文档注释（docstring）。如下图2所示。 停止采样：停止采样符（[\u0026rsquo;\\nclass\u0026rsquo;, \u0026lsquo;\\ndef\u0026rsquo;, \u0026lsquo;\\n#\u0026rsquo;, \u0026lsquo;\\nif\u0026rsquo;, \u0026lsquo;\\nprint\u0026rsquo;]中的一个，否则模型会生成额外的函数或语句） 采样策略：采用核采样（Top-p），并设置top-p=0.96 实验结果 (Results) 如Kaplan等人Scaling Laws for Neural Language Models指出的，语言模型测试损失在模型大小上遵循幂律。代码微调后的测试损失也遵循类似的形式，$\\left( \\frac{N}{5.92 \\times 10^7} \\right)^{-0.13}$，其中N是模型中非embedding参数的参数数量。\n探究不同的k值与temperature的关系。图中可以得出temperature越高，k值越高，则结果越好，因为样本具有更高的多样性，而度量reward只关注是否生成正确解。\n对于679M参数的模型，pass@1的最佳temperature是0.2， pass@100的最佳temperature是0.8。由实验结果可知，他们的pass@k随参数量的变化非常的平滑。\nPass@k是评估k个样本中有多少个通过了单元测试，为了更加接近真实值，引入了n和c，只要n足够大，得到的pass@k就会更接近于真实值。但在实际推理过程的选择中，我们也必须从生成的样本中选择一个样本。根据上图可知选择具有最高平均token对数概率比随机选择要好，但是随机选择比依据对数概率总和来选要稍差。这个图表说明了选择样本的启发式算法的重要性。对于Docstring backtranslation后文会提到，TODO。\n上图是计算Codex-12B（temperatire = 0.8） HumanEval样本与其参考解决方案的BLEU分数。纵坐标是概率密度，横坐标是BLEU分数。显然，BLEU分数的提高可能并不代表在实际中运行正确。\n相关模型和系统的对比分析 (Comparative Analysis of Related Models and Systems) 类似Codex，GPT-Neo、GPT-J基于The Pile进行训练。这个数据集来自各种来源以及8%的Github代码。作者使用HumanEval数据集对GPT-Neo和GPT-J进行了评估。\n对于GPT-Neo，pass@1达到了6.4%，pass@100达到了21.3%，而同等规模的GPT模型在这两个指标上都接近于0%。GPT-Neo-2.7B相当于Codex-85M（参数量少了30倍）。temperature为0.2、0.4和0.8时结果最好。 对于GPT-J-6B，pass@1达到了11.7%，pass@100达到了27.7%。相当于Codex-300M（参数量少了20倍）。temperature为0.2和0.8时结果最好。\n与当时最好的代码补全模型Tabine做了比较，Tabine在pass@1(T = 0.4)为2.6%，pass@100(T = 0.8)为7.6%。相当于Codex-12M。\nAPPS数据集上的结果（Results on the APPS Dataset） APPS(Hendrycks2021年提出, Pre-training of deep bidirectional transformers for language understanding)是一个用于评估代码生成模型的数据集。这个数据集包含5000个训练样本和5000个测试样本，都是关于代码问题，每个都包含单元测试。对于训练数据，包含正确的解决方案。\n与HumanEval不同，APPS数据测试类似OJ判题，从sdin和sdout读取输入输出。\nAPPS论文中测试了找到问题正确解决方案的比例（strict accuracy）和单元测试的通过率（即使答案不对，但只要通过测试）。后一个的度量是为了减少方差（因为第一个准确率很低），因此在测试时要尽量避免strict accuracy。\n在程序竞赛和APPS数据上，会给出三个输入输出用例。作者从模型中采样1000个解决方案，将通过这3个单元测试的解决方案筛选出来。最后计算这个筛选后的样本的pass@k。 考虑算法效率，在算法竞赛中超时是不能被接受的.但是对于Codex，作者评估中使用了3秒的超时时间。 由于Codex没有在APPS上进行指令微调，因此在提示词中添加了input/output示例。在表中表示为\u0026quot;1-shot\u0026quot;。实验结果表明用3个input/output测试过滤出来的样本，再去评估pass@k，效果更好。\n有监督微调 (Supervised Fine-Tuning) 有些从Github上找到的代码是包含类的实现、配置文件、脚本、甚至用来存储数据，这些与生成代码无关。作者假定这些错误匹配的代码会影响HumanEval的性能。作者分别收集了两类数据，一类是来自编程竞赛网站（和我一开始对于做代码生成的想法一摸一样，不过看来三年前就已经有人在做了🤔。。。），一类是持续集成仓库。用这些数据来训练出来的模型，作者称之为Codex-S。\n编程竞赛中的问题（Problems from Competitive Programming） OJ判题大多通过隐藏的单元测试来自动判断提交的功能正确性，这些单元测试通常有优秀的测试覆盖率，是经过了精心设计的。作者从多个流行的编程竞赛和面试网站手机了相关的问题描述、函数声明以及解决方案，把他们整理成类似HumanEval的格式，使用问题描述作为docstring。由于网站的单元测试是不公开的，作者依据问题的描述创建单元测试，或者通过提交错误解决方案提取了额外的测试用例。总共，作者收集了10000个问题。（🤡这方面的工作已经比较成熟了，感觉不好从这方面继续做研究了。）\n持续集成中的问题（Problems from Continuous Integration） 对于使用了持续集成（CI）相关的项目，使用python中sys.setprofile可以记录函数调用的输入和输出，这些数据天然的可以作为单元测试。作者考虑使用GitHub仓库，其中使用Travis和Tox作为它们的持续集成（CI）框架，因为它们是最受欢迎的CI工具之一。作者最终从数百万个问题中收集了40000个问题，因为不是所有的问题都接受输入并返回输出的。\n过滤问题（Filtering Problems） 为了控制模型的训练数据质量，作者使用Codex-12B对每一个任务生成100个样本，如果没有一个样本通过测试，则说明这个问题的描述是不清晰的，作者会将这个问题过滤掉。\n方法 (Method) 用这些最后的训练数据对Codex进行有监督微调得到Codex-S。作者训练主要是最小化参考解决方案的负对数似然。他们使用了训练Codex学习率的1/10的学习率来微调Codex-S，但学习率计划是一样的，训练直到验证集损失达到平稳。\n实验结果 (Results) 和Codex一样，他们首先计算pass@k的最佳temperature（1 \u0026lt;= k \u0026lt;= 100）。作者发现对于k \u0026gt; 1，Codex-S更喜欢略高的temperature，这可能反映了Codex-S的分布比Codex更狭窄。作者对于pass@1使用temperature=0, pass@100使用temperature=1。\n随后作者比较了Codex-S和Codex在pass@1和pass@100。实验结果表明，Codex-S在pass@1 平均比Codex高出6.5%，在pass@100上平均高出15.1%。\n作者同时还绘制了Codex-S-12B的不同样本选择启发式算法在Codex-S-12B上的性能与Codex-12B上的相同启发式算法进行比较。当按平均对数概率从1到100个样本进行排名时，平均比随机高11.6，这比Codex高出2%。\ndocstring生成 (Docstring Generation) 用docstring生成代码是可能的（合理的），因为代码通常紧跟在docstring之后，但是通过代码生成docstring是困难的。因此作者又开发了一个编写docstring的模型，可以描述生成代码的意图。使用前一节的训练问题描述，可以简单的创建一个训练数据集用于依据代码生成描述。\n具体来说，对于每一个训练问题，作者集成了训练样本的函数声明、参考解决方案和docstring。和之前一样，他们训练docstring生成模型（Codex-D）最小化负对数似然。\n对于生成代码，可以在HumanEval上测量pass@k作为基准测试，其中正确性由单元测试来定义。然而，没有类似的方法可以自动评估docstring样本.因此，他们通过手动来评估这些样本，如果文档字符串独特且准确的描述了代码，则认为是正确的。由于工作量大，作者只对每个问题生成的10个样本进行了评估，总共1640个问题，用temperature=0.8的Codex-D-12B。当模型简单的将代码体里的代码复制到docstring中时，作者认为这是错误的。最常见的错误是遗漏了重要的细节（如：结果保留两位小数）或者过度的要求函数名但是函数体的内容与函数名无关。\n实验结果表明，Codex-D的通过率较低，但是与相同temperature下的Codex-S相当。由于自然语言语法没有代码语法严格，所以生成的文档可能更宽容。docstring的质量相对较低，因为程序员🧑‍💻不会花很多时间来写docstring。\n最后，使用docstring模型，又有了一种从k个样本中选出一个样本的方法。不同与之前用最佳平均对数概率选择样本，可以最大化back-translation的P（GT docstring | 生成的样本），其中P是由Codex-D得出的。然而，如下图所示，通过back-translation进行排序的表现不如平均对数概率排序，尽管他优于随机排序。\n局限性与不足 (Limitations) Codex在训练上并不高效：作者认为没必要用Github上这么多的代码，实际上一个完成了学习的科班学生，预计能解决更大一部分的问题（比起Codex-12B）。 Codex可能会出现语法错误或未定义的代码，并且调用未定义或不在定义域内的函数、变量和属性。此外Codex在解析越来越长、更高层次或系统级的要求的时候会比较困难。为了具体说明这个问题，作者创建了一个由13个基本构建快组成的合成数据集。比如“将字符串转换为小写”或“移除每个字符串中第三个元素”（附录C里有详细的内容）。作者发现随着构建块链长度的增加，Codex的性能会呈指数下降。 和其他模态中的文本条件生成模型很难将属性绑定到对象上一样，Codex在将操作绑定到对象上也会出错，尤其是文档涉及的操作和变量很大的时候。如下面代码所示，Codex-12B并没有减少w变量，也没有返回四个变量的乘积。 def do_work(x, y, z, w): \u0026#34;\u0026#34;\u0026#34; Add 3 to y, then subtract 4 from both x and w. Return the product of the four numbers. \u0026#34;\u0026#34;\u0026#34; t=y+3 u=x-4 v=z*w return v 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n提出了一个评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 作者提出了Codex，通过对GPT-3进行微调，使其在HumanEval数据集上的性能得到了进一步提升。 作者提出了Codex-S，通过有监督微调Codex，使其在HumanEval数据集上的性能得到了进一步提升。 作者提出了Codex-D，通过训练docstring生成模型，使其在HumanEval数据集上的性能得到了进一步提升。 参考文献 (References) Kulal, Sumith, et al. \u0026ldquo;Spoc: Search-based pseudocode to code.\u0026rdquo; Advances in Neural Information Processing Systems 32 (2019). Hendrycks, Dan, et al. \u0026ldquo;Measuring coding challenge competence with apps.\u0026rdquo; arXiv preprint arXiv:2105.09938 (2021). 备注 (Notes) 论文提到一个现象（Introduction），12B的Codex可以解决28.8%的问题，而300M的Codex只能解决13.2的问题。这是为什么？ 论文提到了启发式（Heuristic），指的是什么 优化后的pass@k有什么含义。 这篇文章的Related work写了这个领域的发展，最早2011年就有人开始研究代码生成。这部分内容值得深入探索。 我的思考 (Personal Thoughts) 本文与我研究的相关性：提出了一个评估大型语言模型生成代码能力的方法，对于代码生成的研究有一定的参考价值。 是否有可以改进的地方：数据集的数量已经足够，但是数据集的质量可能还有待提高。作者提到了Codex在解析越来越长、更高层次或系统级的要求的时候会比较困难，这个问题也值得进一步研究。 后续可能的研究方向：研究更多相关评估大语言模型生成代码能力的数据集，如MBPP、APPS等数据集。 ","permalink":"http://rextechie.github.io/posts/paper_note/human_eval/","summary":"基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。\n研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。\n功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。\nKual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n \u0026gt; k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c \u0026lt;= n），并计算无偏估计量。其中 $\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。","title":"Evaluating Large Language Models Trained on Code"},{"content":"关于我 🎓 🎯 软件工程研究生在读 🔬 研究方向：基于大语言模型的代码生成 💻 后端开发工程师 🌱 持续学习，保持热情 研究领域 🚀 大语言模型在软件工程中的应用 智能代码生成与程序合成 代码理解与转换 技术栈 💪 语言：Java, Python, JavaScript\u0026hellip; 框架：Spring Boot, Spring Cloud, MyBatis\u0026hellip; 数据库：MySQL, Redis, MongoDB, Elasticsearch\u0026hellip; AI/ML：Neural Network, Transformers\u0026hellip; 项目经历 📚 🤖 基于LLM的代码生成系统 🌟 分布式微服务架构设计与实现 📊 企业级数据分析平台 生活爱好 ⭐ 🏸 羽毛球爱好者 🏃 跑步健身 📚 阅读：技术书籍 GitHub 统计 📊 联系我 📫 Email: rexhub@163.com Blog: 个人博客 ","permalink":"http://rextechie.github.io/about/","summary":"关于我 🎓 🎯 软件工程研究生在读 🔬 研究方向：基于大语言模型的代码生成 💻 后端开发工程师 🌱 持续学习，保持热情 研究领域 🚀 大语言模型在软件工程中的应用 智能代码生成与程序合成 代码理解与转换 技术栈 💪 语言：Java, Python, JavaScript\u0026hellip; 框架：Spring Boot, Spring Cloud, MyBatis\u0026hellip; 数据库：MySQL, Redis, MongoDB, Elasticsearch\u0026hellip; AI/ML：Neural Network, Transformers\u0026hellip; 项目经历 📚 🤖 基于LLM的代码生成系统 🌟 分布式微服务架构设计与实现 📊 企业级数据分析平台 生活爱好 ⭐ 🏸 羽毛球爱好者 🏃 跑步健身 📚 阅读：技术书籍 GitHub 统计 📊 联系我 📫 Email: rexhub@163.com Blog: 个人博客 ","title":"About"}]