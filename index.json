[{"content":"🚏导论 代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。\n🔍索引 代码生成相关模型 MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 代码生成评估指标 Evaluating Large Language Models Trained on Code ","permalink":"http://rextechie.github.io/posts/paper_note/code_generate/","summary":"\u003ch2 id=\"导论\"\u003e🚏导论\u003c/h2\u003e\n\u003cp\u003e代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。\u003c/p\u003e\n\u003ch2 id=\"索引\"\u003e🔍索引\u003c/h2\u003e\n\u003ch3 id=\"代码生成相关模型\"\u003e代码生成相关模型\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../metagpt/\"\u003eMetaGPT: Meta Programming for A Multi-Agent Collaborative Framework\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"代码生成评估指标\"\u003e代码生成评估指标\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../human_eval\"\u003eEvaluating Large Language Models Trained on Code\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"代码生成相关论文索引"},{"content":"🚏 导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。\n在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。\n💻 代码 Java代码实现\n🔍 索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 依赖倒置原则(Dependency Inversion Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)\n抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)\n适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)\n观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern) ","permalink":"http://rextechie.github.io/posts/design_patterns/design_patterns/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cp\u003e设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。\u003c/p\u003e\n\u003cp\u003e在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。\u003c/p\u003e\n\u003ch2 id=\"-代码\"\u003e💻 代码\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/RexTechie/design_patterns\"\u003eJava代码实现\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"-索引\"\u003e🔍 索引\u003c/h2\u003e\n\u003ch3 id=\"设计模式的七大原则\"\u003e设计模式的七大原则\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../signle_responsibility_principle\"\u003e单一职责原则(Single Responsibility Principle)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../open_closed_principle\"\u003e开放-封闭原则(Open Closed Principle)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../dependency_inversion_principle\"\u003e依赖倒置原则(Dependency Inversion Principle)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../liskov_substitution_principle\"\u003e里氏替换原则(Liskov Substitution Principle)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e接口隔离原则(Interface Segregation Principle)\u003c/li\u003e\n\u003cli\u003e迪米特法则(Law of Demeter)\u003c/li\u003e\n\u003cli\u003e合成复用原则(Composite Reuse Principle)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"设计模式的三大类\"\u003e设计模式的三大类\u003c/h3\u003e\n\u003cp\u003e创建性(Creational Pattern)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../abstract_factory/\"\u003e抽象工厂模式(Abstract Factory Pattern)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e建造者模式(Builder Pattern)\u003c/li\u003e\n\u003cli\u003e工厂方法模式(Factory Method Pattern)\u003c/li\u003e\n\u003cli\u003e原型模式(Prototype Pattern)\u003c/li\u003e\n\u003cli\u003e单例模式(Singleton Pattern)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e结构性(Structural Pattern)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e适配器模式(Adapter Pattern)\u003c/li\u003e\n\u003cli\u003e桥接模式(Bridge Pattern)\u003c/li\u003e\n\u003cli\u003e组合模式(Composite Pattern)\u003c/li\u003e\n\u003cli\u003e装饰模式(Decorator Pattern)\u003c/li\u003e\n\u003cli\u003e外观模式(Facade Pattern)\u003c/li\u003e\n\u003cli\u003e享元模式(Flyweight Pattern)\u003c/li\u003e\n\u003cli\u003e代理模式(Proxy Pattern)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e行为型(Behavioral Pattern)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e观察者模式(Observer Pattern)\u003c/li\u003e\n\u003cli\u003e模板模式(Template Pattern)\u003c/li\u003e\n\u003cli\u003e命令模式(Command Pattern)\u003c/li\u003e\n\u003cli\u003e状态模式(State Pattern)\u003c/li\u003e\n\u003cli\u003e职责链模式(Chain of Responsibility Pattern)\u003c/li\u003e\n\u003cli\u003e解释器模式(Interpreter Pattern)\u003c/li\u003e\n\u003cli\u003e中介者模式(Mediator Pattern)\u003c/li\u003e\n\u003cli\u003e访问者模式(Visitor Pattern)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../strategy_pattern/\"\u003e策略模式(Strategy Pattern)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e备忘录模式(Memento Pattern)\u003c/li\u003e\n\u003cli\u003e迭代器模式(Iterator Pattern)\u003c/li\u003e\n\u003c/ul\u003e","title":"设计模式"},{"content":"🚏 导论 里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。\n里氏替换原则是Barbara Liskov女士在1988年发表的，A behavioral notion of subtyping, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。\n由于有里氏替换原则，才使得开放-封闭成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。\n🎬 场景 场景一：🐒 动物世界 因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。\n","permalink":"http://rextechie.github.io/posts/design_patterns/liskov_substitution_principle/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e里氏替换原则是Barbara Liskov女士在1988年发表的，\u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/197320.197383\"\u003eA behavioral notion of subtyping\u003c/a\u003e, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。\u003c/p\u003e\n\u003cp\u003e由于有里氏替换原则，才使得\u003ca href=\"../open_closed_principle\"\u003e开放-封闭\u003c/a\u003e成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-场景\"\u003e🎬 场景\u003c/h2\u003e\n\u003ch3 id=\"场景一-动物世界\"\u003e场景一：🐒 动物世界\u003c/h3\u003e\n\u003cp\u003e因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。\u003c/p\u003e","title":"里氏替换原则(Liskov Substitution Principle)"},{"content":"🚏 导论 依赖倒转原则\nA. 高层模块不应该依赖低层模块。两个都应该依赖抽象。\nB. 抽象不应该依赖细节。细节应该依赖抽象。\n🎬 场景 场景一：📦 修电脑 当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（单一职责原则、开放-封闭原则）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。 与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。\n","permalink":"http://rextechie.github.io/posts/design_patterns/dependency_inversion_principle/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e依赖倒转原则\u003c/p\u003e\n\u003cp\u003eA. 高层模块不应该依赖低层模块。两个都应该依赖抽象。\u003c/p\u003e\n\u003cp\u003eB. 抽象不应该依赖细节。细节应该依赖抽象。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-场景\"\u003e🎬 场景\u003c/h2\u003e\n\u003ch3 id=\"场景一-修电脑\"\u003e场景一：📦 修电脑\u003c/h3\u003e\n\u003cp\u003e当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（\u003ca href=\"../signle_responsibility_principle\"\u003e单一职责原则\u003c/a\u003e、\u003ca href=\"../open_closed_principle\"\u003e开放-封闭原则\u003c/a\u003e）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。\n与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。\u003c/p\u003e","title":"依赖倒转原则(Dependency Inversion Principle)"},{"content":"🚏 导论 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\n对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）\n我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。\n具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\n开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\n🎬 场景 场景一：🏢 公司管理 现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。\n","permalink":"http://rextechie.github.io/posts/design_patterns/open_closed_principle/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）\u003c/p\u003e\n\u003cp\u003e我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。\u003c/p\u003e\n\u003cp\u003e具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。\u003c/p\u003e\n\u003cp\u003e开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-场景\"\u003e🎬 场景\u003c/h2\u003e\n\u003ch3 id=\"场景一-公司管理\"\u003e场景一：🏢 公司管理\u003c/h3\u003e\n\u003cp\u003e现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。\u003c/p\u003e","title":"开放-封闭原则(Open Closed Principle)"},{"content":"🚏 导论 单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\n软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。\n🎬 场景 场景一：📱 手机 现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。\n当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。\n场景二：♦️ 俄罗斯方块 俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。\n这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。\n","permalink":"http://rextechie.github.io/posts/design_patterns/signle_responsibility_principle/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。\u003c/p\u003e\n\u003cp\u003e软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-场景\"\u003e🎬 场景\u003c/h2\u003e\n\u003ch3 id=\"场景一-手机\"\u003e场景一：📱 手机\u003c/h3\u003e\n\u003cp\u003e现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。\u003c/p\u003e\n\u003cp\u003e当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。\u003c/p\u003e\n\u003ch3 id=\"场景二-俄罗斯方块\"\u003e场景二：♦️ 俄罗斯方块\u003c/h3\u003e\n\u003cp\u003e俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。\u003c/p\u003e\n\u003cp\u003e这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。\u003c/p\u003e","title":"单一职责原则(Single Responsibility Principle)"},{"content":"🚏 导论 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以用策略模式封装几乎任何类型的规则，只要分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这些变化的可能性。\n🧀 前置知识 🚦 结构 UML 类图 classDiagram class Context{ -strategy: Strategy +Context(strategy: Strategy) +contextInterface() } class Strategy{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +algorithmInterface() } class ConcreteStrategyA{ +algorithmInterface() } class ConcreteStrategyB{ +algorithmInterface() } class ConcreteStrategyC{ +algorithmInterface() } Context o-- Strategy Strategy \u0026lt;|-- ConcreteStrategyA Strategy \u0026lt;|-- ConcreteStrategyB Strategy \u0026lt;|-- ConcreteStrategyC 基本代码 Strategy类，定义所有支持的算法的公共接口。\npublic abstract class Strategy { /** * 算法方法 */ public abstract void algorithmInterface(); } ConcreteStrategy类，实现具体的算法。\nclass ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法A实现\u0026#34;); } } class ConcreteStrategyB extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法B实现\u0026#34;); } } class ConcreteStrategyC extends Strategy { @Override public void algorithmInterface() { System.out.println(\u0026#34;算法C实现\u0026#34;); } } Context, 用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。\npublic class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void contextInterface() { strategy.algorithmInterface(); } } 客户端代码\npublic static void main(String[] args) { Context context; context = new Context(new ConcreteStrategyA()); context.contextInterface(); context = new Context(new ConcreteStrategyB()); context.contextInterface(); context = new Context(new ConcreteStrategyC()); context.contextInterface(); } 🎭 优缺点分析 😊 优点 策略模式的Strategy层次为Context定义了一系列可重用的算法或行为。继承有助于提取这些算法的公共功能。 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 🙁 缺点 在基本的策略模式中，选择所用具体实现的职责有客户端对象承担，并转给策略模式的Context对象，其实并没有减轻客户端的负担。（可以考虑💭用策略模式+简单工厂模式，但即使是这种方式，也有不足之处，每次更改 算法都要修改Context中的switch代码，这个问题可以用反射来解决） 🎬 场景 现要做一个商场收银系统，营业员根据客户所购买商品的单价和数量，向客户收费。如下图所示：\n初步设计后，关键代码如下所示：\n// 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText()); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 但是如果要增加打折功能，就需要修改代码，在totalPrices后乘以折扣，商场活动结束再修改回去。 显然不够灵活。\n这时候可以考虑增加下拉选项，选择不同的折扣方式，如下图所示： 修改后的代码如下所示：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;打八折\u0026#34;, \u0026#34;打七折\u0026#34;, \u0026#34;打五折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { int selectedIndex = discountComboBox.getSelectedIndex(); double discount = 1; switch (selectedIndex) { case 1: discount = 0.8; break; case 2: discount = 0.7; break; case 3: discount = 0.5; break; default: discount = 1; break; } System.out.println(\u0026#34;选中的折扣：\u0026#34; + selectedIndex); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText()) * discount; // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), discountComboBox.getSelectedItem(), totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 这样修改后的代码虽然实现了功能，但是代码量增加，且不够灵活。每次增加新的折扣方式，都需要修改代码。\n🛠 解决 简单工厂模式 当折扣的业务变多时，频繁修改计算总价代码，不符合开闭原则。可以使用简单工厂模式，将计算总价的代码抽取出来，放到一个类中，根据不同的折扣方式，创建不同的类。\nclassDiagram class CashSuper{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +acceptCash(money: double): double } class CashNormal{ +acceptCash(money: double): double } class CashRebate{ +acceptCash(money: double): double } class CashReturn{ +acceptCash(money: double): double } class CashFactory{ +createCashAccept(type: String): CashSuper } CashSuper \u0026lt;|-- CashNormal CashSuper \u0026lt;|-- CashRebate CashSuper \u0026lt;|-- CashReturn CashFactory --\u0026gt; CashSuper 现金收费抽象类\npublic abstract class CashSuper{ /** * 现金收取超类的抽象方法 * @param money 原价 * @return 折后价 */ public abstract double acceptCash(double money); } 正常收费子类：\npublic class CashNormal extends CashSuper{ /** * 正常收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { return money; } } 打折收费子类：\npublic class CashRebate extends CashSuper{ private double moneyRebate = 1d; public CashRebate(String moneyRebate) { this.moneyRebate = Double.parseDouble(moneyRebate); } /** * 打折收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { return money * moneyRebate; } } 返利收费子类：\npublic class CashReturn extends CashSuper{ private double moneyCondition = 0.0d; private double moneyReturn = 0.0d; public CashReturn(String moneyCondition, String moneyReturn) { this.moneyCondition = Double.parseDouble(moneyCondition); this.moneyReturn = Double.parseDouble(moneyReturn); } /** * 返利收费 * * @param money 原价 * @return 折后价 */ @Override public double acceptCash(double money) { double result = money; if (money \u0026gt;= moneyCondition) { result = money - Math.floor(money / moneyCondition) * moneyReturn; } return result; } } 现金收费工厂类：\npublic class CashFactory { /** * 现金收取工厂 * @param type 收费类型 * @return CashSuper */ public static CashSuper createCashAccept(String type){ CashSuper cs = null; switch (type){ case \u0026#34;正常收费\u0026#34;: cs = new CashNormal(); break; case \u0026#34;满300返100\u0026#34;: cs = new CashReturn(\u0026#34;300\u0026#34;,\u0026#34;100\u0026#34;); break; case \u0026#34;打8折\u0026#34;: cs = new CashRebate(\u0026#34;0.8\u0026#34;); break; default: break; } return cs; } } 客户端主要部分：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { String cashType = (String) discountComboBox.getSelectedItem(); CashSuper cs = CashFactory.createCashAccept(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cs.acceptCash(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 简单工程虽然也能解决这个问题，这个模式知识解决对象创建问题，而且由于工厂本身包括了所有收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或拓展都要改动这个工厂，以致代码需要重新编译部署，不够灵活，所以它不是最好的办法。面对算法的时常变动，应该有更好的办法。\n策略模式 其实上面写的用简单工程模式实现的商场收银系统，已经是策略模式的一个简单应用了。在基于策略模式的代码改写上述程序。\nclassDiagram class CashContext{ -cashSuper: CashSuper +CashContext(type: String) +getResult(money: double): double } class CashSuper{ \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; +acceptCash(money: double): double } class CashNormal{ +acceptCash(money: double): double } class CashRebate{ +acceptCash(money: double): double } class CashReturn{ +acceptCash(money: double): double } CashSuper \u0026lt;|-- CashNormal CashSuper \u0026lt;|-- CashRebate CashSuper \u0026lt;|-- CashReturn CashContext --\u0026gt; CashSuper CashContext类：\nppublic class CashContext { private CashSuper cs; public CashContext(CashSuper cs) { this.cs = cs; } public double getResult(double money) { return cs.acceptCash(money); } } 客户端主要部分：\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { CashContext cc = null; String cashType = (String) discountComboBox.getSelectedItem(); switch (cashType) { case \u0026#34;满300返100\u0026#34;: cc = new CashContext(new CashReturn(\u0026#34;300\u0026#34;, \u0026#34;100\u0026#34;)); break; case \u0026#34;打8折\u0026#34;: cc = new CashContext(new CashRebate(\u0026#34;0.8\u0026#34;)); break; default: cc = new CashContext(new CashNormal()); break; } CashSuper cs = CashFactory.createCashAccept(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cc.getResult(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 但是这样还是回到了原来的问题，在客户端代码中，还是需要根据不同的折扣方式，创建不同的类，这样还是不够灵活。\n简单工厂 + 策略模式 可以尝试用简单工厂模式和策略模式结合，将创建对象的过程交给工厂，客户端只需要知道折扣方式即可。\n改造后的CashContext类：\npublic class CashContext { private CashSuper cs; public CashContext(String type) { switch (type){ case \u0026#34;正常收费\u0026#34;: this.cs = new CashNormal(); break; case \u0026#34;满300返100\u0026#34;: this.cs = new CashReturn(\u0026#34;300\u0026#34;, \u0026#34;100\u0026#34;); break; case \u0026#34;打8折\u0026#34;: this.cs = new CashRebate(\u0026#34;0.8\u0026#34;); break; default: break; } } public double getResult(double money) { return cs.acceptCash(money); } } 客户端代码\n// 创建下拉框，可以选择折扣 JComboBox\u0026lt;String\u0026gt; discountComboBox = new JComboBox\u0026lt;\u0026gt;(new String[]{\u0026#34;正常收费\u0026#34;, \u0026#34;满300返100\u0026#34;, \u0026#34;打8折\u0026#34;}); discountComboBox.setBounds(100, 110, 150, 25); frame.add(discountComboBox); // 确定按钮的动作监听器 confirmButton.addActionListener(new ActionListener() { // 声明一个double变量total来计算总计 double total = 0.0; @Override public void actionPerformed(ActionEvent e) { try { String cashType = (String) discountComboBox.getSelectedItem(); CashContext cc = new CashContext(cashType); // 声明一个double变量totalPrices来计算每个商品的单价(txtPrices) * 数量(txtNum)后的合计 double totalPrices = cc.getResult(Double.parseDouble(priceField.getText()) * Integer.parseInt(quantityField.getText())); // 将每个商品合计计入总计 total = total + totalPrices; // 更新商品列表 itemList.append(String.format(\u0026#34;单价: %s, 数量: %s, 活动: %s, 小计: %.2f\\n\u0026#34;, priceField.getText(), quantityField.getText(), cashType, totalPrices)); totalAmount.setText(String.format(\u0026#34;%.2f\u0026#34;, total)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(frame, \u0026#34;请输入有效的数字！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } }); 客户端代码与简单工程的不同\n// 简单工厂 CashSuper cs = CashFactory.createCashAccept(cashType); // 简单工厂 + 策略模式 CashContext cc = new CashContext(cashType); 在简单工厂，客户端需要知道CashFactory和CashSuper，而在简单工厂 + 策略模式中，客户端只需要知道CashContext即可。耦合性更低了。使得具体的收费算法和客户端分离，可以相互独立地变化。\n","permalink":"http://rextechie.github.io/posts/design_patterns/strategy_pattern/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以用策略模式封装几乎任何类型的规则，只要分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这些变化的可能性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-前置知识\"\u003e🧀 前置知识\u003c/h2\u003e\n\u003chr\u003e\n\u003ch2 id=\"-结构\"\u003e🚦 结构\u003c/h2\u003e\n\u003ch3 id=\"uml-类图\"\u003eUML 类图\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eclassDiagram\n   class Context{\n    -strategy: Strategy\n    +Context(strategy: Strategy)\n    +contextInterface()\n  }\n  class Strategy{\n    \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt;\n    +algorithmInterface()\n  }\n  class ConcreteStrategyA{\n    +algorithmInterface()\n  }\n  class ConcreteStrategyB{\n    +algorithmInterface()\n  }\n  class ConcreteStrategyC{\n    +algorithmInterface()\n  }\n  Context o-- Strategy\n  Strategy \u0026lt;|-- ConcreteStrategyA\n  Strategy \u0026lt;|-- ConcreteStrategyB\n  Strategy \u0026lt;|-- ConcreteStrategyC\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"基本代码\"\u003e基本代码\u003c/h3\u003e\n\u003cp\u003eStrategy类，定义所有支持的算法的公共接口。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eabstract\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eStrategy\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"cm\"\u003e/**\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e     * 算法方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e     */\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eabstract\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ealgorithmInterface\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eConcreteStrategy类，实现具体的算法。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eConcreteStrategyA\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eextends\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eStrategy\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ealgorithmInterface\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;算法A实现\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eConcreteStrategyB\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eextends\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eStrategy\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ealgorithmInterface\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;算法B实现\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eConcreteStrategyC\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eextends\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eStrategy\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ealgorithmInterface\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;算法C实现\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eContext, 用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。\u003c/p\u003e","title":"策略模式（Strategy Pattern）"},{"content":"🚏 导论 抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。\n🧀 前置知识 工厂方法模式（Factory Method） 🚦 结构 classDiagram class AbstractFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createProductA() +createProductB() } class ConcreteFactory1{ +createProductA() +createProductB() } class ConcreteFactory2{ +createProductA() +createProductB() } class AbstractProductA{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductA1 class ProductA2 class AbstractProductB{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class ProductB1 class ProductB2 class Client AbstractFactory \u0026lt;|.. ConcreteFactory1 AbstractFactory \u0026lt;|.. ConcreteFactory2 AbstractProductA \u0026lt;|.. ProductA1 AbstractProductA \u0026lt;|.. ProductA2 AbstractProductB \u0026lt;|.. ProductB1 AbstractProductB \u0026lt;|.. ProductB2 Client --\u0026gt; AbstractFactory Client --\u0026gt; AbstractProductA Client --\u0026gt; AbstractProductB AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。\nAbstractFactory是一个抽象工厂，它里面包含所有产品创建的抽象方法，而ConcreteFactory1和ConcreteFactory2就是两个具体的工厂了。\n通常在运行时在创建一个ConcreteFactory的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。\n🎭 优缺点分析 😊 优点 易于交换产品系列，由于具体工厂类在一个应用中只需要初始化的时候出现一次，这就使得改编一个应用的具体工厂变得非常简单。它只需要改变具体工厂即可使用不同的产品配置。 它让具体的创建实例过程与客户端分离，客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。 🙁 缺点 增加需求时，需要增加新的产品类，并且要调整工厂类，这增加了系统的复杂度。 每次使用都需要声明Factory，但是如果要更改产品系列，那么就需要更改所有的Factory声明。 🎬 场景 公司有一个给第三方企业做的电子商务网站，使用SQL Server数据库，已经都大致完成了。但是公司又接了另外一家公司类似的需求项目，但是这家公司想省钱，要用Access数据库。因此任务就变成了要将整个项目调整为用Access数据库。\n但是替换的过程中出现了很多问题。\nSQL Server的命名空间和Access数据库不同：SQL Server上用的是System.Data.SqlClient，而Access上用的是System.Data.OleDb。 数据库操作语法不同： Access插入数据必须用INSERT INTO，而SQL Server用INSERT（不能用INTO）。 SQL Server中的GetDate()函数在Access中是Now()。 SQL Server中有Substring()函数，而Access中是Mid()。 关键字不同 Access不能用password作为字段名，因为它是关键字，而SQL Server可以。要使用关键字需要用[]括起来。 \u0026hellip; 如果今后要换成其他数据库，那么这个项目就要重新调整。这样的设计显然是不合理的。\n🛠 解决 最初的代码 用户实体: User.java\npublic class User { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } SqlServerUser.java: 用于操作User表\npublic class SqlServerUser { public void insertUser(User user) { System.out.println(\u0026#34;在SQL Server中给User表增加一条记录\u0026#34;); } public User getUser(Integer id) { System.out.println(\u0026#34;在SQL Server中根据ID得到User表一条记录\u0026#34;); return null; } } Client.java: 客户端测试类\npublic class Client { public static void main(String[] args) { User user = new User(); SqlServerUser su = new SqlServerUser(); su.insertUser(user); su.getUser(1); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); } } 这里之所以不能换数据库，愿意在于SqlServerUser su = new SqlServerUser()使得su这个对象被框死在SQL Server上了。如果这里改成多态，那么在执行‘su.insertUser(user);’和‘su.getUser(1)’时就不需要考虑是Access还是Sql Server了。\n初步改造 考虑用工厂方法模式（工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类）进行改造。\nclassDiagram class DaoFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createUserDao() } class SqlServerDaoFactory{ +createUserDao() } class AccessDaoFactory{ +createUserDao() } class UserDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertUser(User user) +getUser(Integer id) } class SqlServerUserDao { +insertUser(User user) +getUser(Integer id) } class AccessUserDao { +insertUser(User user) +getUser(Integer id) } DaoFactory \u0026lt;|.. SqlServerDaoFactory DaoFactory \u0026lt;|.. AccessDaoFactory UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao UserDao.java: UserDao接口\npublic interface UserDao { /** * 插入用户 * @param user 用户 */ void insert(User user); /** * 获取用户 * @param id 用户id * @return 用户 */ User getUser(int id); } SqlServerUserDao.java: 用于访问SQL Server的User\npublic class SqlServerUserDao implements UserDao { /** * 插入用户 * * @param user 用户 */ @Override public void insert(User user) { System.out.println(\u0026#34;在SQL Server中给User表增加一条记录\u0026#34;); } /** * 获取用户 * * @param id 用户id * @return 用户 */ @Override public User getUser(int id) { System.out.println(\u0026#34;在SQL Server中根据id得到User表一条记录\u0026#34;); return null; } } AccessUserDao.java: 用于访问Access的User\npublic class AccessUserDao implements UserDao { /** * 插入用户 * * @param user 用户 */ @Override public void insert(User user) { System.out.println(\u0026#34;在Access中给User表增加一条记录\u0026#34;); } /** * 获取用户 * * @param id 用户id * @return 用户 */ @Override public User getUser(int id) { System.out.println(\u0026#34;在Access中根据id得到User表一条记录\u0026#34;); return null; } } DaoFactory.java: 定义一个创建访问User表对象的抽象的工厂接口\npublic interface DaoFactory { /** * 创建UserDao对象 * @return UserDao对象 */ UserDao createUserDao(); } SqlServerDaoFactory.java: 实现SqlFactory接口，实例化SqlServerFactory类\npublic class SqlServerDaoFactory implements DaoFactory { /** * 创建UserDao对象 * * @return UserDao对象 */ @Override public UserDao createUserDao() { return new SqlServerUserDao(); } } AccessDaoFactory.java: 实现SqlFactory接口，实例化AccessFactory类\npublic class AccessDaoFactory implements DaoFactory{ /** * 创建UserDao对象 * * @return UserDao对象 */ @Override public UserDao createUserDao() { return new AccessUserDao(); } } Client.java: 客户端测试类\npublic class Client { public static void main(String[] args) { User user = new User(); // DaoFactory factory = new SqlServerDaoFactory(); DaoFactory factory = new AccessDaoFactory(); UserDao userDao = factory.createUserDao(); userDao.insert(user); userDao.getUser(1); } } 这样，如果要换数据库，只需要修改DaoFactory factory = new AccessDaoFactory();即可，而对于UserDao接口的对象userDao事先根本不需要知道是访问哪个数据库。这就是所谓的业务逻辑与数据访问逻辑的解耦。\n接下来除了User表，还有Department表，架构就会变成这样：\nclassDiagram direction LR class DaoFactory{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +createUserDao() } class SqlServerDaoFactory{ +createUserDao() } class AccessDaoFactory{ +createUserDao() } class UserDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertUser(User user) +getUser(Integer id) } class SqlServerUserDao { +insertUser(User user) +getUser(Integer id) } class AccessUserDao { +insertUser(User user) +getUser(Integer id) } class DepartmentDao { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; +insertDepartment(Department department) +getDepartment(Integer id) } class SqlServerDepartmentDao { +insertDepartment(Department department) +getDepartment(Integer id) } class AccessDepartmentDao { +insertDepartment(Department department) +getDepartment(Integer id) } DaoFactory \u0026lt;|.. SqlServerDaoFactory DaoFactory \u0026lt;|.. AccessDaoFactory UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao DepartmentDao \u0026lt;|.. SqlServerDepartmentDao DepartmentDao \u0026lt;|.. AccessDepartmentDao 增加DepartmentDao.java，用于客户端访问，解除与具体数据库访问的耦合\npublic interface DepartmentDao { /** * 插入部门 * @param department 部门 */ void insert(Department department); /** * 根据id查询部门 * @param id id * @return 部门 */ Department getDepartment(Integer id); } SqlServerDepartmentDao.java: 用于访问SQL Server的Department\npublic class SqlServerDepartmentDao implements DepartmentDao { /** * 插入部门 * * @param department 部门 */ @Override public void insert(Department department) { System.out.println(\u0026#34;在SQL Server中给Department表增加一条记录\u0026#34;); } /** * 根据id查询部门 * * @param id id * @return 部门 */ @Override public Department getDepartment(Integer id) { System.out.println(\u0026#34;在SQL Server中根据id得到Department表一条记录\u0026#34;); return null; } } AccessDepartmentDao.java: 用于访问Access的Department\npublic class AccessDepartmentDao implements DepartmentDao { /** * 插入部门 * * @param department 部门 */ @Override public void insert(Department department) { System.out.println(\u0026#34;在Access中给Department表增加一条记录\u0026#34;); } /** * 根据id查询部门 * * @param id id * @return 部门 */ @Override public Department getDepartment(Integer id) { System.out.println(\u0026#34;在Access中根据id得到Department表一条记录\u0026#34;); return null; } } 在DaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * @return DepartmentDao对象 */ DepartmentDao createDepartmentDao(); SqlServerDaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * * @return DepartmentDao对象 */ @Override public DepartmentDao createDepartmentDao() { return new SqlServerDepartmentDao(); } AccessDaoFactory.java中增加创建DepartmentDao对象的方法\n/** * 创建DepartmentDao对象 * * @return DepartmentDao对象 */ @Override public DepartmentDao createDepartmentDao() { return new AccessDepartmentDao(); } 最后Client.java\npublic class Client { public static void main(String[] args) { User user = new User(); DaoFactory factory = new SqlServerDaoFactory(); // DaoFactory factory = new AccessDaoFactory(); UserDao userDao = factory.createUserDao(); userDao.insert(user); userDao.getUser(1); DepartmentDao departmentDao = factory.createDepartmentDao(); departmentDao.insert(new Department()); departmentDao.getDepartment(1); } } 输出的结果为：\n在SQL Server中给User表增加一条记录 在SQL Server中根据id得到User表一条记录 在SQL Server中给Department表增加一条记录 在SQL Server中根据id得到Department表一条记录 这样整个架构已经演进为了抽象工厂模式。当只有一个类需要被工厂方法创建的时候，是工厂方法模式，而涉及多个产品系列的问题，这种工厂模式叫做抽象工厂模式（Abstract Factory Pattern）。\n用简单工厂模式改进抽象工厂 由于抽象工厂的缺点中提到，每次使用都需要声明Factory，但是如果要更改产品系列，那么就需要更改所有的Factory声明。这里可以用简单工厂模式改进。\n直接去除DaoFactory、SqlServerDaoFactory、AccessDaoFactory，改用DataAccess类。\nclassDiagram class UserDao{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class DepartmentDao{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class SqlServerUserDao class SqlServerDepartmentDao class AccessUserDao class AccessDepartmentDao class DataAccess{ -db : string +createUser() UserDao +createDepartment() DepartmentDao } UserDao \u0026lt;|.. SqlServerUserDao UserDao \u0026lt;|.. AccessUserDao DepartmentDao \u0026lt;|.. SqlServerDepartmentDao DepartmentDao \u0026lt;|.. AccessDepartmentDao DataAccess ..\u0026gt; UserDao DataAccess ..\u0026gt; DepartmentDao DataAccess.java\npublic class DataAccess { private static final String DB = \u0026#34;SQLServer\u0026#34;; // private static final String DB = \u0026#34;Access\u0026#34;; /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; switch (DB){ case \u0026#34;SQLServer\u0026#34;: userDao = new SqlServerUserDao(); break; case \u0026#34;Access\u0026#34;: userDao = new AccessUserDao(); break; default: break; } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; switch (DB){ case \u0026#34;SQLServer\u0026#34;: departmentDao = new SqlServerDepartmentDao(); break; case \u0026#34;Access\u0026#34;: departmentDao = new AccessDepartmentDao(); break; default: break; } return departmentDao; } } Client.java 客户端代码\npublic class Client { public static void main(String[] args) { User user = new User(); Department department = new Department(); UserDao userDao = DataAccess.createUserDao(); userDao.insert(user); userDao.getUser(1); DepartmentDao departmentDao = DataAccess.createDepartmentDao(); departmentDao.insert(department); departmentDao.getDepartment(1); } } 这样的设计客户端代码可以不出现具体数据库名称，使得需要修改数据库时，只需要在DataAccess修改DB的内容就可以了。但是如果需要增加新的数据库支持，就还需要调整Access的switch结构，原来只需要增加一个工厂类就好了。\n用反射+抽象工厂的数据访问程序 为了解决既不修改switch代码结构，也不让客户端出现具体数据库名称。可以引入反射的思想，通过字符串实例化对应的类。 修改后如下所示\npublic class DataAccess { private static final String DB = \u0026#34;SqlServer\u0026#34;; private static final String packageName = \u0026#34;space.rexhub.designpatterns.creational.abstract_factory.dao.impl\u0026#34;; /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; String className = packageName + \u0026#34;.\u0026#34; + DB + \u0026#34;UserDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getDeclaredConstructor(); userDao = (UserDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; String className = \u0026#34;space.rexhub.designpatterns.creational.abstract_factory.dao.impl.\u0026#34; + DB + \u0026#34;DepartmentDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getConstructor(); departmentDao = (DepartmentDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return departmentDao; } } 这样，只需要修改DB的值，就可以实现不同数据库的切换，并且不需要修改switch结构。如果我们需要提供Oracle的支持，只需要创建OracleUserDao和OracleDepartmentDao类，然后修改DB的值即可。\n但还是可以挑出毛病，切换数据库还是需要在代码里进行修改，能否不修改代码就能切换数据库呢？\n用反射+配置文件实现数据访问程序 为了不修改数据库就能切换数据库，可以将数据库名称放在配置文件中，然后通过反射实例化对应的类。\n创建一个 database_config.properties文件，内容如下：\nDB = SqlServer DataAccess.java只需要从配置文件中获取DB就可以了\npublic class DataAccess { private static final String PACKAGE_NAME = \u0026#34;space.rexhub.design_patterns.creational.abstract_factory.dao.impl\u0026#34;; private static String DB; static{ Properties properties = new Properties(); try { properties.load(new FileInputStream(\u0026#34;space/rexhub/design_patterns/creational/abstract_factory/database_config.properties\u0026#34;)); DB = (String) properties.get(\u0026#34;DB\u0026#34;); } catch (IOException e) { DB = null; } } /** * 创建用户Dao * @return UserDao */ public static UserDao createUserDao(){ UserDao userDao = null; String className = PACKAGE_NAME + \u0026#34;.\u0026#34; + DB + \u0026#34;UserDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getDeclaredConstructor(); userDao = (UserDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return userDao; } /** * 创建部门Dao * @return DepartmentDao */ public static DepartmentDao createDepartmentDao(){ DepartmentDao departmentDao = null; String className = PACKAGE_NAME + \u0026#34;.\u0026#34; + DB + \u0026#34;DepartmentDao\u0026#34;; try { Constructor\u0026lt;?\u0026gt; constructor = Class.forName(className).getConstructor(); departmentDao = (DepartmentDao) constructor.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } return departmentDao; } } 这样这个数据库切换的问题就可以相对较完美的解决了，我们应用了反射+抽象工厂模式解决了数据库访问时的可维护、可扩展问题。\n","permalink":"http://rextechie.github.io/posts/design_patterns/abstract_factory_pattern/","summary":"\u003ch2 id=\"-导论\"\u003e🚏 导论\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"-前置知识\"\u003e🧀 前置知识\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../factory_method/\"\u003e工厂方法模式（Factory Method）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"-结构\"\u003e🚦 结构\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eclassDiagram\n    class AbstractFactory{\n        \u0026lt;\u0026lt;interface\u0026gt;\u0026gt;\n        +createProductA()\n        +createProductB()\n    }\n    class ConcreteFactory1{\n        +createProductA()\n        +createProductB()\n    }\n    class ConcreteFactory2{\n        +createProductA()\n        +createProductB()\n    }\n    class AbstractProductA{\n        \u0026lt;\u0026lt;interface\u0026gt;\u0026gt;\n    }\n    class ProductA1\n    class ProductA2\n    class AbstractProductB{\n        \u0026lt;\u0026lt;interface\u0026gt;\u0026gt;\n    }\n    class ProductB1\n    class ProductB2\n    class Client\n    AbstractFactory \u0026lt;|.. ConcreteFactory1\n    AbstractFactory \u0026lt;|.. ConcreteFactory2\n    AbstractProductA \u0026lt;|.. ProductA1\n    AbstractProductA \u0026lt;|.. ProductA2\n    AbstractProductB \u0026lt;|.. ProductB1\n    AbstractProductB \u0026lt;|.. ProductB2\n    Client --\u0026gt; AbstractFactory\n    Client --\u0026gt; AbstractProductA\n    Client --\u0026gt; AbstractProductB\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。\u003c/p\u003e","title":"抽象工厂模式（Abstract Factory）"},{"content":"基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ArXiv 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。\n研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。\n在MetaGPT中，对于每个角色制定了Agent的名字（name）、资料（profile）、目标（goal）和约束（constraints）。同时也初始化每个角色的特定的上下文（context）和技能（skill）。例如，产品经理可以使用网络搜索技能，而工程师可以执行代码。如下图2所示。所有Agent遵循ReAct风格。\n图2：一个展示MetaGPT软件开发生成过程的图表，强调其对SOPs的显著依赖。\n每个Agent监控环境（MetaGPT中的消息池）以发现重要的观察结果（如其他agent的消息），这些消息可以直接触发Agent的行为，也可以协助完成任务。\nAgent之间的工作流程（Workflow across Agents） 通过定义代理的角色和技能，可以建立起基本的工作流。在MetaGPT的工作中，遵循软件开发中的SOP，使得所有工作都能按顺序执行。\n具体来说，如之前图1所示，产品经理在获取用户需求后，进行全面的需求分析，制定PRD（Product requirement document），里面包含用户故事和需求池。之后将PRD传递给架构师，他会将需求转为系统设计，例如文件列表、数据结构以及接口定义等。一旦在系统设计中捕获，信息就会直接发送给项目经理以进行任务分配。工程师则继续执行指定的类和功能（如图2所示）。在之后的阶段，QA工程师制定测试用例确保代码质量。最后MetaGPT生成高质量的软件解决方案。详细的SOP工作流程如下图3所示。\n图3：MetaGPT软件开发生成过程。\n通信协议（Communication Protocol） 结构化通信接口（Structed Communication Interfaces） 如今大部分基于大语言模型的多智能体框架（CAMEL、NLSOM、CoELA、Generative Agents）都是使用无约束的自然语言作为通信接口。但是如果只用自然语言作为通信接口，会出现问题。如在电话游戏中，在几轮传递之后，原始的信息会发生扭曲。当用纯自然语言进行通信时，也会出现这种问题。因此需要每个角色制定一个结构化的通信接口，以确保信息的准确传递。如之前的图3所示，架构师Agent产生两个输出：系统接口设计和顺序流程图。与ChatDev不同，MetaGPT中的Agent通过文档和图输出，而不是对话。这些文档也都是包含必要信息的文档，防止出现不相关或丢失的内容。\n发布订阅机制（Publish-Subscribe Mechanism） 共享信息对于协作非常关键。比如：建筑师和工程师需要参考PRD。然而，如果每次都是以一对一的方式传达这些信息，可能会使通信变得复杂，效率低下。为了解决这个问题，一个可行的方案是将信息存储在一个全局信息池中。如图2左边所示，metagpt引入了共享消息池，允许所有agent直接访问和发布信息。这样就可以使得任何Agent可以直接从共享池中检索所需的信息，而不需要通过其他Agent传递。这样提高了通信效率。\n如果与每个Agent共享所有信息可能会导致信息过载。在执行任务期间，Agent通常喜欢接受与任务相关的信息，要避免因不相关的细节而分散注意力。如图2左边所示，MetaGPT引入了订阅机制，Agent不依赖对话，而是利用角色特定的兴趣来提取相关的信息。实际实现的时候，一个Agent只会在接收到所有其先决依赖项后才会激活操作。如之前图3所示，架构师主要关注产品经理提供的PRD，而QA工程师等角色的文档可能不太关心。\n迭代编程与执行反馈（Iterative programming with execution feedback） 在现实开发中，调试和优化非常重要。然而现有的方法通常缺少自我纠错的机制（self-correction mechanism），从而导致代码生成失败。之前也有一些人引入了不可执行代码审查（non-executable code review）和自我反思（self-reflection）:ChatDev、ReAct。然而它们在确保代码可执行性和运行时正确性上还是面临很大的挑战。\nMetaGPT引入了一种可执行的反馈机制(executable feedback)来迭代改进代码。更具体地说，如之前图2所示，要求工程师根据产品需求和设计编写代码。这使得工程师能够使用自己的历史执行记录和调试记忆来持续的改进代码。为了获得额外的信息，工程师编写并执行相应的单元测试用例，然后接收测试结果。如果测试结果满足条件，则启动其他的开发任务，否则工程师将进行调试。这种迭代过程将会持续进行，直到测试通过或达到最大迭代次数（3次）。\n实验结果 (Results) 实验环境（Experimental Setup） 数据集（Dataset） 作者使用了两个公开的benchmarks（HumanEval、MBPP）以及一个自己设计的软件开发的benchmark\nHumanEval: 出自openai，有164个手写编程任务，包括提示词（prompt）、标准答案（canonical_solution）、单元测试代码（test）、函数名称（entry_point）。 MBPP: 出自google search，有427个Python任务，这些任务涵盖核心概念和标准库代码，并包括要求（text）、代码（code）、单元测试集（test_list）等信息。 SoftwareDev：作者自己设计的Benchmark，包含70个软件开发任务的代表性示例，每个示例都有自己的任务提示。如下表所示。这些任务有游戏、算法、数据可视化等等。Software专注于工程方面。 评估指标（Evaluation Metrics） pass@k: 对于HumanEval和MBPP，作者使用了openai提出的无偏估计的pass@k指标，$\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。 对于SoftwareDev，优先考虑实际使用，并通过人工评估（A、E）或统计分析（B、C、D）来评估性能。 A：可执行性，该指标对代码进行评分，从1（失败/无法运行）～4（完美）。1-非功能性、2-可运行但不完美、3-可运行但不完美、4-完美。 B：成本，包括运行时间、token使用量以及费用。 C：代码统计，包括代码文件数、每个文件代码行数以及总代码数 D：生产率，定义为token使用量/代码行数，即每行代码消耗的令牌。 E：人工修订成本，指手动修正的次数，解决诸如包导入错误、类名不正确或不完整的引用路径等问题。通常，每次修正涉及最多3行代码。 基线（Baselines） 对于HumanEval和MBPP，作者使用了一些基线模型：\nAlphaCode InCoder CodeGeeX CodeGen CodeX CodeT PaLM GPT-4 其中Dong等人已经提供了一些结果（如InCoder、CodeGeeX）。在HumanEval和MBPP中，作者稍微修改了下提示词，以适应MetaGPT的输入格式。\n对于SoftwareDev上的基线\nAutoGPT LangChain with Python Read-Eval-Print Loop(REPL) tool AgentVerse ChatDev 主要结果（Main Result） 上图表明MetaGPT在HumanEval和MBPP基准测试中达到了SOAT。\nMetaGPT在SoftwareDev上的实验结果几乎均好于ChatDev。这些结果均凸显出SOP在多个Agent直接协作中的好处。\n在上图中，通过可视化示例展示了MetaGPT在SoftwareDev上的生成结果。\n能力分析（Capability Analysis） 如上表所示，MetaGPT包含多种能力，可以有效地处理复杂且专业的开发业务，结合SOPs可以显著改进代码生成。\n消融实验（Ablation Study） 角色的有效性 为了了解不同角色对最终结果的影响，作者对角色部分做了消融实验。结果如上表所示，虽然更多的角色会稍微增加费用，但整体性能显著提高，展示了各种角色的有效性。\n可执行的反馈机制的有效性 在一开始的主要结果展示的图中，见可执行反馈添加到MetaGPT，pass@1显著提高。此外，表1中显示出反馈机制提高了可行性并降低了人工修改成本。这些结果说明了反馈机制如何能够生成更高质量的代码。\n参考文献 (References) Austin J, Odena A, Nye M, et al. Program synthesis with large language models[J]. arXiv preprint arXiv:2108.07732, 2021. Yao S, Zhao J, Yu D, et al. React: Synergizing reasoning and acting in language models[J]. arXiv preprint arXiv:2210.03629, 2022. Zhao X, Li M, Weber C, et al. Chat with the environment: Interactive multimodal perception using large language models[C]//2023 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2023: 3590-3596. 备注 (Notes) 这篇论文本身对方法的描述不足够详细，在实现Agent上有很多小技巧，需要读源码才能体会到\n优点与创新点 (Strengths) 将SOPs与Agent结合，更加模仿了真实世界的软件开发过程。 设计了共享消息池和订阅机制，提高了通信效率。 引入了可执行的反馈机制，提高了代码生成的质量。 局限性与不足 (Limitations) 实际使用后，项目的可执行性还是有待提高。 SoftwareDev的实验评价指标略为主观 我的思考 (Personal Thoughts) 本文与我研究的相关性：MetaGPT可以实现一些复杂任务的开发，在全栈项目开发中有共同之处。对于SOPs的思想、共享消息池和订阅机制以及可执行的反馈机制，可以考虑在项目中使用。 是否有可以改进的地方：评价指标还有待改进。 后续可能的研究方向：MetaGPT实现的任务较为广泛，考虑缩小范围，只生成Web开发相关的代码。 ","permalink":"http://rextechie.github.io/posts/paper_note/metagpt/","summary":"\u003ch2 id=\"基本信息\"\u003e基本信息\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e标题\u003c/strong\u003e: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e作者\u003c/strong\u003e: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e作者单位\u003c/strong\u003e: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e期刊/会议\u003c/strong\u003e: ArXiv\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e发表年份\u003c/strong\u003e: 2023\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDOI\u003c/strong\u003e: \u003ca href=\"https://arxiv.org/abs/2308.00352\"\u003e2308.00352\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开源地址\u003c/strong\u003e: \u003ca href=\"https://github.com/geekan/MetaGPT\"\u003eGithub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键词\u003c/strong\u003e: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"研究背景-background\"\u003e研究背景 (Background)\u003c/h2\u003e\n\u003cp\u003e利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"研究问题-research-questions\"\u003e研究问题 (Research Questions)\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e如何使用应用SOPs与Agent协作开发。\u003c/li\u003e\n\u003cli\u003e如何优化Agent协作通信能力。\u003c/li\u003e\n\u003cli\u003e如何提高代码生成的质量。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"核心贡献-key-contributions\"\u003e核心贡献 (Key Contributions)\u003c/h2\u003e\n\u003cp\u003e总结本文的主要贡献点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。\u003c/li\u003e\n\u003cli\u003e作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%）\u003c/li\u003e\n\u003cli\u003e在HumanEval和MBPP达到了SOAT\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"metagpt-框架-metagpt-framework\"\u003eMetaGPT 框架 (MetaGPT Framework)\u003c/h2\u003e\n\u003ch3 id=\"sop中的agentagents-in-stanndard-operating-procedures\"\u003eSOP中的Agent（Agents in Stanndard Operating Procedures）\u003c/h3\u003e\n\u003ch4 id=\"角色的特定职能\"\u003e角色的特定职能\u003c/h4\u003e\n\u003cp\u003e解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示：\n\u003cimg alt=\"Figure 1\" loading=\"lazy\" src=\"/images/20250108143655.png\"\u003e\n图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。\u003c/p\u003e\n\u003cp\u003e在MetaGPT中，对于每个角色制定了Agent的名字（name）、资料（profile）、目标（goal）和约束（constraints）。同时也初始化每个角色的特定的上下文（context）和技能（skill）。例如，产品经理可以使用网络搜索技能，而工程师可以执行代码。如下图2所示。所有Agent遵循\u003ca href=\"https://arxiv.org/pdf/2210.03629\"\u003eReAct\u003c/a\u003e风格。\u003c/p\u003e","title":"MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework"},{"content":"基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。\n研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。\n功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。\nKual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n \u0026gt; k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c \u0026lt;= n），并计算无偏估计量。其中 $\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。\n直接计算这个估计量会导致得到非常大的数字并且数值不稳定。在下图3中包含了数值稳定性的numpy实现，它简化了表达式并逐项评估乘积项。有人也许会尝试用1-(1-p_hat)^k来估pass@k, 其中p_hat是pass@1的经验估计，但是作者已经证明了这个方式是有偏差的。 上图的推导证明如下所示 例子🌰： 给定n为10，k为2\nid n c k pass@k 0 10 10 2 1 1 10 9 2 1 2 10 8 2 0.98 4 10 7 2 0.93 5 10 6 2 0.86 6 10 5 2 0.78 7 10 4 2 0.67 8 10 3 2 0.53 9 10 2 2 0.38 10 10 1 2 0.2 11 10 0 2 0 手写部分计算过程如下所示 HumanEval数据集(HumanEval: Hand-Wirtten Evaluation Set) 数据集名称：HumanEval 数据集规模：164个手写编程问题 数据集结构：函数签名、问题描述、主体和单元测试（每个问题平均有7.7个单元测试i）。 数据集来源：数据集必须是手写的，因为模型本身已经从Github训练了，Github中已经包含了解决方案。 数据集地址：GitHub 执行生成函数的沙箱(Sandbox for Executing Generated Functions) 由于公开的代码具有未知意图，因此在执行生成的代码时，需要一个沙箱环境，以防止恶意代码的执行。开发沙箱环境的目标是防止这些程序修改、在主机或网络上获得持久性、访问敏感资源或从主机或网络中窃取数据。由于OpenAI的训练是在K8s集群和云服务上，因此沙箱也一样。\n作者选择了gVisor容器作为主要主机保护组件（Unsupervised Translation of Programming Languages）。不使用Docker，是因为Docker容器运行时可以与容器共享主机资源，恶意容器可能会危及主机。gVisor通过模拟其资源在主机和容器之间引入一个安全边界来保护主机。网络相邻的主机和服务受基于eBPF防火墙规则的保护，这些规则阻止了入站和出站的链接（实验所需连接以外的连接）\n代码微调 (Code Fine-Tuning) 微调GPT(12B参数) -\u0026gt; Codex\n数据收集 (Data Collection) 来源：Github上54亿个公共仓库 规模：178GB的Python文件，每个Python文件大小不到1MB。过滤了之后剩下159GB的数据。 数据清洗：过滤掉了可能是自动生成、平均行数大于100、最大行数大于1000或者包含一小部分字母数字字符的文件。 方法 (Method) 学习率：与GPT相同 学习率预热（防止模型开始训练时不稳定，让开始训练的几个step学习率小一些）：175步 学习率调整：余弦学习率衰减 优化器：Adam优化器，β1 = 0.9, β2 = 0.95, €= 10−8，权重衰减系数为0.1 词法分析器：代码词法分析器（code lexer），由于Github上的代码和自然语言在数据分布上不一样，因此词法分析器也要不一样。造成模型低效的的最大的原因是对里面whitespace的编码，因此作者添加了一组token来表示不同长度的whitespace。 评估 使用pass@k指标 评估数据：将每个HumanEval问题整理成Prompt，包含元注解（header）、函数声明（signature）、文档注释（docstring）。如下图2所示。 停止采样：停止采样符（[\u0026rsquo;\\nclass\u0026rsquo;, \u0026lsquo;\\ndef\u0026rsquo;, \u0026lsquo;\\n#\u0026rsquo;, \u0026lsquo;\\nif\u0026rsquo;, \u0026lsquo;\\nprint\u0026rsquo;]中的一个，否则模型会生成额外的函数或语句） 采样策略：采用核采样（Top-p），并设置top-p=0.96 实验结果 (Results) 如Kaplan等人Scaling Laws for Neural Language Models指出的，语言模型测试损失在模型大小上遵循幂律。代码微调后的测试损失也遵循类似的形式，$\\left( \\frac{N}{5.92 \\times 10^7} \\right)^{-0.13}$，其中N是模型中非embedding参数的参数数量。\n探究不同的k值与temperature的关系。图中可以得出temperature越高，k值越高，则结果越好，因为样本具有更高的多样性，而度量reward只关注是否生成正确解。\n对于679M参数的模型，pass@1的最佳temperature是0.2， pass@100的最佳temperature是0.8。由实验结果可知，他们的pass@k随参数量的变化非常的平滑。\nPass@k是评估k个样本中有多少个通过了单元测试，为了更加接近真实值，引入了n和c，只要n足够大，得到的pass@k就会更接近于真实值。但在实际推理过程的选择中，我们也必须从生成的样本中选择一个样本。根据上图可知选择具有最高平均token对数概率比随机选择要好，但是随机选择比依据对数概率总和来选要稍差。这个图表说明了选择样本的启发式算法的重要性。对于Docstring backtranslation后文会提到，TODO。\n上图是计算Codex-12B（temperatire = 0.8） HumanEval样本与其参考解决方案的BLEU分数。纵坐标是概率密度，横坐标是BLEU分数。显然，BLEU分数的提高可能并不代表在实际中运行正确。\n相关模型和系统的对比分析 (Comparative Analysis of Related Models and Systems) 类似Codex，GPT-Neo、GPT-J基于The Pile进行训练。这个数据集来自各种来源以及8%的Github代码。作者使用HumanEval数据集对GPT-Neo和GPT-J进行了评估。\n对于GPT-Neo，pass@1达到了6.4%，pass@100达到了21.3%，而同等规模的GPT模型在这两个指标上都接近于0%。GPT-Neo-2.7B相当于Codex-85M（参数量少了30倍）。temperature为0.2、0.4和0.8时结果最好。 对于GPT-J-6B，pass@1达到了11.7%，pass@100达到了27.7%。相当于Codex-300M（参数量少了20倍）。temperature为0.2和0.8时结果最好。\n与当时最好的代码补全模型Tabine做了比较，Tabine在pass@1(T = 0.4)为2.6%，pass@100(T = 0.8)为7.6%。相当于Codex-12M。\nAPPS数据集上的结果（Results on the APPS Dataset） APPS(Hendrycks2021年提出, Pre-training of deep bidirectional transformers for language understanding)是一个用于评估代码生成模型的数据集。这个数据集包含5000个训练样本和5000个测试样本，都是关于代码问题，每个都包含单元测试。对于训练数据，包含正确的解决方案。\n与HumanEval不同，APPS数据测试类似OJ判题，从sdin和sdout读取输入输出。\nAPPS论文中测试了找到问题正确解决方案的比例（strict accuracy）和单元测试的通过率（即使答案不对，但只要通过测试）。后一个的度量是为了减少方差（因为第一个准确率很低），因此在测试时要尽量避免strict accuracy。\n在程序竞赛和APPS数据上，会给出三个输入输出用例。作者从模型中采样1000个解决方案，将通过这3个单元测试的解决方案筛选出来。最后计算这个筛选后的样本的pass@k。 考虑算法效率，在算法竞赛中超时是不能被接受的.但是对于Codex，作者评估中使用了3秒的超时时间。 由于Codex没有在APPS上进行指令微调，因此在提示词中添加了input/output示例。在表中表示为\u0026quot;1-shot\u0026quot;。实验结果表明用3个input/output测试过滤出来的样本，再去评估pass@k，效果更好。\n有监督微调 (Supervised Fine-Tuning) 有些从Github上找到的代码是包含类的实现、配置文件、脚本、甚至用来存储数据，这些与生成代码无关。作者假定这些错误匹配的代码会影响HumanEval的性能。作者分别收集了两类数据，一类是来自编程竞赛网站（和我一开始对于做代码生成的想法一摸一样，不过看来三年前就已经有人在做了🤔。。。），一类是持续集成仓库。用这些数据来训练出来的模型，作者称之为Codex-S。\n编程竞赛中的问题（Problems from Competitive Programming） OJ判题大多通过隐藏的单元测试来自动判断提交的功能正确性，这些单元测试通常有优秀的测试覆盖率，是经过了精心设计的。作者从多个流行的编程竞赛和面试网站手机了相关的问题描述、函数声明以及解决方案，把他们整理成类似HumanEval的格式，使用问题描述作为docstring。由于网站的单元测试是不公开的，作者依据问题的描述创建单元测试，或者通过提交错误解决方案提取了额外的测试用例。总共，作者收集了10000个问题。（🤡这方面的工作已经比较成熟了，感觉不好从这方面继续做研究了。）\n持续集成中的问题（Problems from Continuous Integration） 对于使用了持续集成（CI）相关的项目，使用python中sys.setprofile可以记录函数调用的输入和输出，这些数据天然的可以作为单元测试。作者考虑使用GitHub仓库，其中使用Travis和Tox作为它们的持续集成（CI）框架，因为它们是最受欢迎的CI工具之一。作者最终从数百万个问题中收集了40000个问题，因为不是所有的问题都接受输入并返回输出的。\n过滤问题（Filtering Problems） 为了控制模型的训练数据质量，作者使用Codex-12B对每一个任务生成100个样本，如果没有一个样本通过测试，则说明这个问题的描述是不清晰的，作者会将这个问题过滤掉。\n方法 (Method) 用这些最后的训练数据对Codex进行有监督微调得到Codex-S。作者训练主要是最小化参考解决方案的负对数似然。他们使用了训练Codex学习率的1/10的学习率来微调Codex-S，但学习率计划是一样的，训练直到验证集损失达到平稳。\n实验结果 (Results) 和Codex一样，他们首先计算pass@k的最佳temperature（1 \u0026lt;= k \u0026lt;= 100）。作者发现对于k \u0026gt; 1，Codex-S更喜欢略高的temperature，这可能反映了Codex-S的分布比Codex更狭窄。作者对于pass@1使用temperature=0, pass@100使用temperature=1。\n随后作者比较了Codex-S和Codex在pass@1和pass@100。实验结果表明，Codex-S在pass@1 平均比Codex高出6.5%，在pass@100上平均高出15.1%。\n作者同时还绘制了Codex-S-12B的不同样本选择启发式算法在Codex-S-12B上的性能与Codex-12B上的相同启发式算法进行比较。当按平均对数概率从1到100个样本进行排名时，平均比随机高11.6，这比Codex高出2%。\ndocstring生成 (Docstring Generation) 用docstring生成代码是可能的（合理的），因为代码通常紧跟在docstring之后，但是通过代码生成docstring是困难的。因此作者又开发了一个编写docstring的模型，可以描述生成代码的意图。使用前一节的训练问题描述，可以简单的创建一个训练数据集用于依据代码生成描述。\n具体来说，对于每一个训练问题，作者集成了训练样本的函数声明、参考解决方案和docstring。和之前一样，他们训练docstring生成模型（Codex-D）最小化负对数似然。\n对于生成代码，可以在HumanEval上测量pass@k作为基准测试，其中正确性由单元测试来定义。然而，没有类似的方法可以自动评估docstring样本.因此，他们通过手动来评估这些样本，如果文档字符串独特且准确的描述了代码，则认为是正确的。由于工作量大，作者只对每个问题生成的10个样本进行了评估，总共1640个问题，用temperature=0.8的Codex-D-12B。当模型简单的将代码体里的代码复制到docstring中时，作者认为这是错误的。最常见的错误是遗漏了重要的细节（如：结果保留两位小数）或者过度的要求函数名但是函数体的内容与函数名无关。\n实验结果表明，Codex-D的通过率较低，但是与相同temperature下的Codex-S相当。由于自然语言语法没有代码语法严格，所以生成的文档可能更宽容。docstring的质量相对较低，因为程序员🧑‍💻不会花很多时间来写docstring。\n最后，使用docstring模型，又有了一种从k个样本中选出一个样本的方法。不同与之前用最佳平均对数概率选择样本，可以最大化back-translation的P（GT docstring | 生成的样本），其中P是由Codex-D得出的。然而，如下图所示，通过back-translation进行排序的表现不如平均对数概率排序，尽管他优于随机排序。\n局限性与不足 (Limitations) Codex在训练上并不高效：作者认为没必要用Github上这么多的代码，实际上一个完成了学习的科班学生，预计能解决更大一部分的问题（比起Codex-12B）。 Codex可能会出现语法错误或未定义的代码，并且调用未定义或不在定义域内的函数、变量和属性。此外Codex在解析越来越长、更高层次或系统级的要求的时候会比较困难。为了具体说明这个问题，作者创建了一个由13个基本构建快组成的合成数据集。比如“将字符串转换为小写”或“移除每个字符串中第三个元素”（附录C里有详细的内容）。作者发现随着构建块链长度的增加，Codex的性能会呈指数下降。 和其他模态中的文本条件生成模型很难将属性绑定到对象上一样，Codex在将操作绑定到对象上也会出错，尤其是文档涉及的操作和变量很大的时候。如下面代码所示，Codex-12B并没有减少w变量，也没有返回四个变量的乘积。 def do_work(x, y, z, w): \u0026#34;\u0026#34;\u0026#34; Add 3 to y, then subtract 4 from both x and w. Return the product of the four numbers. \u0026#34;\u0026#34;\u0026#34; t=y+3 u=x-4 v=z*w return v 核心贡献 (Key Contributions) 总结本文的主要贡献点：\n提出了一个评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 作者提出了Codex，通过对GPT-3进行微调，使其在HumanEval数据集上的性能得到了进一步提升。 作者提出了Codex-S，通过有监督微调Codex，使其在HumanEval数据集上的性能得到了进一步提升。 作者提出了Codex-D，通过训练docstring生成模型，使其在HumanEval数据集上的性能得到了进一步提升。 参考文献 (References) Kulal, Sumith, et al. \u0026ldquo;Spoc: Search-based pseudocode to code.\u0026rdquo; Advances in Neural Information Processing Systems 32 (2019). Hendrycks, Dan, et al. \u0026ldquo;Measuring coding challenge competence with apps.\u0026rdquo; arXiv preprint arXiv:2105.09938 (2021). 备注 (Notes) 论文提到一个现象（Introduction），12B的Codex可以解决28.8%的问题，而300M的Codex只能解决13.2的问题。这是为什么？ 论文提到了启发式（Heuristic），指的是什么 优化后的pass@k有什么含义。 这篇文章的Related work写了这个领域的发展，最早2011年就有人开始研究代码生成。这部分内容值得深入探索。 我的思考 (Personal Thoughts) 本文与我研究的相关性：提出了一个评估大型语言模型生成代码能力的方法，对于代码生成的研究有一定的参考价值。 是否有可以改进的地方：数据集的数量已经足够，但是数据集的质量可能还有待提高。作者提到了Codex在解析越来越长、更高层次或系统级的要求的时候会比较困难，这个问题也值得进一步研究。 后续可能的研究方向：研究更多相关评估大语言模型生成代码能力的数据集，如MBPP、APPS等数据集。 ","permalink":"http://rextechie.github.io/posts/paper_note/human_eval/","summary":"\u003ch2 id=\"基本信息\"\u003e基本信息\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e标题\u003c/strong\u003e: Evaluating Large Language Models Trained on Code\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e作者\u003c/strong\u003e: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e作者单位\u003c/strong\u003e: OpenAI, Anthropic AI, Zipline\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e期刊/会议\u003c/strong\u003e: arXiv\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e发表时间\u003c/strong\u003e: 2021年7月14日\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDOI\u003c/strong\u003e: \u003ca href=\"https://arxiv.org/abs/2107.03374\"\u003e2107.03374\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开源地址\u003c/strong\u003e: \u003ca href=\"https://www.github.com/openai/human-eval\"\u003eGitHub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键词\u003c/strong\u003e: 代码生成, 代码评估, 代码理解\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"研究背景background\"\u003e研究背景(Background)\u003c/h2\u003e\n\u003cp\u003e对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（\u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/321186.321192\"\u003eExperiments with a heuristic compiler\u003c/a\u003e、\u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/362566.362568\"\u003eToward automatic program synthesis\u003c/a\u003e）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有\u003ca href=\"https://arxiv.org/pdf/2002.08155\"\u003eCodeBert\u003c/a\u003e和\u003ca href=\"https://arxiv.org/pdf/2010.03150\"\u003ePyMT5\u003c/a\u003e。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"研究目标research-objectives\"\u003e研究目标(Research Objectives)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。\u003c/li\u003e\n\u003cli\u003e提出Codex，通过对GPT-3进行微调。\u003c/li\u003e\n\u003cli\u003e提出Codex-S，通过有监督微调Codex。\u003c/li\u003e\n\u003cli\u003e提出Codex-D，通过训练docstring生成模型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"评估框架-evaluation-framework\"\u003e评估框架 (Evaluation Framework)\u003c/h2\u003e\n\u003cp\u003e作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。\u003c/p\u003e\n\u003ch3 id=\"功能的正确性functional-correctness\"\u003e功能的正确性(Functional Correctness)\u003c/h3\u003e\n\u003cp\u003e评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文\u003ca href=\"https://arxiv.org/pdf/2009.10297\"\u003eCodeBLEU: a Method for Automatic Evaluation of Code Synthesis\u003c/a\u003e中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。\u003cstrong\u003e评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eKual等人在2019(\u003ca href=\"https://proceedings.neurips.cc/paper/2019/file/7298332f04ac004a0ca44cc69ecf6f6b-Paper.pdf\"\u003eSPoC: Search-based Pseudocode to Code\u003c/a\u003e)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，\u003cstrong\u003e我们给每个任务生成n个样本（n \u0026gt; k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c \u0026lt;= n），并计算无偏估计量\u003c/strong\u003e。其中 $\\text{pass@}k := \\mathbb{E}_{\\text{Problems}} \\left[ 1 - \\frac{\\binom{n-c}{k}}{\\binom{n}{k}} \\right]$。\u003c/p\u003e","title":"Evaluating Large Language Models Trained on Code"},{"content":"关于我 🎓 🎯 软件工程研究生在读 🔬 研究方向：基于大语言模型的代码生成 💻 后端开发工程师 🌱 持续学习，保持热情 研究领域 🚀 大语言模型在软件工程中的应用 智能代码生成与程序合成 代码理解与转换 技术栈 💪 语言：Java, Python, JavaScript\u0026hellip; 框架：Spring Boot, Spring Cloud, MyBatis\u0026hellip; 数据库：MySQL, Redis, MongoDB, Elasticsearch\u0026hellip; AI/ML：Neural Network, Transformers\u0026hellip; 项目经历 📚 🤖 基于LLM的代码生成系统 🌟 分布式微服务架构设计与实现 📊 企业级数据分析平台 生活爱好 ⭐ 🏸 羽毛球爱好者 🏃 跑步健身 📚 阅读：技术书籍 GitHub 统计 📊 联系我 📫 Email: rexhub@163.com Blog: 个人博客 ","permalink":"http://rextechie.github.io/about/","summary":"\u003ch2 id=\"关于我-\"\u003e关于我 🎓\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e🎯 软件工程研究生在读\u003c/li\u003e\n\u003cli\u003e🔬 研究方向：基于大语言模型的代码生成\u003c/li\u003e\n\u003cli\u003e💻 后端开发工程师\u003c/li\u003e\n\u003cli\u003e🌱 持续学习，保持热情\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"研究领域-\"\u003e研究领域 🚀\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e大语言模型在软件工程中的应用\u003c/li\u003e\n\u003cli\u003e智能代码生成与程序合成\u003c/li\u003e\n\u003cli\u003e代码理解与转换\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"技术栈-\"\u003e技术栈 💪\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e语言：Java, Python, JavaScript\u0026hellip;\u003c/li\u003e\n\u003cli\u003e框架：Spring Boot, Spring Cloud, MyBatis\u0026hellip;\u003c/li\u003e\n\u003cli\u003e数据库：MySQL, Redis, MongoDB, Elasticsearch\u0026hellip;\u003c/li\u003e\n\u003cli\u003eAI/ML：Neural Network, Transformers\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"项目经历-\"\u003e项目经历 📚\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e🤖 基于LLM的代码生成系统\u003c/li\u003e\n\u003cli\u003e🌟 分布式微服务架构设计与实现\u003c/li\u003e\n\u003cli\u003e📊 企业级数据分析平台\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"生活爱好-\"\u003e生活爱好 ⭐\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e🏸 羽毛球爱好者\u003c/li\u003e\n\u003cli\u003e🏃 跑步健身\u003c/li\u003e\n\u003cli\u003e📚 阅读：技术书籍\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"github-统计-\"\u003eGitHub 统计 📊\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"GitHub统计\" loading=\"lazy\" src=\"https://github-readme-stats.vercel.app/api?username=rextechie\u0026show_icons=true\u0026theme=radical\"\u003e\u003c/p\u003e\n\u003ch2 id=\"联系我-\"\u003e联系我 📫\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eEmail: \u003ca href=\"mailto:rexhub@163.com\"\u003erexhub@163.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eBlog: \u003ca href=\"https://rextechie.github.io/\"\u003e个人博客\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003c!-- raw HTML omitted --\u003e","title":"About"}]