<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>设计模式 on RexBlog</title>
    <link>http://rextechie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on RexBlog</description>
    <image>
      <title>RexBlog</title>
      <url>http://rextechie.github.io/images/profile.png</url>
      <link>http://rextechie.github.io/images/profile.png</link>
    </image>
    <generator>Hugo -- 0.140.2</generator>
    <language>en</language>
    <lastBuildDate>Fri, 10 Jan 2025 09:12:18 +0800</lastBuildDate>
    <atom:link href="http://rextechie.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>设计模式</title>
      <link>http://rextechie.github.io/posts/design_patterns/design_patterns/</link>
      <pubDate>Tue, 07 Jan 2025 20:59:11 +0800</pubDate>
      <guid>http://rextechie.github.io/posts/design_patterns/design_patterns/</guid>
      <description>记录《大话设计模式》学习笔记，深入浅出23种设计模式，从实际应用出发理解设计模式的精髓</description>
    </item>
    <item>
      <title>开放-封闭原则(Open Closed Principle)</title>
      <link>http://rextechie.github.io/posts/design_patterns/open_closed_principle/</link>
      <pubDate>Fri, 10 Jan 2025 09:12:18 +0800</pubDate>
      <guid>http://rextechie.github.io/posts/design_patterns/open_closed_principle/</guid>
      <description>&lt;h2 id=&#34;-导论&#34;&gt;🚏 导论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）&lt;/p&gt;
&lt;p&gt;我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。&lt;/p&gt;
&lt;p&gt;具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。&lt;/p&gt;
&lt;p&gt;开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-场景&#34;&gt;🎬 场景&lt;/h2&gt;
&lt;h3 id=&#34;场景一-公司管理&#34;&gt;场景一：🏢 公司管理&lt;/h3&gt;
&lt;p&gt;现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。&lt;/p&gt;</description>
    </item>
    <item>
      <title>单一职责原则(Single Responsibility Principle)</title>
      <link>http://rextechie.github.io/posts/design_patterns/signle_responsibility_principle/</link>
      <pubDate>Fri, 10 Jan 2025 08:30:28 +0800</pubDate>
      <guid>http://rextechie.github.io/posts/design_patterns/signle_responsibility_principle/</guid>
      <description>&lt;h2 id=&#34;-导论&#34;&gt;🚏 导论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。&lt;/p&gt;
&lt;p&gt;软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;-场景&#34;&gt;🎬 场景&lt;/h2&gt;
&lt;h3 id=&#34;场景一-手机&#34;&gt;场景一：📱 手机&lt;/h3&gt;
&lt;p&gt;现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。&lt;/p&gt;
&lt;p&gt;当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。&lt;/p&gt;
&lt;h3 id=&#34;场景二-俄罗斯方块&#34;&gt;场景二：♦️ 俄罗斯方块&lt;/h3&gt;
&lt;p&gt;俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。&lt;/p&gt;
&lt;p&gt;这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。&lt;/p&gt;</description>
    </item>
    <item>
      <title>策略模式（Strategy Pattern）</title>
      <link>http://rextechie.github.io/posts/design_patterns/strategy_pattern/</link>
      <pubDate>Wed, 08 Jan 2025 21:57:06 +0800</pubDate>
      <guid>http://rextechie.github.io/posts/design_patterns/strategy_pattern/</guid>
      <description>记录《大话设计模式》学习笔记，深入浅出23种设计模式，从实际应用出发理解设计模式的精髓</description>
    </item>
    <item>
      <title>抽象工厂模式（Abstract Factory）</title>
      <link>http://rextechie.github.io/posts/design_patterns/abstract_factory_pattern/</link>
      <pubDate>Tue, 07 Jan 2025 21:19:06 +0800</pubDate>
      <guid>http://rextechie.github.io/posts/design_patterns/abstract_factory_pattern/</guid>
      <description>记录《大话设计模式》学习笔记，深入浅出23种设计模式，从实际应用出发理解设计模式的精髓</description>
    </item>
  </channel>
</rss>
