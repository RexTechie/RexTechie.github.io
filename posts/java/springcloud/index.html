<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring Cloud原生中间件 | RexBlog</title>
<meta name=keywords content="Java,Spring Cloud"><meta name=description content="Spring Cloud中间件的介绍"><meta name=author content="Rex"><link rel=canonical href=http://rextechie.github.io/posts/java/springcloud/><link crossorigin=anonymous href=/assets/css/stylesheet.56d5e73e1a36d8bc0a4f450d156a288bf54a46b72e29e3f236c46370aa489a22.css integrity="sha256-VtXnPho22LwKT0UNFWooi/VKRrcuKePyNsRjcKpImiI=" rel="preload stylesheet" as=style><link rel=icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=icon type=image/png sizes=16x16 href=http://rextechie.github.io/favicon/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=apple-touch-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=mask-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://rextechie.github.io/posts/java/springcloud/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"default",themeVariables:{lineColor:"#fafafa",darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:url" content="http://rextechie.github.io/posts/java/springcloud/"><meta property="og:site_name" content="RexBlog"><meta property="og:title" content="Spring Cloud原生中间件"><meta property="og:description" content="Spring Cloud中间件的介绍"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-09T13:57:23+08:00"><meta property="article:modified_time" content="2025-06-09T13:57:23+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Spring Cloud"><meta property="og:image" content="http://rextechie.github.io/images/profile.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://rextechie.github.io/images/profile.png"><meta name=twitter:title content="Spring Cloud原生中间件"><meta name=twitter:description content="Spring Cloud中间件的介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://rextechie.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Spring Cloud原生中间件","item":"http://rextechie.github.io/posts/java/springcloud/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring Cloud原生中间件","name":"Spring Cloud原生中间件","description":"Spring Cloud中间件的介绍","keywords":["Java","Spring Cloud"],"articleBody":"📝 代码记录\nConsul（服务注册与发现 + 分布式配置管理） 拥有服务治理功能，实现微服务之间的动态注册与发现\n❌不在使用Eureka：1. 停更进维 2. 注册中心独立且和微服务功能解耦\nConsul官网\nSpring官方介绍\n三个注册中心区别 组件名 语言 CAP 服务健康检查 对外暴露接口 Spring Cloud集成 Eureka Java AP 可配支持 HTTP 已集成 Consul Go CP 支持 HTTP/DNS 已集成 Zookeeper Java CP 支持 客户端 已集成 Nacos Java AP 支持 客户端 已集成 CAP 一个分布式系统最多只能同时满足其中的两个属性。\nConsistency: 强一致性，每次读取都能获取到最近一次成功写入的数据。 Availablity: 可用性，每次请求都会在有限时间内返回结果，无论结果是否为最新。 Partition tolerance: 分区容错性，系统在遇到网络分区（节点之间无法通信）时仍能继续运作。（必须有） 经典CAP：\nAP（Eurake）：当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\nCP：当网络分区出现后，为了保证一致性，系统返回错误信息。\n当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性，Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。结论：违背了可用性A的要求，只满足一致性和分区容错，即CP\n使用 ./consul --version # 查看版本号 ./consul agent -dev # 开发模式启动 http://localhost:8500 LoadBalance（服务调用复杂均衡） 负载均衡：平摊请求，减少服务器压力\nSpring-cloud-starter-loadbalancer：spring官方提供的客户端负载均衡器，在SpringCloud-commons中，用来替代以前的Ribbon，支持RestTemplate、Web Flux。\n客户端与服务器端负载均衡区别：服务器端如Nginx，将客户端发起的请求到通过服务器端部署的Nginx，转发到各个服务器上。LoadBlance本地负载均衡，调用微服务接口时，在注册中心上获取信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用。\nSpring官方介绍\n负载均衡算法 实现ReactiveLoadBalancer接口，默认使用的是RoundRobinLoadBalancer。\n官方对负载均衡算法的介绍\nRoundRobinLoadBalancer: 轮询 RandomLoadBalancer: 随机 OpenFeign（服务调用复杂均衡） Feign是一个声明式web服务客户端，用来替代RestTemplate，只需创建一个Rest接口并在该接口上添加注解@FeignClient。\nOpenFeign基本上就是当前微服务之间调用的事实标准。\n可以结合LoadBalancer实现负载均衡，结合Sentinel实现熔断降级。\nSpring官方介绍 Github\n超时控制 超时控制说明\nconnectTimeout: 连接超时时间 readTimeout: 请求处理超时时间，默认超时时间是60s 重试机制 重试机制说明\n默认情况下会创建Retry.NEVER_RETRY类型的Retry的bean，这将禁用重试，这种重试行为与Feign默认行为不同，他会自动重试IOExceptions，将它们视为网络相关的瞬态异常，以及从ErrorDecoder抛出的任何RetryableException。\n默认HTTPClient修改 默认HTTPClient修改说明\n如果不做特殊配置，OpenFeign默认使用JDK自带的HttpURLConnection发送HTTP请求，\n由于默认HttpURLConnection没有连接池、性能和效率比较低 ，如果采用默认，无法发挥最大性能，故使用Apach的HTTPClient 5替换默认HTTPURLConnection。\n⚠️注意：httpclient的版本对齐\n请求/响应压缩 请求/响应压缩说明\nSpring Cloud OpenFeign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。\n日志打印功能 日志打印功能说明\nFeign 提供了日志打印功能，我们可以通过配置来调整日志级别，\n日志级别：\nNONE：默认的，不显示任何日志； BASIC：仅记录请求方法、URL、响应状态码及执行时间； HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息； FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据 CircuitBreaker（断路器） ⚠️较为繁琐，资料少，不适合自学，面试必考\n解决服务雪崩问题，对于有问题的节点，快速熔断（快速返回失败处理或者返回默认兜底数据【服务降级】）\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n当一个组件或服务出现故障时，CircuitBreaker会迅速切换到开放OPEN状态(保险丝跳闸断电)，阻止请求发送到该组件或服务从而避免更多的请求发送到该组件或服务。这可以减少对该组件或服务的负载，防止该组件或服务进一步崩溃，并使整个系统能够继续正常运行。同时，CircuitBreaker还可以提高系统的可用性和健壮性，因为它可以在分布式系统的各个组件之间自动切换，从而避免单点故障的问题。\nSpring官方介绍\nSpring Cloud提供的两个实现类：Resilience4j、Spring Retry\nResilience4j Resilience4j官网\nResilience4j 是一个轻量级的容错库，专为函数式编程设计。Resilience4j 提供了高阶函数（装饰器），可以增强任何函数式接口、lambda 表达式或方法引用，添加断路器、速率限制器、重试或舱壁。您可以在任何函数式接口、lambda 表达式或方法引用上堆叠多个装饰器。优点是可以自由选择所需的装饰器，而不需要其他任何东西。\n断路（Circuit Breaker） 断路器状态 OPEN CLOSED HALF_OPEN DISABLED(特殊状态) FORCED_OPEN(特殊状态) 3大状态之间的转换 当熔断器关闭时，所有请求都会通过熔断器 失败率超过设定的阈值，熔断器就会从CLOSED转到OPEN，这时所有的请求都会被拒绝 当经过一段时间后，熔断器会从OPEN变为HALF_OPEN，这时有一定数量的请求会被放入，并重新计算失败率 如果失败率超过阈值，则变为OPEN状态，如果失败率低于阈值，则变为CLOSED状态 断路器使用滑动窗口来存储和统计调用的结果 基于访问数量的滑动窗口：统计了最近N次调用的返回结果 基于时间的滑动窗口：统计了最近N秒的调用返回结果 特殊状态 这两个状态不会生成熔断时间，并且不回记录事件的成功或失败 退出这两个状态的唯一方法是触发状态转换或者熔断器 配置 failure-rate-threshold 以百分比配置失败率峰值 sliding-window-type 断路器的滑动窗口期类型: 基于“次数”（COUNT_BASED）、“时间”（TIME_BASED）进行熔断，默认是COUNT_BASED。 sliding-window-size 若COUNT_BASED，则N次调用中有failure-rate-threshold%失败（即5次）打开熔断断路器；若为TIME_BASED则，此时还有额外的两个设置属性，含义为：在N秒内（sliding-window-size）100%（slow-call-rate-threshold）的请求超过N秒（slow-call-duration-threshold）打开断路器。 slowCallRateThreshold 以百分比的方式配置，断路器把调用时间大于slowCallDurationThreshold的调用视为慢调用，当慢调用比例大于等于峰值时，断路器开启，并进入服务降级。 slowCallDurationThreshold 配置调用时间的峰值，高于该峰值的视为慢调用。 permitted-number-of-calls-in-half-open-state 运行断路器在HALF_OPEN状态下时进行N次调用，如果故障或慢速调用仍然高于阈值，断路器再次进入打开状态。 minimum-number-of-calls 在每个滑动窗口期样本数，配置断路器计算错误率或者慢调用率的最小调用数。比如设置为5意味着，在计算故障率之前，必须至少调用5次。如果只记录了4次，即使4次都失败了，断路器也不会进入到打开状态。 wait-duration-in-open-state 从OPEN到HALF_OPEN状态需要等待的时间 例子：\n6次访问中当执行方法的失败率达到50%时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。\n等待5秒后，CircuitBreaker将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。\n如还是异常CircuitBreaker将重新进入开启OPEN状态；如正常将进入关闭CLOSE闭合状态恢复正常处理请求。\nfailure-rate-threshold: 50 # 设置50%的失败率阈值，超过失败请求百分比CircuitBreaker变为open sliding-window-type: COUNT_BASED # 滑动窗口的类型 sliding-window-size: 6 # 滑动窗口的大小，单位为请求数 minimum-number-of-calls: 6 # 断路器计算失败率或慢调用之前所需的最小样本（每个滑动窗口周期） automatic-transition-from-open-to-half-open-enabled: true # 是否启用自动从开启到半开启状态，默认值为false wait-duration-in-open-state: 5s # 从OPEN到HALF_OPEN状态的等待时间 permitted-number-of-calls-in-half-open-state: 2 # 半开状态允许的最大请求数，默认值为10. failure-rate-threshold: 50 # 设置50%的失败率阈值，超过失败请求百分比CircuitBreaker变为open slow-call-duration-threshold: 2s # 慢调用时间阈值，高于此时间的调用将被视为慢调用并增加调用比例。 slow-call-rate-threshold: 30 # 慢调用百分比阈值，超过此百分比的慢调用将触发断路器。 sliding-window-type: TIME_BASED sliding-window-size: 2 # 滑动窗口的大小配置，配置TIME_BASED表示2秒 minimum-number-of-calls: 2 # 断路器计算失败率或慢调用之前所需的最小样本（每个滑动窗口周期） permitted-number-of-calls-in-half-open-state: 2 # 半开状态允许的最大请求数，默认值为10. wait-duration-in-open-state: 5s # 从OPEN到HALF_OPEN状态的等待时间 record-exceptions: - java.lang.Exception 舱壁隔离（Bulkhead） 依赖隔离\u0026负载保护：用来限制对于下游服务的最大并发的限制\n舱壁隔离说明\n两种隔离方式 信号量舱壁（SemaphoreBulkhead）： 当信号量有空闲时，进入系统的请求会直接获取信号量并开始业务处理。 当信号量全备占用时，接下来的请求将会进入阻塞状态，SemaphoreBulkhead提供了一个阻塞计时器 如果阻塞状态的请求在阻塞计时内无法获取到信号量则系统会拒绝这些请求。 若请求在阻塞计时内获取到了信号量，那将直接获取信号量并执行相应的业务处理 FixedThreadPoolBulkhead使用了有界队列和固定大小线程池 当线程池中存在空闲时，则此时进入系统的请求将直接进入线程池开启新线程或使用空闲线程来处理请求 当线程中无空闲时，接下来的请求进入等待队列 若等待队列仍然无剩余空间时接下来的请求将直接被拒绝 在队列中的请求等待线程池出现空闲时，将进入线程池进行业务处理 另，ThreadPoolBulkhead只对CompletableFuture方法有效，所以必须创建返回CompletableFuture类型的方法 速率限制（Rate Limiter） 速率限制说明\n限流算法 漏斗算法（Leaky Bucket） 一个固定容量的漏桶，按照设定常量固定速率流出水滴，类似医院打吊针，不管你源头流量多大，我设定匀速流出。 如果流入水滴超出了桶的容量，则流入的水滴将会溢出了(被丢弃)，而漏桶容量是不变的。 缺点：对于存在突发特性的流量来说缺乏效率。 令牌桶算法（Token Bucket） Spring Cloud 默认使用的算法 当用户发起请求，先判断桶空不空 令牌桶算法会匀速的添加令牌至令牌桶中，桶可容纳令牌的数量是有限的。 用户每次发起请求，先检查桶是否为空。若桶空，则丢弃请求；若桶不空，则申请获得令牌，获得令牌则可排队让处理器处理当前请求 滚动时间窗口算法（Tumbling time window） 允许固定数量的请求进入(比如1秒取4个数据相加，超过25值就over)超过数量就拒绝或者排队，等下一个时间段进入。 由于是在一个时间间隔内进行限制，如果用户在上个时间间隔结束前请求（但没有超过限制），同时在当前时间间隔刚开始请求（同样没超过限制），在各自的时间间隔内，这些请求都是正常的。 缺点：间隔临界的一段时间内的请求就会超过系统限制，可能导致系统被压垮。 滑动时间窗口算法（Sliding time window） 滑动窗口算法是把固定时间片进行划分并且随着时间移动，移动方式为开始时间点变为时间列表中的第2个时间点，结束时间点增加一个时间点。 不断重复，通过这种方式可以巧妙的避开计数器的临界点的问题。 Sleuth(Micrometer) + Zipkin（分布式链路追踪） 分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。\n⚠️ Sleuth停更进维， Sleuth替代方案Micrometer\nMicrometer官方文档\n分布式链路追踪原理 两个关键id：Track Id（链路id）、Span Id（节点id）、Parent Id（父级节点id，Span Id）\n主要通过Span Id记录整条链路\nDashboard ZipKin：由Twitter公司开源，开放源代码分布式的跟踪系統，用于收集服务的定时数据，以解决微服务架构中的延迟问 题，包括：数据的收集、存储、查找和展现。结合spring-cloud-sleuth使用较为简单，集成方便，但是功能较 简单。 Cat：由大众点评开源，基于Java开发的实时应用监控千台，包括实时应用监控，业务监控。集成方案是通过代码埋 点的方式来实现监控，比如：拦截器，过滤器等。对代码的侵入性很大，集成成本较高。风险较大。 Pinpoint：Pinpoint是一款开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能 强大，接入端无代码侵入。 Skywalking： SkyWalking是国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多 种插件，UI功能较强，接入端无代码侵入。 整合Micrometer Tracing 由于Micrometer Tracing是一个门面工具自身并没有实现完整的链路追踪系统，具体的链路追踪另外需要引入的是第三方链路追踪系统的依赖：\nmicrometer-tracing-bom 导入链路追踪版本中心，体系化说明 micrometer-tracing 指标追踪 micrometer-tracing-bridge-brave 一个Micrometer模块，用于与分布式跟踪工具 Brave 集成，以收集应用程序的分布式跟踪数据。Brave是一个开源的分布式跟踪工具，它可以帮助用户在分布式系统中跟踪请求的流转，它使用一种称为\"跟踪上下文\"的机制，将请求的跟踪信息存储在请求的头部，然后将请求传递给下一个服务。在整个请求链中，Brave会将每个服务处理请求的时间和其他信息存储到跟踪数据中，以便用户可以了解整个请求的路径和性能。 micrometer-observation 一个基于度量库 Micrometer的观测模块，用于收集应用程序的度量数据。 feign-micrometer 一个Feign HTTP客户端的Micrometer模块，用于收集客户端请求的度量数据。 zipkin-reporter-brave 一个用于将 Brave 跟踪数据报告到Zipkin 跟踪系统的库。 补充包：spring-boot-starter-actuator SpringBoot框架的一个模块用于监视和管理应用程序 Gateway（服务网关 ） 以前都是用Zuul，但是Zuul更新太水了，Spring Cloud 自己研发了Gateway替代Zuul\nSpring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发(路由)到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。Spring Cloud Gateway本身也是一个微服务，需要注册进服务注册中心。\nSpring官方介绍\n三大核心 路由（Route）：网关的基本构建块。它由一个ID、一个目标URI、一组断言和一组过滤器定义。如果断言为True，则匹配路由。 断言（Predicate）：参考的是Java8中的java.util.function.Predicate, 允许匹配HTTP请求中的任何内容，例如头或参数。如果请求与断言相匹配则进行路由。 过滤器（Filter）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 Gateway工作流程 工作流程说明\n客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(Pre)或之后(Post)执行业务逻辑。\n在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等;\n在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。\n核心：路由转发 + 断言判断 + 执行过滤器链\nRoute以微服务名 - 动态获取服务URI 在配置route的uri时使用 lb://服务名 即可\nPredicate断言 Predicate断言说明\nSpring Cloud中Gateway有一个RoutePredictFactory，通过RoutePredicate工厂类可以创建Predict对象，Predict对象用于Route的匹配。Spring Cloud Gateway中包含多个内置的Route Predicate Factories：After、Before、Between、Cookie、Header、Host、Method、Path、Query、ReadBody、RemoteAddr、XForwardedRemoteAddr、Weight、CloudFoundryRouteService，当然也可以自定义。\nFilter过滤 Filter过滤说明\n功能上类似SpringMVC里的拦截器Interceptor，Servlet里的过滤器\n“pre\"和\"post\"分别会在请求被执行前调用和被执行后调用，用来修改请求和响应信息\n作用：请求鉴权、异常处理、记录接口调用时长统计\n过滤器分类\n单一内置过滤器 自定义过滤器 ","wordCount":"408","inLanguage":"en","image":"http://rextechie.github.io/images/profile.png","datePublished":"2025-06-09T13:57:23+08:00","dateModified":"2025-06-09T13:57:23+08:00","author":{"@type":"Person","name":"Rex"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://rextechie.github.io/posts/java/springcloud/"},"publisher":{"@type":"Organization","name":"RexBlog","logo":{"@type":"ImageObject","url":"http://rextechie.github.io/favicon/favicon_32x32.png"}}}</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js crossorigin=anonymous></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})'></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://rextechie.github.io/ accesskey=h title="🏘️Home (Alt + H)"><img src=http://rextechie.github.io/favicon/favicon_32x32.png alt aria-label=logo height=35>🏘️Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://rextechie.github.io/posts/ title="📚 Posts"><span>📚 Posts</span></a></li><li><a href=http://rextechie.github.io/archives/ title="📅 Archives"><span>📅 Archives</span></a></li><li><a href=http://rextechie.github.io/search/ title="🔍 Search (Alt + /)" accesskey=/><span>🔍 Search</span></a></li><li><a href=http://rextechie.github.io/categories/ title="📂 Categories"><span>📂 Categories</span></a></li><li><a href=http://rextechie.github.io/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=http://rextechie.github.io/about/ title="📝 About"><span>📝 About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://rextechie.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://rextechie.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Spring Cloud原生中间件</h1><div class=post-description>Spring Cloud中间件的介绍</div><div class=post-meta><span title='2025-06-09 13:57:23 +0800 +0800'>June 9, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;408 words&nbsp;·&nbsp;Rex&nbsp;|&nbsp;<a href=https://github.com/RexTechie/RexTechie.github.io/blob/main/content/posts/java/springcloud.md rel="noopener noreferrer" target=_blank>修改</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#consul服务注册与发现--分布式配置管理>Consul（服务注册与发现 + 分布式配置管理）</a><ul><li><a href=#三个注册中心区别>三个注册中心区别</a></li><li><a href=#使用>使用</a></li></ul></li><li><a href=#loadbalance服务调用复杂均衡>LoadBalance（服务调用复杂均衡）</a><ul><li><a href=#负载均衡算法>负载均衡算法</a></li></ul></li><li><a href=#openfeign服务调用复杂均衡>OpenFeign（服务调用复杂均衡）</a><ul><li><a href=#超时控制>超时控制</a></li><li><a href=#重试机制>重试机制</a></li><li><a href=#默认httpclient修改>默认HTTPClient修改</a></li><li><a href=#请求响应压缩>请求/响应压缩</a></li><li><a href=#日志打印功能>日志打印功能</a></li></ul></li><li><a href=#circuitbreaker断路器>CircuitBreaker（断路器）</a><ul><li><a href=#resilience4j>Resilience4j</a></li></ul></li><li><a href=#sleuthmicrometer--zipkin分布式链路追踪>Sleuth(Micrometer) + Zipkin（分布式链路追踪）</a><ul><li><a href=#分布式链路追踪原理>分布式链路追踪原理</a></li><li><a href=#dashboard>Dashboard</a></li><li><a href=#整合micrometer-tracing>整合Micrometer Tracing</a></li></ul></li><li><a href=#gateway服务网关->Gateway（服务网关 ）</a><ul><li><a href=#三大核心>三大核心</a></li><li><a href=#gateway工作流程>Gateway工作流程</a></li><li><a href=#route以微服务名---动态获取服务uri>Route以微服务名 - 动态获取服务URI</a></li><li><a href=#predicate断言>Predicate断言</a></li><li><a href=#filter过滤>Filter过滤</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>📝 <a href=https://github.com/RexTechie/cloud2024>代码记录</a></p><h2 id=consul服务注册与发现--分布式配置管理>Consul（服务注册与发现 + 分布式配置管理）<a hidden class=anchor aria-hidden=true href=#consul服务注册与发现--分布式配置管理>#</a></h2><blockquote><p>拥有服务治理功能，实现微服务之间的动态注册与发现</p><p>❌不在使用Eureka：1. 停更进维 2. 注册中心独立且和微服务功能解耦</p></blockquote><p><a href=https://developer.hashicorp.com/consul>Consul官网</a></p><p><a href=http://spring.io/projects/spring-cloud-consul>Spring官方介绍</a></p><h3 id=三个注册中心区别>三个注册中心区别<a hidden class=anchor aria-hidden=true href=#三个注册中心区别>#</a></h3><table><thead><tr><th>组件名</th><th>语言</th><th>CAP</th><th>服务健康检查</th><th>对外暴露接口</th><th>Spring Cloud集成</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>AP</td><td>可配支持</td><td>HTTP</td><td>已集成</td></tr><tr><td>Consul</td><td>Go</td><td>CP</td><td>支持</td><td>HTTP/DNS</td><td>已集成</td></tr><tr><td>Zookeeper</td><td>Java</td><td>CP</td><td>支持</td><td>客户端</td><td>已集成</td></tr><tr><td>Nacos</td><td>Java</td><td>AP</td><td>支持</td><td>客户端</td><td>已集成</td></tr></tbody></table><h4 id=cap>CAP<a hidden class=anchor aria-hidden=true href=#cap>#</a></h4><blockquote><p>一个分布式系统最多只能同时满足其中的两个属性。</p></blockquote><ul><li>Consistency: 强一致性，每次读取都能获取到最近一次成功写入的数据。</li><li>Availablity: 可用性，每次请求都会在有限时间内返回结果，无论结果是否为最新。</li><li>Partition tolerance: 分区容错性，系统在遇到网络分区（节点之间无法通信）时仍能继续运作。（必须有）</li></ul><p>经典CAP：</p><ul><li><p>AP（Eurake）：当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</p><p><img alt=CAP_AP loading=lazy src=/images/20250612214547.png></p></li><li><p>CP：当网络分区出现后，为了保证一致性，系统返回错误信息。</p><p><img alt=CAP_CP loading=lazy src=/images/20250612214611.png></p></li></ul><p>当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性结论：违背了一致性C的要求，只满足可用性和分区容错，即AP</p><p>当网络分区出现后，为了保证一致性，<strong>就必须拒接请求</strong>，否则无法保证一致性，Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。结论：违背了可用性A的要求，只满足一致性和分区容错，即CP</p><h3 id=使用>使用<a hidden class=anchor aria-hidden=true href=#使用>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>./consul --version <span class=c1># 查看版本号</span>
</span></span><span class=line><span class=cl>./consul agent -dev <span class=c1># 开发模式启动 http://localhost:8500</span>
</span></span></code></pre></div><h2 id=loadbalance服务调用复杂均衡>LoadBalance（服务调用复杂均衡）<a hidden class=anchor aria-hidden=true href=#loadbalance服务调用复杂均衡>#</a></h2><blockquote><p>负载均衡：平摊请求，减少服务器压力</p><p>Spring-cloud-starter-loadbalancer：spring官方提供的客户端负载均衡器，在SpringCloud-commons中，用来替代以前的Ribbon，支持RestTemplate、Web Flux。</p><p>客户端与服务器端负载均衡区别：服务器端如Nginx，将客户端发起的请求到通过服务器端部署的Nginx，转发到各个服务器上。LoadBlance本地负载均衡，调用微服务接口时，在注册中心上获取信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用。</p></blockquote><p><a href=https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/loadbalancer.html>Spring官方介绍</a></p><h3 id=负载均衡算法>负载均衡算法<a hidden class=anchor aria-hidden=true href=#负载均衡算法>#</a></h3><p>实现ReactiveLoadBalancer接口，默认使用的是RoundRobinLoadBalancer。</p><p><a href=https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/loadbalancer.html#switching-between-the-load-balancing-algorithms>官方对负载均衡算法的介绍</a></p><ul><li>RoundRobinLoadBalancer: 轮询</li><li>RandomLoadBalancer: 随机</li></ul><h2 id=openfeign服务调用复杂均衡>OpenFeign（服务调用复杂均衡）<a hidden class=anchor aria-hidden=true href=#openfeign服务调用复杂均衡>#</a></h2><blockquote><p>Feign是一个声明式web服务客户端，用来替代RestTemplate，只需创建一个Rest接口并在该接口上添加注解@FeignClient。</p><p>OpenFeign基本上就是当前微服务之间调用的事实标准。</p><p>可以结合LoadBalancer实现负载均衡，结合Sentinel实现熔断降级。</p></blockquote><p><a href=https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html>Spring官方介绍</a> <a href=https://github.com/spring-cloud/spring-cloud-openfeign>Github</a></p><h3 id=超时控制>超时控制<a hidden class=anchor aria-hidden=true href=#超时控制>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html#timeout-handling>超时控制说明</a></p><ul><li>connectTimeout: 连接超时时间</li><li>readTimeout: 请求处理超时时间，默认超时时间是60s</li></ul><h3 id=重试机制>重试机制<a hidden class=anchor aria-hidden=true href=#重试机制>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html#spring-cloud-feign-overriding-defaults>重试机制说明</a></p><p>默认情况下会创建Retry.NEVER_RETRY类型的Retry的bean，这将禁用重试，这种重试行为与Feign默认行为不同，他会自动重试IOExceptions，将它们视为网络相关的瞬态异常，以及从ErrorDecoder抛出的任何RetryableException。</p><h3 id=默认httpclient修改>默认HTTPClient修改<a hidden class=anchor aria-hidden=true href=#默认httpclient修改>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html#spring-cloud-feign-overriding-defaults>默认HTTPClient修改说明</a></p><p>如果不做特殊配置，OpenFeign默认使用JDK自带的HttpURLConnection发送HTTP请求，</p><p>由于默认HttpURLConnection没有连接池、性能和效率比较低 ，如果采用默认，无法发挥最大性能，故使用Apach的HTTPClient 5替换默认HTTPURLConnection。</p><p>⚠️注意：httpclient的版本对齐</p><h3 id=请求响应压缩>请求/响应压缩<a hidden class=anchor aria-hidden=true href=#请求响应压缩>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html#feign-request-response-compression>请求/响应压缩说明</a></p><p>Spring Cloud OpenFeign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。</p><h3 id=日志打印功能>日志打印功能<a hidden class=anchor aria-hidden=true href=#日志打印功能>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-openfeign/reference/spring-cloud-openfeign.html#feign-logging>日志打印功能说明</a></p><p>Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，</p><p>日志级别：</p><ul><li>NONE：默认的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</li><li>HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；</li><li>FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据</li></ul><h2 id=circuitbreaker断路器>CircuitBreaker（断路器）<a hidden class=anchor aria-hidden=true href=#circuitbreaker断路器>#</a></h2><p>⚠️较为繁琐，资料少，不适合自学，面试必考</p><blockquote><p>解决服务雪崩问题，对于有问题的节点，快速熔断（快速返回失败处理或者返回默认兜底数据【服务降级】）</p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><p>当一个组件或服务出现故障时，CircuitBreaker会迅速切换到开放OPEN状态(保险丝跳闸断电)，阻止请求发送到该组件或服务从而避免更多的请求发送到该组件或服务。这可以减少对该组件或服务的负载，防止该组件或服务进一步崩溃，并使整个系统能够继续正常运行。同时，CircuitBreaker还可以提高系统的可用性和健壮性，因为它可以在分布式系统的各个组件之间自动切换，从而避免单点故障的问题。</p></blockquote><p><a href=https://spring.io/projects/spring-cloud-circuitbreaker>Spring官方介绍</a></p><p>Spring Cloud提供的两个实现类：Resilience4j、Spring Retry</p><h3 id=resilience4j>Resilience4j<a hidden class=anchor aria-hidden=true href=#resilience4j>#</a></h3><p><a href=https://github.com/resilience4j/resilience4j>Resilience4j官网</a></p><blockquote><p>Resilience4j 是一个轻量级的容错库，专为函数式编程设计。Resilience4j 提供了高阶函数（装饰器），可以增强任何函数式接口、lambda 表达式或方法引用，添加断路器、速率限制器、重试或舱壁。您可以在任何函数式接口、lambda 表达式或方法引用上堆叠多个装饰器。优点是可以自由选择所需的装饰器，而不需要其他任何东西。</p></blockquote><h4 id=断路circuit-breaker>断路（Circuit Breaker）<a hidden class=anchor aria-hidden=true href=#断路circuit-breaker>#</a></h4><h5 id=断路器状态>断路器状态<a hidden class=anchor aria-hidden=true href=#断路器状态>#</a></h5><ul><li>OPEN</li><li>CLOSED</li><li>HALF_OPEN</li><li>DISABLED(特殊状态)</li><li>FORCED_OPEN(特殊状态)</li></ul><h5 id=3大状态之间的转换>3大状态之间的转换<a hidden class=anchor aria-hidden=true href=#3大状态之间的转换>#</a></h5><p><img alt=官方状态转换图 loading=lazy src=https://files.readme.io/39cdd54-state_machine.jpg></p><ul><li>当熔断器关闭时，所有请求都会通过熔断器<ul><li>失败率超过设定的阈值，熔断器就会从CLOSED转到OPEN，这时所有的请求都会被拒绝</li><li>当经过一段时间后，熔断器会从OPEN变为HALF_OPEN，这时有一定数量的请求会被放入，并重新计算失败率</li><li>如果失败率超过阈值，则变为OPEN状态，如果失败率低于阈值，则变为CLOSED状态</li></ul></li><li>断路器使用滑动窗口来存储和统计调用的结果<ul><li>基于访问数量的滑动窗口：统计了最近N次调用的返回结果</li><li>基于时间的滑动窗口：统计了最近N秒的调用返回结果</li></ul></li><li>特殊状态<ul><li>这两个状态不会生成熔断时间，并且不回记录事件的成功或失败</li><li>退出这两个状态的唯一方法是触发状态转换或者熔断器</li></ul></li></ul><h5 id=配置>配置<a hidden class=anchor aria-hidden=true href=#配置>#</a></h5><table><thead><tr><th><strong>failure-rate-threshold</strong></th><th><strong>以百分比配置失败率峰值</strong></th></tr></thead><tbody><tr><td><strong>sliding-window-type</strong></td><td><strong>断路器的滑动窗口期类型: 基于“次数”（COUNT_BASED）、“时间”（TIME_BASED）进行熔断，默认是COUNT_BASED。</strong></td></tr><tr><td><strong>sliding-window-size</strong></td><td><strong>若COUNT_BASED，则N次调用中有failure-rate-threshold%失败（即5次）打开熔断断路器；若为TIME_BASED则，此时还有额外的两个设置属性，含义为：在N秒内（sliding-window-size）100%（slow-call-rate-threshold）的请求超过N秒（slow-call-duration-threshold）打开断路器。</strong></td></tr><tr><td><strong>slowCallRateThreshold</strong></td><td><strong>以百分比的方式配置，断路器把调用时间大于slowCallDurationThreshold的调用视为慢调用，当慢调用比例大于等于峰值时，断路器开启，并进入服务降级。</strong></td></tr><tr><td><strong>slowCallDurationThreshold</strong></td><td><strong>配置调用时间的峰值，高于该峰值的视为慢调用。</strong></td></tr><tr><td><strong>permitted-number-of-calls-in-half-open-state</strong></td><td><strong>运行断路器在HALF_OPEN状态下时进行N次调用，如果故障或慢速调用仍然高于阈值，断路器再次进入打开状态。</strong></td></tr><tr><td><strong>minimum-number-of-calls</strong></td><td><strong>在每个滑动窗口期样本数，配置断路器计算错误率或者慢调用率的最小调用数。比如设置为5意味着，在计算故障率之前，必须至少调用5次。如果只记录了4次，即使4次都失败了，断路器也不会进入到打开状态。</strong></td></tr><tr><td><strong>wait-duration-in-open-state</strong></td><td><strong>从OPEN到HALF_OPEN状态需要等待的时间</strong></td></tr></tbody></table><p>例子：</p><p>6次访问中当执行方法的失败率达到50%时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。</p><p>等待5秒后，CircuitBreaker将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。</p><p>如还是异常CircuitBreaker将重新进入开启OPEN状态；如正常将进入关闭CLOSE闭合状态恢复正常处理请求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>failure-rate-threshold</span><span class=p>:</span><span class=w> </span><span class=m>50</span><span class=w> </span><span class=c># 设置50%的失败率阈值，超过失败请求百分比CircuitBreaker变为open</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>sliding-window-type</span><span class=p>:</span><span class=w> </span><span class=l>COUNT_BASED</span><span class=w> </span><span class=c># 滑动窗口的类型</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>sliding-window-size</span><span class=p>:</span><span class=w> </span><span class=m>6</span><span class=w> </span><span class=c># 滑动窗口的大小，单位为请求数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>minimum-number-of-calls</span><span class=p>:</span><span class=w> </span><span class=m>6</span><span class=w> </span><span class=c># 断路器计算失败率或慢调用之前所需的最小样本（每个滑动窗口周期）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>automatic-transition-from-open-to-half-open-enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w> </span><span class=c># 是否启用自动从开启到半开启状态，默认值为false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>wait-duration-in-open-state</span><span class=p>:</span><span class=w> </span><span class=l>5s</span><span class=w> </span><span class=c># 从OPEN到HALF_OPEN状态的等待时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>permitted-number-of-calls-in-half-open-state</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w> </span><span class=c># 半开状态允许的最大请求数，默认值为10.</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>failure-rate-threshold</span><span class=p>:</span><span class=w> </span><span class=m>50</span><span class=w> </span><span class=c># 设置50%的失败率阈值，超过失败请求百分比CircuitBreaker变为open</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>slow-call-duration-threshold</span><span class=p>:</span><span class=w> </span><span class=l>2s</span><span class=w> </span><span class=c># 慢调用时间阈值，高于此时间的调用将被视为慢调用并增加调用比例。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>slow-call-rate-threshold</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w> </span><span class=c># 慢调用百分比阈值，超过此百分比的慢调用将触发断路器。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>sliding-window-type</span><span class=p>:</span><span class=w> </span><span class=l>TIME_BASED</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>sliding-window-size</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w> </span><span class=c># 滑动窗口的大小配置，配置TIME_BASED表示2秒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>minimum-number-of-calls</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w> </span><span class=c># 断路器计算失败率或慢调用之前所需的最小样本（每个滑动窗口周期）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>permitted-number-of-calls-in-half-open-state</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w> </span><span class=c># 半开状态允许的最大请求数，默认值为10.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>wait-duration-in-open-state</span><span class=p>:</span><span class=w> </span><span class=l>5s</span><span class=w> </span><span class=c># 从OPEN到HALF_OPEN状态的等待时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>record-exceptions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>java.lang.Exception</span><span class=w>
</span></span></span></code></pre></div><h4 id=舱壁隔离bulkhead>舱壁隔离（Bulkhead）<a hidden class=anchor aria-hidden=true href=#舱壁隔离bulkhead>#</a></h4><blockquote><p>依赖隔离&负载保护：用来限制对于下游服务的最大并发的限制</p></blockquote><p><a href=https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/core-modules/bulkhead.md>舱壁隔离说明</a></p><h5 id=两种隔离方式>两种隔离方式<a hidden class=anchor aria-hidden=true href=#两种隔离方式>#</a></h5><ul><li>信号量舱壁（SemaphoreBulkhead）：<ul><li>当信号量有空闲时，进入系统的请求会直接获取信号量并开始业务处理。</li><li>当信号量全备占用时，接下来的请求将会进入阻塞状态，SemaphoreBulkhead提供了一个阻塞计时器<ul><li>如果阻塞状态的请求在阻塞计时内无法获取到信号量则系统会拒绝这些请求。</li><li>若请求在阻塞计时内获取到了信号量，那将直接获取信号量并执行相应的业务处理</li></ul></li></ul></li><li>FixedThreadPoolBulkhead使用了有界队列和固定大小线程池<ul><li>当线程池中存在空闲时，则此时进入系统的请求将直接进入线程池开启新线程或使用空闲线程来处理请求</li><li>当线程中无空闲时，接下来的请求进入等待队列<ul><li>若等待队列仍然无剩余空间时接下来的请求将直接被拒绝</li><li>在队列中的请求等待线程池出现空闲时，将进入线程池进行业务处理</li></ul></li><li>另，ThreadPoolBulkhead只对CompletableFuture方法有效，所以必须创建返回CompletableFuture类型的方法</li></ul></li></ul><h4 id=速率限制rate-limiter>速率限制（Rate Limiter）<a hidden class=anchor aria-hidden=true href=#速率限制rate-limiter>#</a></h4><p><a href=https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/core-modules/ratelimiter.md>速率限制说明</a></p><h5 id=限流算法>限流算法<a hidden class=anchor aria-hidden=true href=#限流算法>#</a></h5><ul><li>漏斗算法（Leaky Bucket）<ul><li>一个固定容量的漏桶，按照设定常量固定速率流出水滴，类似医院打吊针，不管你源头流量多大，我设定匀速流出。</li><li>如果流入水滴超出了桶的容量，则流入的水滴将会溢出了(被丢弃)，而漏桶容量是不变的。</li><li>缺点：对于存在突发特性的流量来说缺乏效率。</li></ul></li><li><strong>令牌桶算法（Token Bucket）</strong><ul><li>Spring Cloud 默认使用的算法</li><li>当用户发起请求，先判断桶空不空<ul><li>令牌桶算法会匀速的添加令牌至令牌桶中，桶可容纳令牌的数量是有限的。</li><li>用户每次发起请求，先检查桶是否为空。若桶空，则丢弃请求；若桶不空，则申请获得令牌，获得令牌则可排队让处理器处理当前请求</li></ul></li></ul></li><li>滚动时间窗口算法（Tumbling time window）<ul><li>允许固定数量的请求进入(比如1秒取4个数据相加，超过25值就over)超过数量就拒绝或者排队，等下一个时间段进入。</li><li>由于是在一个时间间隔内进行限制，如果用户在上个时间间隔结束前请求（但没有超过限制），同时在当前时间间隔刚开始请求（同样没超过限制），在各自的时间间隔内，这些请求都是正常的。</li><li>缺点：间隔临界的一段时间内的请求就会超过系统限制，可能导致系统被压垮。</li></ul></li><li><strong>滑动时间窗口算法（Sliding time window）</strong><ul><li>滑动窗口算法是把固定时间片进行划分并且随着时间移动，移动方式为开始时间点变为时间列表中的第2个时间点，结束时间点增加一个时间点。</li><li>不断重复，通过这种方式可以巧妙的避开计数器的临界点的问题。</li></ul></li></ul><h2 id=sleuthmicrometer--zipkin分布式链路追踪>Sleuth(Micrometer) + Zipkin（分布式链路追踪）<a hidden class=anchor aria-hidden=true href=#sleuthmicrometer--zipkin分布式链路追踪>#</a></h2><blockquote><p>分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><p>⚠️ Sleuth停更进维， Sleuth替代方案Micrometer</p></blockquote><p><a href=https://micrometer.io/docs/tracing>Micrometer官方文档</a></p><h3 id=分布式链路追踪原理>分布式链路追踪原理<a hidden class=anchor aria-hidden=true href=#分布式链路追踪原理>#</a></h3><p>两个关键id：Track Id（链路id）、Span Id（节点id）、Parent Id（父级节点id，Span Id）</p><p>主要通过Span Id记录整条链路</p><h3 id=dashboard>Dashboard<a hidden class=anchor aria-hidden=true href=#dashboard>#</a></h3><ul><li><a href=https://zipkin.io/>ZipKin</a>：由Twitter公司开源，开放源代码分布式的跟踪系統，用于收集服务的定时数据，以解决微服务架构中的延迟问
题，包括：数据的收集、存储、查找和展现。结合spring-cloud-sleuth使用较为简单，集成方便，但是功能较
简单。</li><li><a href=https://github.com/dianping/cat>Cat</a>：由大众点评开源，基于Java开发的实时应用监控千台，包括实时应用监控，业务监控。集成方案是通过代码埋
点的方式来实现监控，比如：拦截器，过滤器等。对代码的侵入性很大，集成成本较高。风险较大。</li><li><a href=https://github.com/pinpoint-apm/pinpoint>Pinpoint</a>：Pinpoint是一款开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能
强大，接入端无代码侵入。</li><li><a href=https://skywalking.apache.org/>Skywalking</a>： SkyWalking是国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多
种插件，UI功能较强，接入端无代码侵入。</li></ul><h3 id=整合micrometer-tracing>整合Micrometer Tracing<a hidden class=anchor aria-hidden=true href=#整合micrometer-tracing>#</a></h3><p>由于Micrometer Tracing是一个门面工具自身并没有实现完整的链路追踪系统，具体的链路追踪另外需要引入的是第三方链路追踪系统的依赖：</p><ul><li>micrometer-tracing-bom 导入链路追踪版本中心，体系化说明</li><li>micrometer-tracing 指标追踪</li><li>micrometer-tracing-bridge-brave 一个Micrometer模块，用于与分布式跟踪工具 Brave 集成，以收集应用程序的分布式跟踪数据。Brave是一个开源的分布式跟踪工具，它可以帮助用户在分布式系统中跟踪请求的流转，它使用一种称为"跟踪上下文"的机制，将请求的跟踪信息存储在请求的头部，然后将请求传递给下一个服务。在整个请求链中，Brave会将每个服务处理请求的时间和其他信息存储到跟踪数据中，以便用户可以了解整个请求的路径和性能。</li><li>micrometer-observation 一个基于度量库 Micrometer的观测模块，用于收集应用程序的度量数据。</li><li>feign-micrometer 一个Feign HTTP客户端的Micrometer模块，用于收集客户端请求的度量数据。</li><li>zipkin-reporter-brave 一个用于将 Brave 跟踪数据报告到Zipkin 跟踪系统的库。</li><li>补充包：spring-boot-starter-actuator SpringBoot框架的一个模块用于监视和管理应用程序</li></ul><h2 id=gateway服务网关->Gateway（服务网关 ）<a hidden class=anchor aria-hidden=true href=#gateway服务网关->#</a></h2><blockquote><p>以前都是用Zuul，但是Zuul更新太水了，Spring Cloud 自己研发了Gateway替代Zuul</p><p>Spring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发(路由)到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。Spring Cloud Gateway本身也是一个微服务，需要注册进服务注册中心。</p></blockquote><p><a href=https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-webmvc>Spring官方介绍</a></p><h3 id=三大核心>三大核心<a hidden class=anchor aria-hidden=true href=#三大核心>#</a></h3><ul><li>路由（Route）：网关的基本构建块。它由一个ID、一个目标URI、一组断言和一组过滤器定义。如果断言为True，则匹配路由。</li><li>断言（Predicate）：参考的是Java8中的java.util.function.Predicate, 允许匹配HTTP请求中的任何内容，例如头或参数。如果请求与断言相匹配则进行路由。</li><li>过滤器（Filter）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</li></ul><h3 id=gateway工作流程>Gateway工作流程<a hidden class=anchor aria-hidden=true href=#gateway工作流程>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-webmvc/how-it-works.html>工作流程说明</a></p><p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(Pre)或之后(Post)执行业务逻辑。</p><p>在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等;</p><p>在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p><p>核心：路由转发 + 断言判断 + 执行过滤器链</p><h3 id=route以微服务名---动态获取服务uri>Route以微服务名 - 动态获取服务URI<a hidden class=anchor aria-hidden=true href=#route以微服务名---动态获取服务uri>#</a></h3><p>在配置route的uri时使用 lb://服务名 即可</p><h3 id=predicate断言>Predicate断言<a hidden class=anchor aria-hidden=true href=#predicate断言>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-webflux/request-predicates-factories.html>Predicate断言说明</a></p><p>Spring Cloud中Gateway有一个RoutePredictFactory，通过RoutePredicate工厂类可以创建Predict对象，Predict对象用于Route的匹配。Spring Cloud Gateway中包含多个内置的Route Predicate Factories：After、Before、Between、Cookie、Header、Host、Method、Path、Query、ReadBody、RemoteAddr、XForwardedRemoteAddr、Weight、CloudFoundryRouteService，当然也可以自定义。</p><h3 id=filter过滤>Filter过滤<a hidden class=anchor aria-hidden=true href=#filter过滤>#</a></h3><p><a href=https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway-server-webflux/gatewayfilter-factories.html>Filter过滤说明</a></p><p>功能上类似SpringMVC里的拦截器Interceptor，Servlet里的过滤器</p><p>&ldquo;pre"和"post"分别会在请求被执行前调用和被执行后调用，用来修改请求和响应信息</p><p>作用：请求鉴权、异常处理、记录接口调用时长统计</p><p>过滤器分类</p><ul><li>单一内置过滤器</li><li>自定义过滤器</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://rextechie.github.io/tags/java/>Java</a></li><li><a href=http://rextechie.github.io/tags/spring-cloud/>Spring Cloud</a></li></ul><nav class=paginav><a class=prev href=http://rextechie.github.io/posts/java/springcloudalibaba/><span class=title>« Prev</span><br><span>Spring Cloud Alibaba中间件</span>
</a><a class=next href=http://rextechie.github.io/posts/paper_note/doc_agent/><span class=title>Next »</span><br><span>DocAgent: A Multi-Agent System for Automated Code Documentation Generation</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on x" href="https://x.com/intent/tweet/?text=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6&amp;url=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f&amp;hashtags=Java%2cSpringCloud"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f&amp;title=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6&amp;summary=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6&amp;source=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f&title=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on whatsapp" href="https://api.whatsapp.com/send?text=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6%20-%20http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on telegram" href="https://telegram.me/share/url?text=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6&amp;url=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Spring Cloud原生中间件 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Spring%20Cloud%e5%8e%9f%e7%94%9f%e4%b8%ad%e9%97%b4%e4%bb%b6&u=http%3a%2f%2frextechie.github.io%2fposts%2fjava%2fspringcloud%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=RexTechie/blogcomment issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://rextechie.github.io/>RexBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>