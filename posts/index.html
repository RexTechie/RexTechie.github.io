<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | RexBlog</title>
<meta name=keywords content><meta name=description content="Posts - RexBlog"><meta name=author content="Rex"><link rel=canonical href=http://rextechie.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.56d5e73e1a36d8bc0a4f450d156a288bf54a46b72e29e3f236c46370aa489a22.css integrity="sha256-VtXnPho22LwKT0UNFWooi/VKRrcuKePyNsRjcKpImiI=" rel="preload stylesheet" as=style><link rel=icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=icon type=image/png sizes=16x16 href=http://rextechie.github.io/favicon/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=apple-touch-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=mask-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://rextechie.github.io/posts/index.xml><link rel=alternate hreflang=en href=http://rextechie.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"default",themeVariables:{lineColor:"#fafafa",darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:url" content="http://rextechie.github.io/posts/"><meta property="og:site_name" content="RexBlog"><meta property="og:title" content="Posts"><meta property="og:description" content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://rextechie.github.io/images/profile.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://rextechie.github.io/images/profile.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://rextechie.github.io/posts/"}]}</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js crossorigin=anonymous></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})'></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://rextechie.github.io/ accesskey=h title="🏘️Home (Alt + H)"><img src=http://rextechie.github.io/favicon/favicon_32x32.png alt aria-label=logo height=35>🏘️Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://rextechie.github.io/posts/ title="📚 Posts"><span class=active>📚 Posts</span></a></li><li><a href=http://rextechie.github.io/archives/ title="📅 Archives"><span>📅 Archives</span></a></li><li><a href=http://rextechie.github.io/search/ title="🔍 Search (Alt + /)" accesskey=/><span>🔍 Search</span></a></li><li><a href=http://rextechie.github.io/categories/ title="📂 Categories"><span>📂 Categories</span></a></li><li><a href=http://rextechie.github.io/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=http://rextechie.github.io/about/ title="📝 About"><span>📝 About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://rextechie.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>代码生成相关论文索引</h2></header><div class=entry-content><p>🚏导论 代码生成是指通过机器学习模型生成代码的过程，是自然语言处理和程序生成的结合。代码生成技术在软件开发、自动化测试、代码补全等领域有着广泛的应用。本文将记录代码生成相关的论文笔记，包括代码生成模型、评估指标等内容。
🔍索引 代码生成领域综述 Unifying the Perspectives of NLP and Software Engineering: A Survey on Language Models for Code 代码生成相关模型 MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 代码生成评估指标 Evaluating Large Language Models Trained on Code</p></div><footer class=entry-footer><span title='2025-01-08 21:21:46 +0800 +0800'>January 8, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;46 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 代码生成相关论文索引" href=http://rextechie.github.io/posts/paper_note/code_generate/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式</h2></header><div class=entry-content><p>🚏 导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。
在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。
💻 代码 Java代码实现
🔍 索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 依赖倒置原则(Dependency Inversion Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)
抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)
适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)
观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern)</p></div><footer class=entry-footer><span title='2025-01-07 20:59:11 +0800 +0800'>January 7, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;88 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 设计模式" href=http://rextechie.github.io/posts/design_patterns/design_patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Paper2Code</h2></header><div class=entry-content><p>基本信息 标题: Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 作者: Minju Seo, Jinheon Baek, Seongyun Lee, Sung Ju Hwang等。 作者单位: KAIST, DeepAuto.ai 期刊/会议: ArXiv 发表年份: 2025 DOI: 2504.17192v2 开源地址: Github 关键词: Large Language Models (LLMs), Code Generation（Machine Learning） 研究背景 (Background) 尽管机器学习研究的迅速增长，但相应的代码实施通常无法实现，这使研究人员重现结果并在先前的工作基础上进行劳动密集型。同时，最近的大型语言模型（LLMS）在了解科学文档并生成高质量代码方面表现出色。
研究问题 (Research Questions) 用agent复现机器学习相关的论文方法与实验
核心贡献 (Key Contributions) 提出从科研论文自动生成代码的框架: PaperCoder ​​三阶段工作流程​​：PaperCoder框架将代码生成任务分解为三个结构化的阶段，规划、分析、编码。 构建基准数据集（包含90篇来自ICML、NeurIPS和ICLR 2024的论文） 在PaperBench基准测试中的优异表现：在新发布的PaperBench基准测试中，PaperCoder表现出色，显著优于其他强基线方法。 方法（Methods） 作者引入了PaperCoder，是一种新颖的框架，用于实现研究仓库（论文复现出来的代码仓库）的生成。作者将工作过程建模为M(R) = C，其中M是模型，R是论文，C是代码。受软件开发方法的启发，作者采用了一种结构化的方法，该方法反映了良好的经验验证的软件工程原则，即：规划-分析-实现的工作流程。为了实现这一目标，作者将过程分解为三个阶段：1）规划（Planing）. 2）分析（Analyzing）. 3）编码（Coding）。每个阶段都利用多智能体方案。更加规范化的定义是C = M (P) = M_code(R, P, A)，其中R是论文，P是规划，A是分析。每个部分的生成遵循：P = M_plan(R), A = M_analysis(R, P) and C = M_code(R, P, A)。完整的流程如下图所示：...</p></div><footer class=entry-footer><span title='2025-05-12 13:41:31 +0800 +0800'>May 12, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to Paper2Code" href=http://rextechie.github.io/posts/paper_note/paper2code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving</h2></header><div class=entry-content><p>基本信息 标题: PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving 作者: Mihir Parmar、Xin Liu等 作者单位: Google、Arizona State University 期刊/会议: ArXiv 发表年份: 2025 DOI: 2502.16111 开源地址: 🈚️ 关键词: Agent 研究背景与问题 (Background & Questions) 有效的计划是设计在解决复杂现实世界问题的系统的关键组件。传统的用模板化的方式缺乏通用性。 LLM 可以较好的做一些规划任务，比如用 LLM 在自然语言中做规划可以解决一些代码问题。因此作者考虑增强 LLM 生成计划的能力，并证明其在科学和金融领域下游任务的实用性。
核心贡献 (Key Contributions) 总结本文的主要贡献点：
PlanGEN，一种新颖的、模型无关的、可扩展的多智能体框架，用于增强LLM的自然规划。 在一些复杂规划和推理的 Benchmarks 上达到了 SOTA 级别。 一种基于约束的验证和基于实例级复杂性的推理算法选择的新方法。 PlanGEN LLM Agents PlanGEN 包括三个 大模型 Agent：Constraint Agent、 Verification Agent 和一个 Selection Agent。每个Agent使用现成的 LLM（如：Gemini, GPT）。...</p></div><footer class=entry-footer><span title='2025-03-25 11:52:08 +0800 +0800'>March 25, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving" href=http://rextechie.github.io/posts/paper_note/plangen/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Proxy_pattern</h2></header><div class=entry-content><p>🚏 导论 代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。
代理模式的应用场景
远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指当调用真实的对象时，代理处理另外一些事。 🚦 结构 UML类图 classDiagram class Client{ } class Subject{ &lt;&lt;abstract>> +Request() } class RealSubject{ +Request() } class Proxy{ -realSubject: RealSubject +Request() } Client --> Subject Subject &lt;|.. RealSubject Subject &lt;|.. Proxy 代码实现 Subject类，定义了RealSubject和Proxy的公共接口，这样就在任何使用RealSubject的地方都可以使用Proxy
public class abstract Subject { public abstract void Request(); } RealSUbject类，定义Proxy所代表的真实实体
public class RealSubject extends Subject { @Override public void Request() { System.out.println("真实的请求"); } } Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject相同的接口，这样代理就可以用来代替实体
public class Proxy extends Subject { private RealSubject realSubject; @Override public void Request() { if (realSubject == null) { realSubject = new RealSubject(); } realSubject....</p></div><footer class=entry-footer><span title='2025-01-12 14:26:34 +0800 +0800'>January 12, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;139 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to Proxy_pattern" href=http://rextechie.github.io/posts/design_patterns/proxy_pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>装饰模式（Decorator Pattern）</h2></header><div class=entry-content><p>🚏 导论 装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。当现有目标功能不足的时候，需要增强时，可以考虑使用装饰模式。
装饰模式把每个要装饰的代码放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。
装饰器常在面向切面编程（AOP）中使用，比如日志、事务、权限等功能。
🚦 结构 UML类图 classDiagram class Component{ &lt;&lt;interface>> +operation() } class ConcreteComponent{ +operation() } class Decorator{ &lt;&lt;abstract>> -component: Component +operation() } class ConcreteDecoratorA{ -addedState +operation() } class ConcreteDecoratorB{ +operation() -AddedBehavior() } Component &lt;|-- ConcreteComponent Component &lt;|-- Decorator Decorator o-- Component Decorator &lt;|-- ConcreteDecoratorA Decorator &lt;|-- ConcreteDecoratorB Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。
装饰模式是利用setComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。
基本代码 Component类
public interface Component { void operation(); } ConcreteComponent类
public class ConcreteComponent implements Component { @Override public void operation() { System....</p></div><footer class=entry-footer><span title='2025-01-11 09:01:58 +0800 +0800'>January 11, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;751 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 装饰模式（Decorator Pattern）" href=http://rextechie.github.io/posts/design_patterns/decorator_pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>里氏替换原则(Liskov Substitution Principle)</h2></header><div class=entry-content><p>🚏 导论 里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。
里氏替换原则是Barbara Liskov女士在1988年发表的，A behavioral notion of subtyping, 具体的数学定义如下所示：If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T。用大白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。
由于有里氏替换原则，才使得开放-封闭成为了可能，正是由于子类性的可替换性才使得使用父类类型的模块在无需修改的情况下可以扩展。
🎬 场景 场景一：🐒 动物世界 因为了有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。</p></div><footer class=entry-footer><span title='2025-01-10 09:58:23 +0800 +0800'>January 10, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;47 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 里氏替换原则(Liskov Substitution Principle)" href=http://rextechie.github.io/posts/design_patterns/liskov_substitution_principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>依赖倒转原则(Dependency Inversion Principle)</h2></header><div class=entry-content><p>🚏 导论 依赖倒转原则
A. 高层模块不应该依赖低层模块。两个都应该依赖抽象。
B. 抽象不应该依赖细节。细节应该依赖抽象。
🎬 场景 场景一：📦 修电脑 当电脑出现蓝屏时，通常考虑是否时内存坏了或是内存条与主板接触不良。如果是内存坏了，那么就需要更换内存条，如果是内存条与主板接触不良，那么就需要重新插拔内存条。得益于电脑部件以及相关接口的设计，只需要了解简单的计算机知识，就可以轻松的定位问题并维修电脑了。他们的设计中体现了依赖倒转原则，当然还有其他的原则（单一职责原则、开放-封闭原则）。依赖倒转原则原话是说抽象不应该依赖细节，细节应该依赖于抽象，其实就是面向接口编程，而不是面向实现编程。无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就回出现换内存需要把主板也换了的尴尬。 与修📻收音机相比，修电脑反而要简单。是因为收音机耦合过度了，只要收音机出现故障，不管是没有声音、不能调频，还是有杂音，反正都很难修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难易维护。</p></div><footer class=entry-footer><span title='2025-01-10 09:57:54 +0800 +0800'>January 10, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;13 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 依赖倒转原则(Dependency Inversion Principle)" href=http://rextechie.github.io/posts/design_patterns/dependency_inversion_principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>开放-封闭原则(Open Closed Principle)</h2></header><div class=entry-content><p>🚏 导论 开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。
对于拓展是开放的（Open for extension），对于更改是封闭的（Closed for modiication）
我们在做任何系统的时候都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推到重来。怎样的设计才能让软件在需求变化时，可以相对容易的修改呢？这就是开放-封闭原则要解决的问题。
具体来说，在设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来了，增加一些类，原来的代码能不动则不动。当然，绝对的对修改封闭是不可能的。无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。若猜测失败，要及时的去调整。面对新需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。
🎬 场景 场景一：🏢 公司管理 现要作为老板，给公司制定考勤制度，规定九点上班，不允许迟到。但是有公司骨干，老是迟到。他们也有实际的难处，比如有些人家离公司太远，有些人每天上午要送小孩子上学。需要对他们特殊处理，但不能违反公司的规定。其实迟到不是问题，最主要的是保证8小时的工作量或是完成业绩目标。于是应该改变管理方式，如弹性上班工作制，早到早下班，晚到晚下班，或者每人每月允许三次迟到，迟到者当天下班补时间等等。对市场销售人员可能就更加以业绩为标准，工作时间不固定了。这其实就是对工作时间或业绩成效的修改关闭，而对时间制度拓展的开放。</p></div><footer class=entry-footer><span title='2025-01-10 09:12:18 +0800 +0800'>January 10, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;16 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 开放-封闭原则(Open Closed Principle)" href=http://rextechie.github.io/posts/design_patterns/open_closed_principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>单一职责原则(Single Responsibility Principle)</h2></header><div class=entry-content><p>🚏 导论 单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。
如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。
🎬 场景 场景一：📱 手机 现在的手机都有很多功能（除了打电话、发消息）：听音乐 、玩游戏、 拍照、摄影等等。但是这里的功能，都是基础功能，实际并没有做的特别专。比如听音乐，手机的音质没有专业的音乐播放器好；拍照，手机的像素没有专业的相机好；玩游戏，手机的操作体验没有专业的游戏机好。所以，手机的功能虽然多，但是都是基础功能，没有做的特别专业。大多时候，一件产品简单一些，职责单一一些，或许是更好的选择。
当然，手机的发展有它的特点，而编程时，我们却是要在类的职责分离上多做思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。
场景二：♦️ 俄罗斯方块 俄罗斯方块的实现：俄罗斯方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个小方块。不断绘出和擦掉就形成了动画，所以应该要有画和擦方块的动画。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这些其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。
这里大部分都是一些函数，如果将这些函数都放在一个类里，那么这个类就会变得很大，很难维护并且也很难迁移。可以将这些与游戏逻辑相关的函数（下落、旋转、碰撞判断、移动、堆积）提取出来，这些函数和界面如何表示没有特别大的关系，因为所谓方块无非是一个坐标，方块的下落、旋转、碰撞判断、移动、堆积等都是坐标的变化。因此可以将运行界面和游戏逻辑分开，这样就可以更好的维护和迁移。</p></div><footer class=entry-footer><span title='2025-01-10 08:30:28 +0800 +0800'>January 10, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;17 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 单一职责原则(Single Responsibility Principle)" href=http://rextechie.github.io/posts/design_patterns/signle_responsibility_principle/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://rextechie.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://rextechie.github.io/>RexBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>