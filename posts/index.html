<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | RexBlog</title>
<meta name=keywords content><meta name=description content="Posts - RexBlog"><meta name=author content="Rex"><link rel=canonical href=http://rextechie.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.56d5e73e1a36d8bc0a4f450d156a288bf54a46b72e29e3f236c46370aa489a22.css integrity="sha256-VtXnPho22LwKT0UNFWooi/VKRrcuKePyNsRjcKpImiI=" rel="preload stylesheet" as=style><link rel=icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=icon type=image/png sizes=16x16 href=http://rextechie.github.io/favicon/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=apple-touch-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=mask-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://rextechie.github.io/posts/index.xml><link rel=alternate hreflang=en href=http://rextechie.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"default",themeVariables:{lineColor:"#fafafa",darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:url" content="http://rextechie.github.io/posts/"><meta property="og:site_name" content="RexBlog"><meta property="og:title" content="Posts"><meta property="og:description" content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://rextechie.github.io/images/profile.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://rextechie.github.io/images/profile.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://rextechie.github.io/posts/"}]}</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js crossorigin=anonymous></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})'></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://rextechie.github.io/ accesskey=h title="🏘️Home (Alt + H)"><img src=http://rextechie.github.io/favicon/favicon_32x32.png alt aria-label=logo height=35>🏘️Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://rextechie.github.io/ title=🏘️Home><span>🏘️Home</span></a></li><li><a href=http://rextechie.github.io/posts/ title=📚Posts><span class=active>📚Posts</span></a></li><li><a href=http://rextechie.github.io/archives/ title=📅Archives><span>📅Archives</span></a></li><li><a href=http://rextechie.github.io/search/ title="🔍Search (Alt + /)" accesskey=/><span>🔍Search</span></a></li><li><a href=http://rextechie.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://rextechie.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://rextechie.github.io/about/ title=📝About><span>📝About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://rextechie.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式</h2></header><div class=entry-content><p>🚏导论 设计模式是软件开发中解决常见问题的最佳实践，它们凝聚了多年的工程经验与智慧，是提升代码质量、可维护性和灵活性的关键工具。设计模式通过提供一套通用的解决方案，使得开发人员能够应对不同的需求和挑战，而不必从零开始设计系统架构。
在这部分内容中，我将通过学习经典的《大话设计模式》一书，深入理解和探讨23种设计模式。从实际应用的角度出发，我们不仅关注每种模式的定义和结构，更会探索它们在现实世界中的应用场景。
🔍索引 设计模式的七大原则 单一职责原则(Single Responsibility Principle) 开放-封闭原则(Open Closed Principle) 里氏替换原则(Liskov Substitution Principle) 依赖倒置原则(Dependency Inversion Principle) 接口隔离原则(Interface Segregation Principle) 迪米特法则(Law of Demeter) 合成复用原则(Composite Reuse Principle) 设计模式的三大类 创建性(Creational Pattern)
抽象工厂模式(Abstract Factory Pattern) 建造者模式(Builder Pattern) 工厂方法模式(Factory Method Pattern) 原型模式(Prototype Pattern) 单例模式(Singleton Pattern) 结构性(Structural Pattern)
适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern) 组合模式(Composite Pattern) 装饰模式(Decorator Pattern) 外观模式(Facade Pattern) 享元模式(Flyweight Pattern) 代理模式(Proxy Pattern) 行为型(Behavioral Pattern)
观察者模式(Observer Pattern) 模板模式(Template Pattern) 命令模式(Command Pattern) 状态模式(State Pattern) 职责链模式(Chain of Responsibility Pattern) 解释器模式(Interpreter Pattern) 中介者模式(Mediator Pattern) 访问者模式(Visitor Pattern) 策略模式(Strategy Pattern) 备忘录模式(Memento Pattern) 迭代器模式(Iterator Pattern)</p></div><footer class=entry-footer><span title='2025-01-07 20:59:11 +0800 +0800'>January 7, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;83 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 设计模式" href=http://rextechie.github.io/posts/design_patterns/design_patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>抽象工厂模式（Abstract Factory）</h2></header><div class=entry-content><p>🚏 导论 抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。当有多个相同的类要实现类似的功能，但是具体的实现细节有所不同，这时候就可以使用抽象工厂模式。
🧀 前置知识 工厂方法模式（Factory Method） 🚦 结构 classDiagram class AbstractFactory{ &lt;&lt;interface>> +createProductA() +createProductB() } class ConcreteFactory1{ +createProductA() +createProductB() } class ConcreteFactory2{ +createProductA() +createProductB() } class AbstractProductA{ &lt;&lt;interface>> } class ProductA1 class ProductA2 class AbstractProductB{ &lt;&lt;interface>> } class ProductB1 class ProductB2 class Client AbstractFactory &lt;|-- ConcreteFactory1 AbstractFactory &lt;|-- ConcreteFactory2 AbstractProductA &lt;|-- ProductA1 AbstractProductA &lt;|-- ProductA2 AbstractProductB &lt;|-- ProductB1 AbstractProductB &lt;|-- ProductB2 Client --> AbstractFactory Client --> AbstractProductA Client --> AbstractProductB AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们有可能有不同的实现，而ProductA1、ProductA2、ProductB1、ProductB2是对两个抽象产品的具体分类实现。
...</p></div><footer class=entry-footer><span title='2025-01-07 21:19:06 +0800 +0800'>January 7, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1258 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to 抽象工厂模式（Abstract Factory）" href=http://rextechie.github.io/posts/design_patterns/abstract_factory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework</h2></header><div class=entry-content><p>基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ArXiv 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。
研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：
引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOA，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。
在MetaGPT中，对于每个角色制定了Agent的名字（name）、资料（profile）、目标（goal）和约束（constraints）。同时也初始化每个角色的特定的上下文（context）和技能（skill）。例如，产品经理可以使用网络搜索技能，而工程师可以执行代码。如下图2所示。所有Agent遵循ReAct风格。
...</p></div><footer class=entry-footer><span title='2025-01-07 20:39:47 +0800 +0800'>January 7, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;256 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework" href=http://rextechie.github.io/posts/paper_note/metagpt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Evaluating Large Language Models Trained on Code</h2></header><div class=entry-content><p>基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。
研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。
功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。
Kual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n > k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c &lt;= n），并计算无偏估计量。其中 $\text{pass@}k := \mathbb{E}_{\text{Problems}} \left[ 1 - \frac{\binom{n-c}{k}}{\binom{n}{k}} \right]$。
...</p></div><footer class=entry-footer><span title='2025-01-01 14:47:39 +0800 +0800'>January 1, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to Evaluating Large Language Models Trained on Code" href=http://rextechie.github.io/posts/paper_note/human_eval/></a></article></main><footer class=footer><span>&copy; 2025 <a href=http://rextechie.github.io/>RexBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>