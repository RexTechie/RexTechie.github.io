<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DocAgent: A Multi-Agent System for Automated Code Documentation Generation | RexBlog</title>
<meta name=keywords content="Agent"><meta name=description content="代码文档注释生成"><meta name=author content="Rex"><link rel=canonical href=http://rextechie.github.io/posts/paper_note/doc_agent/><link crossorigin=anonymous href=/assets/css/stylesheet.56d5e73e1a36d8bc0a4f450d156a288bf54a46b72e29e3f236c46370aa489a22.css integrity="sha256-VtXnPho22LwKT0UNFWooi/VKRrcuKePyNsRjcKpImiI=" rel="preload stylesheet" as=style><link rel=icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=icon type=image/png sizes=16x16 href=http://rextechie.github.io/favicon/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=apple-touch-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=mask-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://rextechie.github.io/posts/paper_note/doc_agent/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"default",themeVariables:{lineColor:"#fafafa",darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:url" content="http://rextechie.github.io/posts/paper_note/doc_agent/"><meta property="og:site_name" content="RexBlog"><meta property="og:title" content="DocAgent: A Multi-Agent System for Automated Code Documentation Generation"><meta property="og:description" content="代码文档注释生成"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-03T13:11:17+08:00"><meta property="article:modified_time" content="2025-06-03T13:11:17+08:00"><meta property="article:tag" content="Agent"><meta property="og:image" content="http://rextechie.github.io/images/profile.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://rextechie.github.io/images/profile.png"><meta name=twitter:title content="DocAgent: A Multi-Agent System for Automated Code Documentation Generation"><meta name=twitter:description content="代码文档注释生成"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://rextechie.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DocAgent: A Multi-Agent System for Automated Code Documentation Generation","item":"http://rextechie.github.io/posts/paper_note/doc_agent/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DocAgent: A Multi-Agent System for Automated Code Documentation Generation","name":"DocAgent: A Multi-Agent System for Automated Code Documentation Generation","description":"代码文档注释生成","keywords":["Agent"],"articleBody":"基本信息 标题: DocAgent: A Multi-Agent System for Automated Code Documentation Generation 作者: Dayu Yang（通讯作者）、Antoine Simoulin、Xin Qian等。 作者单位: Meta AI 期刊/会议: ArXiv 发表年份: 2025.04.11 DOI: 2504.08725 开源地址: Github 关键词: Code Documentation, Multi-Agent System, Large Language Models 研究问题 (Research Questions) 如何自动生成代码文档注释，尤其是处理函数/类中复杂的依赖关系和上下文信息？\n研究背景 (Background) 像现在的方法FIM（Fill in the Middle）和 chat agent可以实现自动化生成文档注释，但还是有一些局限性：\n省略了必要的信息（例如，参数或返回值描述）。 它们通常提供最少量的上下文或理由，限制了生成文档注释的价值。 由于LLM的幻觉，会虚构不存在的组件，尤其是规模比较大的项目中。 核心贡献 (Key Contributions) DocAgent，一个多智能体、拓扑结构化的上下文感知文档生成系统。 一个衡量代码文档完整性、实用性和事实一致性的稳健评估框架。 全面实验表明，DocAgent在多个数据集中持续优于最先进的基线。 方法 (Methodology) DocAgent分两个阶段来处理复杂的依赖关系并确保上下文的相关性。\n用一个Navigator确定一个最佳的依赖感知的处理顺序 Multi-Agent System系统增量地生成文档注释，利用专门的Agent进行代码分析、信息检索、编写文档注释和验证 Navigator: 感知依赖顺序 生成文档注释需要理解依赖代码之间的关系，然而如果给出所有内容，很容易超出上下文窗口的限制。Navigator模块就是为了解决这个问题，Navigator建立了一个处理顺序，确保处理依赖关系之后才对组件做文档注释，从而实现增量上下文构建。\n构建依赖图 首先对整个存储库进行静态分析，解析源文件的抽象语法树（AST，Abstract Syntax Tree），以识别代码组件（函数、方法、类）及其相互关系（函数调用、继承、属性方法和模块导入），用一个有向无环图（DAG， Directed Acyclic Graph）来表示，节点是组件，边是依赖关系。为了实现拓扑排序，用Tarjan算法检测图中的循环，并将其浓缩单个超级节点。\nTopological Traversal for Hierarchical Generation 使用有向无环图，Navigator模块使用DAG执行拓扑排序，以确定文档注释生成顺序。遍历遵循“依赖优先”原则：只有在所有直接依赖的组件都已生成文档注释后，才会处理组件。这种方式确保多智能体系统为特定组件生成文档注释时，已经生成该组件的所有依赖性描述。因此，每个文档注释只需要其单跳依赖项的信息，消除了需要拉入不断增长的背景信息链的需求。\nMulti-Agent Documentation Generation 多智能体系统由一个编排器协调四个专业智能体（Reader、Searcher、Writer、Verifier），为每个组件生成文档。\nReader 对于ReaderAgent来说，他的任务是确定对生成全面的且对代码文档注释有帮助的信息。他通过评估组件的复杂性、可见性和实现细节来进行判断，1）是否需要外部信息，简单的、自包含的组件可能不需要外部信息。2）需要什么信息：这涉及到识别特定的内部依赖（用到的函数、类）、使用的上下文（组件调用的地方，以及其目标）或隐式/显式的外部概念（算法、库、领域知识）。\n这个Agent最终输出的是一个格式化的XML，1）关于相关代码组件的内部信息、2）针对特定算法或技术的外部知识。\n对于内部信息，需要包含依赖和引用。依赖意味着目标组件调用里其他组件，Reader Agent会判断这些依赖是否是必须的信息。引用意味着目标组件在代码库的某个地方被调用，揭示了目标组件的目的。\n外部请求针对的信息并非直接来自代码库本身或可从代码库推断，例如特定领域的知识或第三方库功能。\nSearcher Searcher Agent 负责使用工具满足Reader Agent的信息请求。\n内部代码分析工具（Internal Code Analysis Tool）: 该工具利用静态分析能力遍历代码库，可获取指定内部组件的源代码及现有文档，定位目标组件的调用点，通过预计算依赖图或实时分析追踪依赖关系，并提取相关结构信息（如类继承层次、方法签名等）。 外部知识检索工具（External Knowledge Retrieval Tool）: 这个工具通过通用检索API介入外部知识源，能根据Reader对外部概念查询需求自动构建检索语句，并对返回结果进行处理以提取相关解释、定义或描述。 Searcher会将检索到的内部代码信息和外部知识合并为结构化格式，作为后续智能体运作的上下文依据。\n就像两个人类合作完成项目并相互交流一样，在Searcher将检索到的信息发送回读者后，Reader会读取更新后的上下文和目标组件，并判断当前上下文是否足以生成文档。若Reader认为检索到的信息仍不充分，Reader可继续向Searcher发送信息请求。如此，信息请求与新检索到的内容将在Reader与Searcher之间循环传递，直至获取足够的信息为止。\nWriter Writer智能体的输入是目标组件的代码和由Searcher产出的结构化的内容，核心任务是生成代码文档注释。生成过程主要通过提示词根据组件类型指定所需结构和内容：\n函数/方法（Function / Method）：通常需要摘要、额外描述、参数描述、返回值描述、引发的异常以及可能使用的示例（特别是对于公共组件）。 类：通常需要摘要、额外描述、初始化示例、构造器参数描述、公共参数描述 这个Writer Agent根据代码和提供的上下文生成符合要求的代码文档注释。\nVerifier Verifier的输入是Writer提供的上下文、代码组件和生成的代码文档注释，根据预定义的质量标准评估代码文档：信息价值、详细程度和完整性。评估后，Verifier要么批准文档，要么通过结构化反馈提供具体的改进建议。\n如果问题可以不通过额外上下文信息的情况下解决，Verifier可以和Writer进行交互。比如：格式问题，可以通过要求Writer重写来轻松解决。\n如果问题是因为缺乏信息引起的，并且需要额外的内容，verifier也可以向Reader提供建议，并且将通过Reader-Searcher循环收集额外的信息。\nOrchestrator 用Orchestrator管理agent工作流，来实现整体的迭代过程。整个周期：\nReader分析目标代码以及必要的上下文 Searcher收集信息 Writer写文档注释 Verifier评估注释质量，批准或退回以供修订 这个过程一直持续到生成令人满意的代码文档注释或达到最大迭代限制。\nAdaptive Context Manage(自适应上下文管理)：为了处理Searcher检索到的很大的文本，尤其是复杂的组件，Orchestrator实现了一个自适应上下文截断机制。他监控提供给Writer的token总数，如果context超过了一个可配置的阈值（基于底层LLM的限制），Orchestrator将使用截断策略。它识别结构化后的上下文中最大部分（如：外部知识片段、特定的依赖细节），并从这些部分的末尾选择性地删除内容，以减少token数同时保持整体结构。\n评估框架（Evaluation Framework） 存在的挑战：\n缺乏gold reference。传统的指标BLEU或ROUGE，不能适用。 根据文档注释长度这样的方法不足以作为实际效用的指标 人工评估具有主观性、成本高、难以拓展，大规模试验或持续集成场景不切实际 为了解决这些问题，作者提出了一个新的评估框架，包含几个方面：完整性（Completeness）、帮助性（Helpfulness）、真实性（Truthfulness）。\n完整性（Completeness） 完整性评估依据标准结构的约定，并包括预期用于给定代码元素（例如，函数、类）的基本组件。高质量的代码文档注释不仅包括摘要，还包括参数描述、返回值、引发的异常以及可能的使用示例，这些信息依赖于目标组件的声明、主体和可见性。评估方法\n主要评估方法，采用抽象语法树（AST）和正则表达式的自动化检查器。\nAST Parsing：识别代码组件（类、函数、方法）并提取其生成的文档注释。 Code Analysis：分析代码声明和代码主体（例如：参数、返回语句、抛出异常是否存在）以及可见性（公共/私有），来确定文注释档部分。如没有参数的函数不需要“参数”部分，而公共类可能比私有函数更有用。 Section Identification：检测文档注释中标准部分（例如，摘要、描述、参数、返回值、抛出异常、示例、类属性）的存在，使用预定义模式和结构提示。 Scoring：计算每个文档注释的完整性得分，作为所需部分存在的比例。0.0～1.0之间。 这种确定性方法提供了一个结构遵循的客观度量，表明文档是否符合基本形式要求。\n帮助性（Helpfulness） 帮助是评估文档注释内容的语义质量和实用价值，一个有帮助性的文档注释不仅限于重申代码元素；它阐明了代码的目的、使用上下文、设计理由和潜在限制。\nClarity and Conciseness: 摘要信息是否简洁 Descriptive Depth：扩展描述是否提供了足够的信息，解释了代码背后的“为什么”，或者提到了相关场景或边缘情况？ Parameter/Attribute Utilty：输入和属性的描述是否有意义，是否指定了预期的类型、值范围或约束，而不是仅仅重复名称？ Guidance：文档注释是否有效地指导开发者何时以及如何使用该组件？ 评估方式，使用LLM进行评估，作者提出了一套框架。Component Specific Evaluation：作者将评估分解为分别评估文档注释的不同部分（摘要、主要描述、参数描述）使用针对每个部分的提示词。Structured Prompt Engineering:\n明确评分标准（Explicit Scoring Rubrics）：详细标准用5分制Likert特量表（1=Poor，5=Excellent） 示例说明（Illustrative Examples）：具体对应不同等级的文档注释片段示例，确立评价标准 分步说明（Step-by-Step Instructions）：引导LLM分析代码，将文档注释与评分标准进行比较，考虑代码的上下文，并为其评分提供理由。 标准的输出格式（Standardized Output Format）：要求大模型提供结构化输出，包括详细的推理、具体的改进意见（如适用）以及最终的数值评分。 这种结构化方法允许对语义质量进行可扩展的评估，超越了表面层次的检查，以衡量文档对开发者的实际价值。\n真实性（Truthfulness） 由于LLM存在幻觉，因此可能会导致生成文档注释时引用不存在的函数、参数或类，或者错误地表示组件之间的关系，因此有必要评估文档注释的真实性。作者通过验证生成的文档注释中提到的实体是否确实存在与目标的代码库中以及引用是否正确来评估真实性。主要过程包含三部分：\n代码实体提取（Code Entity Extraction）：大模型用提示词从代码仓库中提取特定代码组件（类、函数、方法、属性）。提示词特别的引导大模型区分关键字、内置类型和常见外部库组件，重点关注内部引用。 真实构造（Ground Truth Construction）：作者利用Navigator构建的依赖图，将其用作基准事实，包含所有代码组件及其在存储库中的规范表示。 验证（Verification）：每个提取的实体提及都与依赖图进行交叉引用。 作者使用Existence Ratio来量化Truthfulness，即文档注释中提及的实体与代码库中的实际实体的比例。${Existence Ratio} = \\frac{Verified Entities}{Extracted Entities}$\n高比率表明文档在实际代码结构中很好地建立了基础，从而最大限度地减少了幻觉引用的风险。\n实验 (Experimental) 基线（Baselines） FIM（Fill-in-the-middle） 用途模拟：模拟内联代码补全工具，通过补全“中间空白”来预测注释内容。 使用模型：使用的是 CodeLlama-13B（Roziere 等人，2023），这是一个开源模型，专门针对 FIM 任务进行训练（Bavarian 等人，2022）。 简称：FIM-CL Chat 用途模拟：将代码片段直接输入到聊天模型中，请其生成文档注释，代表了当前流行的基于对话的使用方式。 测试模型： GPT-4o mini：简称 Chat-GPT CodeLlama-34B-instruct：简称 Chat-CL 实验设置（Experimental Setup） Data: 选择了一组具有不同规模、复杂度和领域的Python代码库的代表性子集，以确保多样性。数据集包括具有不同依赖密度的模块、函数、方法和类。\nSystem: 作者评估了 DocAgent 的两个变体，仅在所用底层大语言模型（LLM）上有所不同\nDA-GPT：基于 GPT-4o mini 的 DocAgent 版本 DA-CL：基于 CodeLlama-34B-instruct 的 DocAgent 版本 Statistical: 所有关于统计显著性的结论均基于配对 t 检验（paired t-tests），显著性阈值设为：p \u003c 0.05\n实验结果（Experimental Results） 作者主要对Completeness、Helpfulness和Truthfulness三个方面进行了评估。\n完整性试验 从结果来看DocAgent的方法完整性显著优于Chat和FIM。说明DocAgent能够生成更全面的代码文档注释，包含更多必要的部分。\n帮助性试验 如表所示，DocAgent实现了最高的整体有用性得分，显著优于相应的Chat和FIM，展示了其通过利用检索到的上下文生成更清晰、更有信息量的内容的能力。即使生成有用的参数描述是非常困难的，但是在这里，DocAgent依旧是最高分，这表明其结构化方法有助于这项困难任务，尽管仍有改进空间。\n真实性试验 上表的结果展示了DocAgent生成的文档注释在事实准确性方面的优越性。DocAgent实现了最高的存在比率，表明其大部分对内部代码组件的引用都是正确的。\n消融试验 - Helpfulness DA-Rand表示Navigator部分不进行拓扑排序，随机处理代码组件。\n由试验表明，经过拓扑排序的DocAgent在帮助性方面表现更好，表明依赖感知的处理顺序对生成有用的代码文档注释至关重要。\n消融试验 - Truthfulness 由试验表明，虽然没有Navigator，Searcher依然能检索依赖的组件。然而没有遵循“依赖优先”原则，这些组件不太可能有可用于上下文的现有文档注释。\n总体而言，消融结果证实，导航器的依赖感知拓扑排序是DocAgent的关键组成部分，通过实现有效的增量上下文管理，显著提高了生成文档注释的有用性和事实准确性。\n参考文献 (References) LLM Agent Guang Yang, Yu Zhou, Wei Cheng, Xiangyu Zhang, Xiang Chen, Terry Yue Zhuo, Ke Liu, Xin Zhou, David Lo, and Taolue Chen. 2024. Less is more: Docstring compression in code generation. arXiv preprint arXiv:2410.22793. Shinn Yao, Jeffrey Zhao, Dian Yu, Kang Chen, Karthik Narasimhan, and Yuan Cao. 2022. React: Synergizing reasoning and acting in language models. arXiv preprint arXiv:2210.03629. Noah Shinn, Margaret Labash, and Stefano Ermon. 2023. Reflexion: Language agents with verbal reinforcement learning. arXiv preprint arXiv:2303.11366. Xiang Li, Qinyuan Zhu, Yelong Cheng, Weizhu Xu, and Xi Liu. 2023b. Camel: Communicative agents for “mind” exploration. arXiv preprint arXiv:2303.17760. Ziniu Wu, Cheng Liu, Jindong Zhang, Xinyun Li, Yewen Wang, Jimmy Xin, Lianmin Zhang, Eric Xing, Yuxin Lu, and Percy Liang. 2023. Autogen: Enabling next-generation multi-agent communication with language models. arXiv preprint arXiv:2309.07864. Xiaoqing Zhang, Zhirui Wang, Lichao Yang, Wei Zhang, and Yong Zhang. 2023b. Mapcoder: Map-reducestyle code generation with multi-agent collaboration. arXiv preprint arXiv:2307.15808. Yuzhang Qian, Zian Zhang, Liang Pan, Peng Wang, Shouyi Liu, Wayne Xin Zhao, and Ji-Rong Wen. 2023. Chatdev: Revolutionizing software development with ai-collaborative agents. arXiv preprint arXiv:2307.07924. Code Summarization Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing Qin, Ting Liu, and Daxin Jiang. 2020. Codebert: A pre-trained model for programming and natural languages. In EMNLP. Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Nan Duan, Ming Zhou, and Daxin Jiang. 2021. Graphcodebert: Pre-training code representations with data flow. In ICLR. Wasi U Ahmad, Saikat Chakraborty, Baishakhi Ray, and Kai-Wei Chang. 2021. Unified pre-training for program understanding and generation. In ACL. Yue Wang, Shuo Ren, Daya Lu, Duyu Tang, Nan Duan, Ming Zhou, and Daxin Jiang. 2021. Codet5: Identifier-aware unified pre-trained encoder-decoder models for code understanding and generation. In EMNLP. Colin B Clement, Andrew Terrell, Hanlin Mao, Joshua Dillon, Sameer Singh, and Dan Alistarh. 2020. Pymt5: Multi-mode translation of natural language and python code with transformers. In EMNLP. Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, and 1 others. 2021. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374. Raymond Li, Lewis Tunstall, Patrick von Platen, Jungtaek Kim, Teven Le Scao, Thomas Wolf, and Alexander M. Rush. 2023a. Starcoder: May the source be with you! Preprint, arXiv:2305.06161. Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Romain Sauvestre, Tal Remez, and 1 others. 2023. Code llama: Open foundation models for code. arXiv preprint arXiv:2308.12950. 优点与创新点 (Strengths) 有图论的理论支撑，通过依赖图和拓扑排序来处理复杂的代码依赖关系。 试验客观性强，紧紧依赖于代码的AST和正则表达式，避免了人工评估的主观性。 我的思考 (Personal Thoughts) 是否可以考虑将DAG图用于通过需求生成复杂业务的代码中？ 对于项目级别的代码生成后，能否通过DocAgent类似的方法增加代码注释？\n","wordCount":"687","inLanguage":"en","image":"http://rextechie.github.io/images/profile.png","datePublished":"2025-06-03T13:11:17+08:00","dateModified":"2025-06-03T13:11:17+08:00","author":{"@type":"Person","name":"Rex"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://rextechie.github.io/posts/paper_note/doc_agent/"},"publisher":{"@type":"Organization","name":"RexBlog","logo":{"@type":"ImageObject","url":"http://rextechie.github.io/favicon/favicon_32x32.png"}}}</script><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js crossorigin=anonymous></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})'></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://rextechie.github.io/ accesskey=h title="🏘️Home (Alt + H)"><img src=http://rextechie.github.io/favicon/favicon_32x32.png alt aria-label=logo height=35>🏘️Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://rextechie.github.io/posts/ title="📚 Posts"><span>📚 Posts</span></a></li><li><a href=http://rextechie.github.io/archives/ title="📅 Archives"><span>📅 Archives</span></a></li><li><a href=http://rextechie.github.io/search/ title="🔍 Search (Alt + /)" accesskey=/><span>🔍 Search</span></a></li><li><a href=http://rextechie.github.io/categories/ title="📂 Categories"><span>📂 Categories</span></a></li><li><a href=http://rextechie.github.io/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=http://rextechie.github.io/about/ title="📝 About"><span>📝 About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://rextechie.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://rextechie.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DocAgent: A Multi-Agent System for Automated Code Documentation Generation</h1><div class=post-description>代码文档注释生成</div><div class=post-meta><span title='2025-06-03 13:11:17 +0800 +0800'>June 3, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;687 words&nbsp;·&nbsp;Rex&nbsp;|&nbsp;<a href=https://github.com/RexTechie/RexTechie.github.io/blob/main/content/posts/paper_note/doc_agent.md rel="noopener noreferrer" target=_blank>修改</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#基本信息>基本信息</a></li><li><a href=#研究问题-research-questions>研究问题 (Research Questions)</a></li><li><a href=#研究背景-background>研究背景 (Background)</a></li><li><a href=#核心贡献-key-contributions>核心贡献 (Key Contributions)</a></li><li><a href=#方法-methodology>方法 (Methodology)</a><ul><li><a href=#navigator-感知依赖顺序>Navigator: 感知依赖顺序</a></li><li><a href=#multi-agent-documentation-generation>Multi-Agent Documentation Generation</a></li></ul></li><li><a href=#评估框架evaluation-framework>评估框架（Evaluation Framework）</a><ul><li><a href=#完整性completeness>完整性（Completeness）</a></li><li><a href=#帮助性helpfulness>帮助性（Helpfulness）</a></li><li><a href=#真实性truthfulness>真实性（Truthfulness）</a></li></ul></li><li><a href=#实验-experimental>实验 (Experimental)</a><ul><li><a href=#基线baselines>基线（Baselines）</a></li><li><a href=#实验设置experimental-setup>实验设置（Experimental Setup）</a></li><li><a href=#实验结果experimental-results>实验结果（Experimental Results）</a></li></ul></li><li><a href=#参考文献-references>参考文献 (References)</a><ul><li><a href=#llm-agent>LLM Agent</a></li><li><a href=#code-summarization>Code Summarization</a></li></ul></li><li><a href=#优点与创新点-strengths>优点与创新点 (Strengths)</a></li><li><a href=#我的思考-personal-thoughts>我的思考 (Personal Thoughts)</a></li></ul></nav></div></details></div><div class=post-content><h2 id=基本信息>基本信息<a hidden class=anchor aria-hidden=true href=#基本信息>#</a></h2><ul><li><strong>标题</strong>: DocAgent: A Multi-Agent System for Automated Code Documentation Generation</li><li><strong>作者</strong>: Dayu Yang（通讯作者）、Antoine Simoulin、Xin Qian等。</li><li><strong>作者单位</strong>: Meta AI</li><li><strong>期刊/会议</strong>: ArXiv</li><li><strong>发表年份</strong>: 2025.04.11</li><li><strong>DOI</strong>: <a href=https://arxiv.org/abs/2504.08725>2504.08725</a></li><li><strong>开源地址</strong>: <a href=https://github.com/facebookresearch/DocAgent>Github</a></li><li><strong>关键词</strong>: Code Documentation, Multi-Agent System, Large Language Models</li></ul><hr><h2 id=研究问题-research-questions>研究问题 (Research Questions)<a hidden class=anchor aria-hidden=true href=#研究问题-research-questions>#</a></h2><p>如何自动生成代码文档注释，尤其是处理函数/类中复杂的依赖关系和上下文信息？</p><hr><h2 id=研究背景-background>研究背景 (Background)<a hidden class=anchor aria-hidden=true href=#研究背景-background>#</a></h2><p>像现在的方法FIM（Fill in the Middle）和 chat agent可以实现自动化生成文档注释，但还是有一些局限性：</p><ol><li>省略了必要的信息（例如，参数或返回值描述）。</li><li>它们通常提供最少量的上下文或理由，限制了生成文档注释的价值。</li><li>由于LLM的幻觉，会虚构不存在的组件，尤其是规模比较大的项目中。</li></ol><hr><h2 id=核心贡献-key-contributions>核心贡献 (Key Contributions)<a hidden class=anchor aria-hidden=true href=#核心贡献-key-contributions>#</a></h2><p><img alt=DocAgent loading=lazy src=/images/20250612102640.png></p><ul><li>DocAgent，一个多智能体、拓扑结构化的上下文感知文档生成系统。</li><li>一个衡量代码文档完整性、实用性和事实一致性的稳健评估框架。</li><li>全面实验表明，DocAgent在多个数据集中持续优于最先进的基线。</li></ul><hr><h2 id=方法-methodology>方法 (Methodology)<a hidden class=anchor aria-hidden=true href=#方法-methodology>#</a></h2><p>DocAgent分两个阶段来处理复杂的依赖关系并确保上下文的相关性。</p><ol><li>用一个Navigator确定一个最佳的依赖感知的处理顺序</li><li>Multi-Agent System系统增量地生成文档注释，利用专门的Agent进行代码分析、信息检索、编写文档注释和验证</li></ol><p><img alt="Architecture of DocAgent" loading=lazy src=/images/20250609093041.png></p><h3 id=navigator-感知依赖顺序>Navigator: 感知依赖顺序<a hidden class=anchor aria-hidden=true href=#navigator-感知依赖顺序>#</a></h3><p>生成文档注释需要理解依赖代码之间的关系，然而如果给出所有内容，很容易超出上下文窗口的限制。Navigator模块就是为了解决这个问题，Navigator建立了一个处理顺序，确保处理依赖关系之后才对组件做文档注释，从而实现增量上下文构建。</p><h4 id=构建依赖图>构建依赖图<a hidden class=anchor aria-hidden=true href=#构建依赖图>#</a></h4><p>首先对整个存储库进行静态分析，解析源文件的抽象语法树（AST，Abstract Syntax Tree），以识别代码组件（函数、方法、类）及其相互关系（函数调用、继承、属性方法和模块导入），用一个有向无环图（DAG， Directed Acyclic Graph）来表示，节点是组件，边是依赖关系。为了实现拓扑排序，用Tarjan算法检测图中的循环，并将其浓缩单个超级节点。</p><h4 id=topological-traversal-for-hierarchical-generation>Topological Traversal for Hierarchical Generation<a hidden class=anchor aria-hidden=true href=#topological-traversal-for-hierarchical-generation>#</a></h4><p>使用有向无环图，Navigator模块使用DAG执行拓扑排序，以确定文档注释生成顺序。遍历遵循“依赖优先”原则：只有在所有直接依赖的组件都已生成文档注释后，才会处理组件。这种方式确保多智能体系统为特定组件生成文档注释时，已经生成该组件的所有依赖性描述。因此，每个文档注释只需要其单跳依赖项的信息，消除了需要拉入不断增长的背景信息链的需求。</p><h3 id=multi-agent-documentation-generation>Multi-Agent Documentation Generation<a hidden class=anchor aria-hidden=true href=#multi-agent-documentation-generation>#</a></h3><p>多智能体系统由一个编排器协调四个专业智能体（Reader、Searcher、Writer、Verifier），为每个组件生成文档。</p><h4 id=reader>Reader<a hidden class=anchor aria-hidden=true href=#reader>#</a></h4><p>对于ReaderAgent来说，他的任务是确定对生成全面的且对代码文档注释有帮助的信息。他通过评估组件的复杂性、可见性和实现细节来进行判断，1）是否需要外部信息，简单的、自包含的组件可能不需要外部信息。2）需要什么信息：这涉及到识别特定的内部依赖（用到的函数、类）、使用的上下文（组件调用的地方，以及其目标）或隐式/显式的外部概念（算法、库、领域知识）。</p><p>这个Agent最终输出的是一个格式化的XML，1）关于相关代码组件的内部信息、2）针对特定算法或技术的外部知识。</p><p>对于内部信息，需要包含依赖和引用。依赖意味着目标组件调用里其他组件，Reader Agent会判断这些依赖是否是必须的信息。引用意味着目标组件在代码库的某个地方被调用，揭示了目标组件的目的。</p><p>外部请求针对的信息并非直接来自代码库本身或可从代码库推断，例如特定领域的知识或第三方库功能。</p><h4 id=searcher>Searcher<a hidden class=anchor aria-hidden=true href=#searcher>#</a></h4><p>Searcher Agent 负责使用工具满足Reader Agent的信息请求。</p><ul><li>内部代码分析工具（Internal Code Analysis Tool）: 该工具利用静态分析能力遍历代码库，可获取指定内部组件的源代码及现有文档，定位目标组件的调用点，通过预计算依赖图或实时分析追踪依赖关系，并提取相关结构信息（如类继承层次、方法签名等）。</li><li>外部知识检索工具（External Knowledge Retrieval Tool）: 这个工具通过通用检索API介入外部知识源，能根据Reader对外部概念查询需求自动构建检索语句，并对返回结果进行处理以提取相关解释、定义或描述。</li></ul><p>Searcher会将检索到的内部代码信息和外部知识合并为结构化格式，作为后续智能体运作的上下文依据。</p><p>就像两个人类合作完成项目并相互交流一样，在Searcher将检索到的信息发送回读者后，Reader会读取更新后的上下文和目标组件，并判断当前上下文是否足以生成文档。若Reader认为检索到的信息仍不充分，Reader可继续向Searcher发送信息请求。如此，信息请求与新检索到的内容将在Reader与Searcher之间循环传递，直至获取足够的信息为止。</p><h4 id=writer>Writer<a hidden class=anchor aria-hidden=true href=#writer>#</a></h4><p>Writer智能体的输入是目标组件的代码和由Searcher产出的结构化的内容，核心任务是生成代码文档注释。生成过程主要通过提示词根据组件类型指定所需结构和内容：</p><ul><li>函数/方法（Function / Method）：通常需要摘要、额外描述、参数描述、返回值描述、引发的异常以及可能使用的示例（特别是对于公共组件）。</li><li>类：通常需要摘要、额外描述、初始化示例、构造器参数描述、公共参数描述</li></ul><p>这个Writer Agent根据代码和提供的上下文生成符合要求的代码文档注释。</p><h4 id=verifier>Verifier<a hidden class=anchor aria-hidden=true href=#verifier>#</a></h4><p>Verifier的输入是Writer提供的上下文、代码组件和生成的代码文档注释，根据预定义的质量标准评估代码文档：信息价值、详细程度和完整性。评估后，Verifier要么批准文档，要么通过结构化反馈提供具体的改进建议。</p><p>如果问题可以不通过额外上下文信息的情况下解决，Verifier可以和Writer进行交互。比如：格式问题，可以通过要求Writer重写来轻松解决。</p><p>如果问题是因为缺乏信息引起的，并且需要额外的内容，verifier也可以向Reader提供建议，并且将通过Reader-Searcher循环收集额外的信息。</p><h4 id=orchestrator>Orchestrator<a hidden class=anchor aria-hidden=true href=#orchestrator>#</a></h4><p>用Orchestrator管理agent工作流，来实现整体的迭代过程。整个周期：</p><ol><li>Reader分析目标代码以及必要的上下文</li><li>Searcher收集信息</li><li>Writer写文档注释</li><li>Verifier评估注释质量，批准或退回以供修订</li></ol><p>这个过程一直持续到生成令人满意的代码文档注释或达到最大迭代限制。</p><p>Adaptive Context Manage(自适应上下文管理)：为了处理Searcher检索到的很大的文本，尤其是复杂的组件，Orchestrator实现了一个自适应上下文截断机制。他监控提供给Writer的token总数，如果context超过了一个可配置的阈值（基于底层LLM的限制），Orchestrator将使用截断策略。它识别结构化后的上下文中最大部分（如：外部知识片段、特定的依赖细节），并从这些部分的末尾选择性地删除内容，以减少token数同时保持整体结构。</p><hr><h2 id=评估框架evaluation-framework>评估框架（Evaluation Framework）<a hidden class=anchor aria-hidden=true href=#评估框架evaluation-framework>#</a></h2><p>存在的挑战：</p><ol><li>缺乏gold reference。传统的指标BLEU或ROUGE，不能适用。</li><li>根据文档注释长度这样的方法不足以作为实际效用的指标</li><li>人工评估具有主观性、成本高、难以拓展，大规模试验或持续集成场景不切实际</li></ol><p>为了解决这些问题，作者提出了一个新的评估框架，包含几个方面：完整性（Completeness）、帮助性（Helpfulness）、真实性（Truthfulness）。</p><h3 id=完整性completeness>完整性（Completeness）<a hidden class=anchor aria-hidden=true href=#完整性completeness>#</a></h3><p>完整性评估依据标准结构的约定，并包括预期用于给定代码元素（例如，函数、类）的基本组件。高质量的代码文档注释不仅包括摘要，还包括参数描述、返回值、引发的异常以及可能的使用示例，这些信息依赖于目标组件的声明、主体和可见性。评估方法</p><p>主要评估方法，采用抽象语法树（AST）和正则表达式的自动化检查器。</p><ul><li>AST Parsing：识别代码组件（类、函数、方法）并提取其生成的文档注释。</li><li>Code Analysis：分析代码声明和代码主体（例如：参数、返回语句、抛出异常是否存在）以及可见性（公共/私有），来确定文注释档部分。如没有参数的函数不需要“参数”部分，而公共类可能比私有函数更有用。</li><li>Section Identification：检测文档注释中标准部分（例如，摘要、描述、参数、返回值、抛出异常、示例、类属性）的存在，使用预定义模式和结构提示。</li><li>Scoring：计算每个文档注释的完整性得分，作为所需部分存在的比例。0.0～1.0之间。</li></ul><p>这种确定性方法提供了一个结构遵循的客观度量，表明文档是否符合基本形式要求。</p><h3 id=帮助性helpfulness>帮助性（Helpfulness）<a hidden class=anchor aria-hidden=true href=#帮助性helpfulness>#</a></h3><p>帮助是评估文档注释内容的语义质量和实用价值，一个有帮助性的文档注释不仅限于重申代码元素；它阐明了代码的目的、使用上下文、设计理由和潜在限制。</p><ul><li>Clarity and Conciseness: 摘要信息是否简洁</li><li>Descriptive Depth：扩展描述是否提供了足够的信息，解释了代码背后的“为什么”，或者提到了相关场景或边缘情况？</li><li>Parameter/Attribute Utilty：输入和属性的描述是否有意义，是否指定了预期的类型、值范围或约束，而不是仅仅重复名称？</li><li>Guidance：文档注释是否有效地指导开发者何时以及如何使用该组件？</li></ul><p>评估方式，使用LLM进行评估，作者提出了一套框架。Component Specific Evaluation：作者将评估分解为分别评估文档注释的不同部分（摘要、主要描述、参数描述）使用针对每个部分的提示词。Structured Prompt Engineering:</p><ol><li>明确评分标准（Explicit Scoring Rubrics）：详细标准用5分制Likert特量表（1=Poor，5=Excellent）</li><li>示例说明（Illustrative Examples）：具体对应不同等级的文档注释片段示例，确立评价标准</li><li>分步说明（Step-by-Step Instructions）：引导LLM分析代码，将文档注释与评分标准进行比较，考虑代码的上下文，并为其评分提供理由。</li><li>标准的输出格式（Standardized Output Format）：要求大模型提供结构化输出，包括详细的推理、具体的改进意见（如适用）以及最终的数值评分。</li></ol><p>这种结构化方法允许对语义质量进行可扩展的评估，超越了表面层次的检查，以衡量文档对开发者的实际价值。</p><h3 id=真实性truthfulness>真实性（Truthfulness）<a hidden class=anchor aria-hidden=true href=#真实性truthfulness>#</a></h3><p>由于LLM存在幻觉，因此可能会导致生成文档注释时引用不存在的函数、参数或类，或者错误地表示组件之间的关系，因此有必要评估文档注释的真实性。作者通过验证生成的文档注释中提到的实体是否确实存在与目标的代码库中以及引用是否正确来评估真实性。主要过程包含三部分：</p><ul><li>代码实体提取（Code Entity Extraction）：大模型用提示词从代码仓库中提取特定代码组件（类、函数、方法、属性）。提示词特别的引导大模型区分关键字、内置类型和常见外部库组件，重点关注内部引用。</li><li>真实构造（Ground Truth Construction）：作者利用Navigator构建的依赖图，将其用作基准事实，包含所有代码组件及其在存储库中的规范表示。</li><li>验证（Verification）：每个提取的实体提及都与依赖图进行交叉引用。</li></ul><p>作者使用Existence Ratio来量化Truthfulness，即文档注释中提及的实体与代码库中的实际实体的比例。${Existence Ratio} = \frac{Verified Entities}{Extracted Entities}$</p><p>高比率表明文档在实际代码结构中很好地建立了基础，从而最大限度地减少了幻觉引用的风险。</p><h2 id=实验-experimental>实验 (Experimental)<a hidden class=anchor aria-hidden=true href=#实验-experimental>#</a></h2><h3 id=基线baselines>基线（Baselines）<a hidden class=anchor aria-hidden=true href=#基线baselines>#</a></h3><ul><li>FIM（Fill-in-the-middle）<ul><li>用途模拟：模拟内联代码补全工具，通过补全“中间空白”来预测注释内容。</li><li>使用模型：使用的是 CodeLlama-13B（Roziere 等人，2023），这是一个开源模型，专门针对 FIM 任务进行训练（Bavarian 等人，2022）。</li><li>简称：FIM-CL</li></ul></li><li>Chat<ul><li>用途模拟：将代码片段直接输入到聊天模型中，请其生成文档注释，代表了当前流行的基于对话的使用方式。</li><li>测试模型：<ul><li>GPT-4o mini：简称 Chat-GPT</li><li>CodeLlama-34B-instruct：简称 Chat-CL</li></ul></li></ul></li></ul><h3 id=实验设置experimental-setup>实验设置（Experimental Setup）<a hidden class=anchor aria-hidden=true href=#实验设置experimental-setup>#</a></h3><p>Data: 选择了一组具有不同规模、复杂度和领域的Python代码库的代表性子集，以确保多样性。数据集包括具有不同依赖密度的模块、函数、方法和类。</p><p>System: 作者评估了 DocAgent 的两个变体，仅在所用底层大语言模型（LLM）上有所不同</p><ul><li>DA-GPT：基于 GPT-4o mini 的 DocAgent 版本</li><li>DA-CL：基于 CodeLlama-34B-instruct 的 DocAgent 版本</li></ul><p>Statistical: 所有关于统计显著性的结论均基于配对 t 检验（paired t-tests），显著性阈值设为：p &lt; 0.05</p><h3 id=实验结果experimental-results>实验结果（Experimental Results）<a hidden class=anchor aria-hidden=true href=#实验结果experimental-results>#</a></h3><p>作者主要对Completeness、Helpfulness和Truthfulness三个方面进行了评估。</p><p><img alt=试验（Experiment） loading=lazy src=/images/20250612102510.png></p><h4 id=完整性试验>完整性试验<a hidden class=anchor aria-hidden=true href=#完整性试验>#</a></h4><p><img alt=完整性（Completeness） loading=lazy src=/images/20250611161423.png></p><p>从结果来看DocAgent的方法完整性显著优于Chat和FIM。说明DocAgent能够生成更全面的代码文档注释，包含更多必要的部分。</p><h4 id=帮助性试验>帮助性试验<a hidden class=anchor aria-hidden=true href=#帮助性试验>#</a></h4><p><img alt=帮助性（Helpfulness） loading=lazy src=/images/20250611161836.png></p><p>如表所示，DocAgent实现了最高的整体有用性得分，显著优于相应的Chat和FIM，展示了其通过利用检索到的上下文生成更清晰、更有信息量的内容的能力。即使生成有用的参数描述是非常困难的，但是在这里，DocAgent依旧是最高分，这表明其结构化方法有助于这项困难任务，尽管仍有改进空间。</p><h4 id=真实性试验>真实性试验<a hidden class=anchor aria-hidden=true href=#真实性试验>#</a></h4><p><img alt=真实性（Truthfulness） loading=lazy src=/images/20250611162251.png></p><p>上表的结果展示了DocAgent生成的文档注释在事实准确性方面的优越性。DocAgent实现了最高的存在比率，表明其大部分对内部代码组件的引用都是正确的。</p><h4 id=消融试验---helpfulness>消融试验 - Helpfulness<a hidden class=anchor aria-hidden=true href=#消融试验---helpfulness>#</a></h4><p>DA-Rand表示Navigator部分不进行拓扑排序，随机处理代码组件。</p><p><img alt="消融试验 - Helpfulness" loading=lazy src=/images/20250611163517.png></p><p>由试验表明，经过拓扑排序的DocAgent在帮助性方面表现更好，表明依赖感知的处理顺序对生成有用的代码文档注释至关重要。</p><h4 id=消融试验---truthfulness>消融试验 - Truthfulness<a hidden class=anchor aria-hidden=true href=#消融试验---truthfulness>#</a></h4><p><img alt="消融试验 - Truthfulness" loading=lazy src=/images/20250611164426.png></p><p>由试验表明，虽然没有Navigator，Searcher依然能检索依赖的组件。然而没有遵循“依赖优先”原则，这些组件不太可能有可用于上下文的现有文档注释。</p><p>总体而言，消融结果证实，导航器的依赖感知拓扑排序是DocAgent的关键组成部分，通过实现有效的增量上下文管理，显著提高了生成文档注释的有用性和事实准确性。</p><hr><h2 id=参考文献-references>参考文献 (References)<a hidden class=anchor aria-hidden=true href=#参考文献-references>#</a></h2><h3 id=llm-agent>LLM Agent<a hidden class=anchor aria-hidden=true href=#llm-agent>#</a></h3><ul><li>Guang Yang, Yu Zhou, Wei Cheng, Xiangyu Zhang, Xiang Chen, Terry Yue Zhuo, Ke Liu, Xin Zhou, David Lo, and Taolue Chen. 2024. Less is more: Docstring compression in code generation. arXiv preprint arXiv:2410.22793.</li><li>Shinn Yao, Jeffrey Zhao, Dian Yu, Kang Chen, Karthik Narasimhan, and Yuan Cao. 2022. React: Synergizing reasoning and acting in language models. arXiv preprint arXiv:2210.03629.</li><li>Noah Shinn, Margaret Labash, and Stefano Ermon. 2023. Reflexion: Language agents with verbal reinforcement learning. arXiv preprint arXiv:2303.11366.</li><li>Xiang Li, Qinyuan Zhu, Yelong Cheng, Weizhu Xu, and Xi Liu. 2023b. Camel: Communicative agents for “mind” exploration. arXiv preprint arXiv:2303.17760.</li><li>Ziniu Wu, Cheng Liu, Jindong Zhang, Xinyun Li, Yewen Wang, Jimmy Xin, Lianmin Zhang, Eric Xing, Yuxin Lu, and Percy Liang. 2023. Autogen: Enabling next-generation multi-agent communication with language models. arXiv preprint arXiv:2309.07864.</li><li>Xiaoqing Zhang, Zhirui Wang, Lichao Yang, Wei Zhang, and Yong Zhang. 2023b. Mapcoder: Map-reducestyle code generation with multi-agent collaboration. arXiv preprint arXiv:2307.15808.</li><li>Yuzhang Qian, Zian Zhang, Liang Pan, Peng Wang, Shouyi Liu, Wayne Xin Zhao, and Ji-Rong Wen. 2023. Chatdev: Revolutionizing software development with ai-collaborative agents. arXiv preprint arXiv:2307.07924.</li></ul><h3 id=code-summarization>Code Summarization<a hidden class=anchor aria-hidden=true href=#code-summarization>#</a></h3><ul><li>Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing Qin, Ting Liu, and Daxin Jiang. 2020. Codebert: A pre-trained model for programming and natural languages. In EMNLP.</li><li>Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Nan Duan, Ming Zhou, and Daxin Jiang. 2021. Graphcodebert: Pre-training code representations with data flow. In ICLR.</li><li>Wasi U Ahmad, Saikat Chakraborty, Baishakhi Ray, and Kai-Wei Chang. 2021. Unified pre-training for program understanding and generation. In ACL.</li><li>Yue Wang, Shuo Ren, Daya Lu, Duyu Tang, Nan Duan, Ming Zhou, and Daxin Jiang. 2021. Codet5: Identifier-aware unified pre-trained encoder-decoder models for code understanding and generation. In EMNLP.</li><li>Colin B Clement, Andrew Terrell, Hanlin Mao, Joshua Dillon, Sameer Singh, and Dan Alistarh. 2020. Pymt5: Multi-mode translation of natural language and python code with transformers. In EMNLP.</li><li>Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, and 1 others. 2021. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374.</li><li>Raymond Li, Lewis Tunstall, Patrick von Platen, Jungtaek Kim, Teven Le Scao, Thomas Wolf, and Alexander M. Rush. 2023a. Starcoder: May the source be with you! Preprint, arXiv:2305.06161.</li><li>Baptiste Roziere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, Xiaoqing Ellen Tan, Yossi Adi, Jingyu Liu, Romain Sauvestre, Tal Remez, and 1 others. 2023. Code llama: Open foundation models for code. arXiv preprint arXiv:2308.12950.</li></ul><hr><h2 id=优点与创新点-strengths>优点与创新点 (Strengths)<a hidden class=anchor aria-hidden=true href=#优点与创新点-strengths>#</a></h2><ol><li>有图论的理论支撑，通过依赖图和拓扑排序来处理复杂的代码依赖关系。</li><li>试验客观性强，紧紧依赖于代码的AST和正则表达式，避免了人工评估的主观性。</li></ol><hr><h2 id=我的思考-personal-thoughts>我的思考 (Personal Thoughts)<a hidden class=anchor aria-hidden=true href=#我的思考-personal-thoughts>#</a></h2><p>是否可以考虑将DAG图用于通过需求生成复杂业务的代码中？
对于项目级别的代码生成后，能否通过DocAgent类似的方法增加代码注释？</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=http://rextechie.github.io/tags/agent/>Agent</a></li></ul><nav class=paginav><a class=prev href=http://rextechie.github.io/posts/java/springcloud/><span class=title>« Prev</span><br><span>Spring Cloud 原生中间件</span>
</a><a class=next href=http://rextechie.github.io/posts/paper_note/paper2code/><span class=title>Next »</span><br><span>Paper2Code</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on x" href="https://x.com/intent/tweet/?text=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation&amp;url=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f&amp;hashtags=Agent"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f&amp;title=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation&amp;summary=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation&amp;source=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on reddit" href="https://reddit.com/submit?url=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f&title=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on whatsapp" href="https://api.whatsapp.com/send?text=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation%20-%20http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on telegram" href="https://telegram.me/share/url?text=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation&amp;url=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DocAgent: A Multi-Agent System for Automated Code Documentation Generation on ycombinator" href="https://news.ycombinator.com/submitlink?t=DocAgent%3a%20A%20Multi-Agent%20System%20for%20Automated%20Code%20Documentation%20Generation&u=http%3a%2f%2frextechie.github.io%2fposts%2fpaper_note%2fdoc_agent%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=RexTechie/blogcomment issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://rextechie.github.io/>RexBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>