<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>📒论文笔记 | RexBlog</title>
<meta name=keywords content><meta name=description content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><meta name=author content="Rex"><link rel=canonical href=http://rextechie.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.56d5e73e1a36d8bc0a4f450d156a288bf54a46b72e29e3f236c46370aa489a22.css integrity="sha256-VtXnPho22LwKT0UNFWooi/VKRrcuKePyNsRjcKpImiI=" rel="preload stylesheet" as=style><link rel=icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=icon type=image/png sizes=16x16 href=http://rextechie.github.io/favicon/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=apple-touch-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><link rel=mask-icon href=http://rextechie.github.io/favicon/favicon_32x32.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://rextechie.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/index.xml><link rel=alternate hreflang=en href=http://rextechie.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"default",themeVariables:{lineColor:"#fafafa",darkMode:!0},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:url" content="http://rextechie.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="RexBlog"><meta property="og:title" content="📒论文笔记"><meta property="og:description" content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://rextechie.github.io/images/profile.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://rextechie.github.io/images/profile.png"><meta name=twitter:title content="📒论文笔记"><meta name=twitter:description content="探索技术与科研的交融之地 | 分享前沿技术动态、深入解读学术论文 | 用技术视角解读世界的个人笔记"><link rel=stylesheet href=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.css><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/katex.min.js crossorigin=anonymous></script><script defer src=https://cdn.jsdmirror.com/npm/katex@0.16.11/dist/contrib/auto-render.min.js crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})'></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://rextechie.github.io/ accesskey=h title="🏘️Home (Alt + H)"><img src=http://rextechie.github.io/favicon/favicon_32x32.png alt aria-label=logo height=35>🏘️Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://rextechie.github.io/posts/ title="📚 Posts"><span>📚 Posts</span></a></li><li><a href=http://rextechie.github.io/archives/ title="📅 Archives"><span>📅 Archives</span></a></li><li><a href=http://rextechie.github.io/search/ title="🔍 Search (Alt + /)" accesskey=/><span>🔍 Search</span></a></li><li><a href=http://rextechie.github.io/categories/ title="📂 Categories"><span>📂 Categories</span></a></li><li><a href=http://rextechie.github.io/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=http://rextechie.github.io/about/ title="📝 About"><span>📝 About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://rextechie.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://rextechie.github.io/categories/>Categories</a></div><h1>📒论文笔记
<a href=/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Multi-Agent Design: Optimizing Agents with Better Prompts and Topologies</h2></header><div class=entry-content><p>基本信息 标题: Multi-Agent Design: Optimizing Agents with Better Prompts and Topologies 作者: Han Zhou（通讯作者）、Ruoxi Sun、Hamid Palangi、Shariq Iqbal、Ivan Vulić、Anna Korhonen和Sercan Ö. Arık。 作者单位: Google和剑桥大学 期刊/会议: ArXiv 发表年份: 2025.02.04 DOI: 2502.02533 开源地址: Github 关键词: Multi-Agent System, Large Language Models 研究问题 (Research Questions) 大语言模型，作为多个相互交互协作的智能体，可以解决复杂任务。这些智能体通过声明其功能的提示词以及协调智能体间交互的拓扑结构进行编程。本文所研究的主要问题是优化多智能体系统中的提示词以及智能体的拓扑结构。
研究背景 (Background) 尽管最近的研究探讨了自动化智能体设计各个方面，但在理解哪些因素对改进MAS性能最为关键方面仍存在差距。例如，DSPy自动化了设计示例以改进提示编程的过程。J Li(More agents is all you need作者)提出通过扩大多数投票中的代理数量来优化MAS。ADAS通过基于LLM的元代理编程代码表达的新拓扑。AFlow在预定义操作集中使用蒙特卡洛树搜索来寻找更好的拓扑。然而，包括提示词和拓扑在内的多个设计空间之间的相互作用仍然不明确。
核心贡献 (Key Contributions) 深入分析了影响基于LLM的MAS性能的设计因素，强调了prompt的重要性，并确定了有影响力的拓扑结构。 提出了一种名为Mass的新型多阶段优化器，通过在具有影响力的搜索空间中交错优化prompt和拓扑结构来自动化MAS设计。 大量数据在各种评估基准上显示出显著的性能提升，为构建有效的未来多智能体系统提供了指导。 设计多智能体系统（Designing Multi-Agent Systems） 作者认为MAS的设计可以分为两个层级：块级设计(Block-level)和工作流编排(Workflow-level orchestration)。对于块级，目标是设计单个智能体，通过更好的提示词设计最好的提示词来表现出特定的角色。对于工作流编排，它的优化涉及要包含智能体的类型和数量，以及如何以最有效的方式编排他们，这被称为拓扑优化。
$\mathcal{W}^{*}(a)=\arg\max\mathbb{E}_{(x,y)\sim\mathcal{D}}[f(\mathcal{W}(a)(x)),y]$
块级：智能体的提示词设计（Block-level: Prompt Design for Agents） 对于块级，对下游任务影响最主要的是prompt，它定义了智能体的角色（例如，“You are an expert in reflecting on errors…”），提供额外的指令来塑造其行为（例如，“You should think step by step…”）以及可选地包含少量示例（zero-shot/one-shot/few-shot）来指导智能体的回复。比如，一种SOAT提示词优化器同时搜索指令和少量示例，其中示例是从模型自身在验证集上的正确预测中引导出来的，基于验证指标。基于这些示例，提示词优化器会为指令提出一些候选方案，并提供数据集摘要或各种提示词以提高候选方案的多样性。然后指令和示例会被联合优化。...</p></div><footer class=entry-footer><span title='2025-06-19 11:27:17 +0800 +0800'>June 19, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1308 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to Multi-Agent Design: Optimizing Agents with Better Prompts and Topologies" href=http://rextechie.github.io/posts/paper_note/multi_agent_design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DocAgent: A Multi-Agent System for Automated Code Documentation Generation</h2></header><div class=entry-content><p>基本信息 标题: DocAgent: A Multi-Agent System for Automated Code Documentation Generation 作者: Dayu Yang（通讯作者）、Antoine Simoulin、Xin Qian等。 作者单位: Meta AI 期刊/会议: ArXiv 发表年份: 2025.04.11 DOI: 2504.08725 开源地址: Github 关键词: Code Documentation, Multi-Agent System, Large Language Models 研究问题 (Research Questions) 如何自动生成代码文档注释，尤其是处理函数/类中复杂的依赖关系和上下文信息？
研究背景 (Background) 像现在的方法FIM（Fill in the Middle）和 chat agent可以实现自动化生成文档注释，但还是有一些局限性：
省略了必要的信息（例如，参数或返回值描述）。 它们通常提供最少量的上下文或理由，限制了生成文档注释的价值。 由于LLM的幻觉，会虚构不存在的组件，尤其是规模比较大的项目中。 核心贡献 (Key Contributions) DocAgent，一个多智能体、拓扑结构化的上下文感知文档生成系统。 一个衡量代码文档完整性、实用性和事实一致性的稳健评估框架。 全面实验表明，DocAgent在多个数据集中持续优于最先进的基线。 方法 (Methodology) DocAgent分两个阶段来处理复杂的依赖关系并确保上下文的相关性。
用一个Navigator确定一个最佳的依赖感知的处理顺序 Multi-Agent System系统增量地生成文档注释，利用专门的Agent进行代码分析、信息检索、编写文档注释和验证 Navigator: 感知依赖顺序 生成文档注释需要理解依赖代码之间的关系，然而如果给出所有内容，很容易超出上下文窗口的限制。Navigator模块就是为了解决这个问题，Navigator建立了一个处理顺序，确保处理依赖关系之后才对组件做文档注释，从而实现增量上下文构建。
构建依赖图 首先对整个存储库进行静态分析，解析源文件的抽象语法树（AST，Abstract Syntax Tree），以识别代码组件（函数、方法、类）及其相互关系（函数调用、继承、属性方法和模块导入），用一个有向无环图（DAG， Directed Acyclic Graph）来表示，节点是组件，边是依赖关系。为了实现拓扑排序，用Tarjan算法检测图中的循环，并将其浓缩单个超级节点。...</p></div><footer class=entry-footer><span title='2025-06-03 13:11:17 +0800 +0800'>June 3, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;687 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to DocAgent: A Multi-Agent System for Automated Code Documentation Generation" href=http://rextechie.github.io/posts/paper_note/doc_agent/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Paper2Code</h2></header><div class=entry-content><p>基本信息 标题: Paper2Code: Automating Code Generation from Scientific Papers in Machine Learning 作者: Minju Seo, Jinheon Baek, Seongyun Lee, Sung Ju Hwang等。 作者单位: KAIST, DeepAuto.ai 期刊/会议: ArXiv 发表年份: 2025 DOI: 2504.17192v2 开源地址: Github 关键词: Large Language Models (LLMs), Code Generation（Machine Learning） 研究背景 (Background) 尽管机器学习研究的迅速增长，但相应的代码实施通常无法实现，这使研究人员重现结果并在先前的工作基础上进行劳动密集型。同时，最近的大型语言模型（LLMS）在了解科学文档并生成高质量代码方面表现出色。
研究问题 (Research Questions) 用agent复现机器学习相关的论文方法与实验
核心贡献 (Key Contributions) 提出从科研论文自动生成代码的框架: PaperCoder ​​三阶段工作流程​​：PaperCoder框架将代码生成任务分解为三个结构化的阶段，规划、分析、编码。 构建基准数据集（包含90篇来自ICML、NeurIPS和ICLR 2024的论文） 在PaperBench基准测试中的优异表现：在新发布的PaperBench基准测试中，PaperCoder表现出色，显著优于其他强基线方法。 方法（Methods） 作者引入了PaperCoder，是一种新颖的框架，用于实现研究仓库（论文复现出来的代码仓库）的生成。作者将工作过程建模为M(R) = C，其中M是模型，R是论文，C是代码。受软件开发方法的启发，作者采用了一种结构化的方法，该方法反映了良好的经验验证的软件工程原则，即：规划-分析-实现的工作流程。为了实现这一目标，作者将过程分解为三个阶段：1）规划（Planing）. 2）分析（Analyzing）. 3）编码（Coding）。每个阶段都利用多智能体方案。更加规范化的定义是C = M (P) = M_code(R, P, A)，其中R是论文，P是规划，A是分析。每个部分的生成遵循：P = M_plan(R), A = M_analysis(R, P) and C = M_code(R, P, A)。完整的流程如下图所示：...</p></div><footer class=entry-footer><span title='2025-05-12 13:41:31 +0800 +0800'>May 12, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;315 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to Paper2Code" href=http://rextechie.github.io/posts/paper_note/paper2code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving</h2></header><div class=entry-content><p>基本信息 标题: PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving 作者: Mihir Parmar、Xin Liu等 作者单位: Google、Arizona State University 期刊/会议: ArXiv 发表年份: 2025 DOI: 2502.16111 开源地址: 🈚️ 关键词: Agent 研究背景与问题 (Background & Questions) 有效的计划是设计在解决复杂现实世界问题的系统的关键组件。传统的用模板化的方式缺乏通用性。 LLM 可以较好的做一些规划任务，比如用 LLM 在自然语言中做规划可以解决一些代码问题。因此作者考虑增强 LLM 生成计划的能力，并证明其在科学和金融领域下游任务的实用性。
核心贡献 (Key Contributions) 总结本文的主要贡献点：
PlanGEN，一种新颖的、模型无关的、可扩展的多智能体框架，用于增强LLM的自然规划。 在一些复杂规划和推理的 Benchmarks 上达到了 SOTA 级别。 一种基于约束的验证和基于实例级复杂性的推理算法选择的新方法。 PlanGEN LLM Agents PlanGEN 包括三个 大模型 Agent：Constraint Agent、 Verification Agent 和一个 Selection Agent。每个Agent使用现成的 LLM（如：Gemini, GPT）。...</p></div><footer class=entry-footer><span title='2025-03-25 11:52:08 +0800 +0800'>March 25, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to PlanGEN: A Multi-Agent Framework for Generating Planning and Reasoning Trajectories for Complex Problem Solving" href=http://rextechie.github.io/posts/paper_note/plangen/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework</h2></header><div class=entry-content><p>基本信息 标题: MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework 作者: Sirui Hong、Mingchen Zhuge、Chenglin Wu（通讯作者）等。 作者单位: DeepWisdom、阿卜杜拉国王科技大学、厦门大学、香港中文大学、南京大学、宾夕法尼亚大学、加州大学伯克利分校、瑞士人工智能实验室 期刊/会议: ICLR 2023 发表年份: 2023 DOI: 2308.00352 开源地址: Github 关键词: MetaGPT, Multi-Agent Collaboration, Standardized Operating Procedures (SOPs), Large Language Models (LLMs), Code Generation 研究背景 (Background) 利用大语言模型的Agent为增强和复制人类的工作流程提供了机会。但是实际应用中，现有系统将复杂问题过度简化。很多人想努力实现有效、连贯和准确的解决问题，尤其是需要协作的任务。而SOP可以有效的分解任务并且协调各个任务，明确的SOPs能够提高任务执行的一致性和准确性，确保其与定义的角色和质量标准相符。
研究问题 (Research Questions) 如何使用应用SOPs与Agent协作开发。 如何优化Agent协作通信能力。 如何提高代码生成的质量。 核心贡献 (Key Contributions) 总结本文的主要贡献点：
引入了MetaGPT，一个基于LLM的多智能体协作元编程框架。 作者在MetaGPT设计中创新性地集成了SOP，减少了LLM的代理之间的无效协作。此外，还引入了一种新颖的执行反馈机制，可以在运行时调试和执行代码，从而提高了代码生成的质量（MBPP上提高了5.4%） 在HumanEval和MBPP达到了SOAT MetaGPT 框架 (MetaGPT Framework) SOP中的Agent（Agents in Stanndard Operating Procedures） 角色的特定职能 解决复杂的任务或问题通常需要具有不同技能和专业知识的智能体协作，每个智能体都针对特定问题提供专门的输出。如在一家软件公司，产品经理的任务是分析业务、软件工程师负责编程开发。因此MetaGPT定义了五个角色：产品经理（Product Manager）、架构师（Architect）、项目经理（Project Manager）、工程师（Engineer）以及QA工程师（QA Engineer）。如下面图1所示： 图1：MetaGPT与真实世界人类团队之间的软件开发SOPs。...</p></div><footer class=entry-footer><span title='2025-01-07 20:39:47 +0800 +0800'>January 7, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;257 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework" href=http://rextechie.github.io/posts/paper_note/metagpt/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Evaluating Large Language Models Trained on Code</h2></header><div class=entry-content><p>基本信息 标题: Evaluating Large Language Models Trained on Code 作者: Mark Chen、Jerry Tworek、Heewoo Jun、Qiming Yuan等 作者单位: OpenAI, Anthropic AI, Zipline 期刊/会议: arXiv 发表时间: 2021年7月14日 DOI: 2107.03374 开源地址: GitHub 关键词: 代码生成, 代码评估, 代码理解 研究背景(Background) 对于代码生成任务由于语言模型的推动最早的研究在1963、1971年就开始了（Experiments with a heuristic compiler、Toward automatic program synthesis）,最近的有基于掩码语言模型(masked language modeling)和跨度预测(span prediction)改编用于训练其编程对应物的有CodeBert和PyMT5。OpenAI在GPT3发布的时候，就已经可以通过文档注释(docstrings)生成python代码了，但是能力还是比较有限。
研究目标(Research Objectives) 提出一种评估大型语言模型生成代码能力的方法，包括pass@k指标和HumanEval数据集。 提出Codex，通过对GPT-3进行微调。 提出Codex-S，通过有监督微调Codex。 提出Codex-D，通过训练docstring生成模型。 评估框架 (Evaluation Framework) 作者定义了pass@k指标，以及HumanEval数据集，用于评估Codex的性能。
功能的正确性(Functional Correctness) 评估生成质量可以通过匹配的方式：精确匹配或模糊匹配（如BLEU得分）。然而有研究揭示了基于匹配的代码评估指标的不足。如论文CodeBLEU: a Method for Automatic Evaluation of Code Synthesis中发现BLEU在捕捉代码特有的语义特征方面存在问题，并建议对分数进行几个语义的修改。更加根本的问题是，基于匹配的方式无法评估庞大的并且复杂的代码。近期无监督的代码翻译或伪代码到代码的翻译相关问题也转向了功能性准确性的评估，如果样本通过了测试用例，那么就认为生成的代码是正确的。作者认为这种方式应用到代码生成的评估中是合理的。评估功能正确性最有说服力的理由是程序员常使用这种方式进行评估（单元测试）。
Kual等人在2019(SPoC: Search-based Pseudocode to Code)就用了pass@k，对于每个问题生成k个代码样本，如果其中有一个样本通过了单元测试就认为问题已得到了解决，并计算解决问题的总比例。然而作者认为以这种方式计算pass@k会有很高的方差，而且计算量大。相反，为了评估pass@k，我们给每个任务生成n个样本（n > k, 论文中使用n = 200, k = 100）, 统计通过单元测试的正确样本数c（c &lt;= n），并计算无偏估计量。其中 $\text{pass@}k := \mathbb{E}_{\text{Problems}} \left[ 1 - \frac{\binom{n-c}{k}}{\binom{n}{k}} \right]$。...</p></div><footer class=entry-footer><span title='2025-01-01 14:47:39 +0800 +0800'>January 1, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Rex</footer><a class=entry-link aria-label="post link to Evaluating Large Language Models Trained on Code" href=http://rextechie.github.io/posts/paper_note/human_eval/></a></article></main><footer class=footer><span>&copy; 2025 <a href=http://rextechie.github.io/>RexBlog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>